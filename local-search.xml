<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>readme</title>
    <link href="/2020/04/03/README/"/>
    <url>/2020/04/03/README/</url>
    
    <content type="html"><![CDATA[<p align="center">  <img alt="Fluid Logo" src="https://avatars2.githubusercontent.com/t/3419353?s=280&v=4" srcset="/img/loading.gif" width="128"></p><p align="center">一款 Material Design 风格的主题</p><p align="center">An elegant Material-Design theme for Hexo</p><p><img src="https://cdn.jsdelivr.net/gh/fluid-dev/static@master/hexo-theme-fluid/screenshots/index.png" srcset="/img/loading.gif" alt="ScreenShot"></p><p align="center">  <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases" target="_blank" rel="noopener"><img alt="GitHub release (latest by date)" src="https://img.shields.io/github/v/release/fluid-dev/hexo-theme-fluid" srcset="/img/loading.gif"></a>  <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener"><img alt="Hexo version" src="https://img.shields.io/badge/Hexo-3%2B-orange" srcset="/img/loading.gif"></a>  <a href="https://github.com/fluid-dev/hexo-theme-fluid/graphs/contributors" target="_blank" rel="noopener"><img alt="Contributors" src="https://img.shields.io/github/contributors/fluid-dev/hexo-theme-fluid.svg?style=flat" srcset="/img/loading.gif"></a>  <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/LICENSE" target="_blank" rel="noopener"><img alt="License" src="https://img.shields.io/github/license/fluid-dev/hexo-theme-fluid.svg?style=flat" srcset="/img/loading.gif"></a></p><p align="center">中文简体  |  <a title="English" href="README_en.md">English</a></p><p align="center">  <span>文档：</span>  <a href="https://hexo.fluid-dev.com/docs/" target="_blank" rel="noopener">用户手册</a>&nbsp&nbsp&nbsp&nbsp  <a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">文章配置</a></p><p align="center">  <span>预览：</span>  <a href="https://hexo.fluid-dev.com/" target="_blank" rel="noopener">demo</a>&nbsp&nbsp&nbsp&nbsp  <a href="https://zkqiang.cn" target="_blank" rel="noopener">zkqiang's blog</a></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h4 id="1-搭建-Hexo-博客"><a href="#1-搭建-Hexo-博客" class="headerlink" title="1. 搭建 Hexo 博客"></a>1. 搭建 Hexo 博客</h4><p>如果你还没有 Hexo 博客，请按照 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a> 进行安装、建站。</p><h4 id="2-获取主题最新版本"><a href="#2-获取主题最新版本" class="headerlink" title="2. 获取主题最新版本"></a>2. 获取主题最新版本</h4><p>请优先下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases" target="_blank" rel="noopener">最新 release 版本</a>，master 分支无法保证稳定。</p><p>下载后解压到 themes 目录下并重命名为 <code>fluid</code>。</p><h4 id="3-指定主题"><a href="#3-指定主题" class="headerlink" title="3. 指定主题"></a>3. 指定主题</h4><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>：</p><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，可不改</span></code></pre><h4 id="4-创建「关于页」"><a href="#4-创建「关于页」" class="headerlink" title="4. 创建「关于页」"></a>4. 创建「关于页」</h4><p>自 v1.7.0 开始，「关于页」需要手动创建：</p><pre><code class="hljs bash">$ hexo new page about</code></pre><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><pre><code class="hljs yml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-23</span> <span class="hljs-number">19</span><span class="hljs-string">:20:33</span><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><span class="hljs-meta">---</span><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span></code></pre><h2 id="升级主题"><a href="#升级主题" class="headerlink" title="升级主题"></a>升级主题</h2><p>首先强烈建议学习使用<a href="https://hexo.fluid-dev.com/docs/guide/#%E8%A6%86%E7%9B%96%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">覆盖配置</a></p><p>然后升级步骤<a href="https://hexo.fluid-dev.com/docs/example/#%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%A2%98" target="_blank" rel="noopener">参照这里</a></p><h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><ul><li><input checked="" disabled="" type="checkbox"> 图片懒加载</li><li><input checked="" disabled="" type="checkbox"> 自定义代码高亮方案</li><li><input checked="" disabled="" type="checkbox"> 内置多语言</li><li><input checked="" disabled="" type="checkbox"> 支持多款评论插件</li><li><input checked="" disabled="" type="checkbox"> 支持使用<a href="https://hexo.io/zh-cn/docs/data-files" target="_blank" rel="noopener">数据文件</a>存放配置</li><li><input checked="" disabled="" type="checkbox"> 自定义静态资源 CDN</li><li><input checked="" disabled="" type="checkbox"> 无比详实的<a href="https://hexo.fluid-dev.com/docs/" target="_blank" rel="noopener">用户文档</a></li><li><input checked="" disabled="" type="checkbox"> 内置文章搜索</li><li><input checked="" disabled="" type="checkbox"> 页脚备案信息</li><li><input checked="" disabled="" type="checkbox"> 网页访问统计</li><li><input checked="" disabled="" type="checkbox"> 支持 LaTeX 数学公式</li><li><input checked="" disabled="" type="checkbox"> 支持 mermaid 流程图</li><li><input checked="" disabled="" type="checkbox"> 音乐播放器</li></ul><h2 id="贡献者"><a href="#贡献者" class="headerlink" title="贡献者"></a>贡献者</h2><p><a href="https://github.com/fluid-dev/hexo-theme-fluid/graphs/contributors" target="_blank" rel="noopener"><img src="https://opencollective.com/hexo-theme-fluid/contributors.svg?width=890&button=false" srcset="/img/loading.gif" alt="contributors"></a></p><p>英文文档翻译：<a href="https://eatrice.top/" target="_blank" rel="noopener">@EatRice</a> <a href="https://ruru.eatrice.top" target="_blank" rel="noopener">@橙子杀手</a></p><p>其他贡献：<a href="https://github.com/zhugaoqi" target="_blank" rel="noopener">@zhugaoqi</a> <a href="https://github.com/julydate" target="_blank" rel="noopener">@julydate</a></p><p>如你也想贡献代码，可参照<a href="https://hexo.fluid-dev.com/docs/contribute/" target="_blank" rel="noopener">贡献指南</a></p><h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><p>微信群：扫描二维码添加好友进交流群</p><details>    <summary>二维码</summary>    <p><b>在聊天中发送「fluid」（不是在好友验证中）自动拉群</b></p>    <p><b>该微信仅用于拉群，不进行答疑</b></p>    <img width="200" src="https://cdn.jsdelivr.net/gh/fluid-dev/static@master/hexo-theme-fluid/wechat.jpeg" srcset="/img/loading.gif" alt="wechat"></details><h2 id="赞助"><a href="#赞助" class="headerlink" title="赞助"></a>赞助</h2><p>你可以通过下方二维码赞助本项目，资金将用于服务器开销以及今后的公共接口服务</p><details>    <summary>二维码</summary>    <img width="600" src="https://cdn.jsdelivr.net/gh/fluid-dev/static@master/hexo-theme-fluid/sponsor.png" srcset="/img/loading.gif" alt="sponsor"></details><p>其他商业赞助可发送邮件至 zkqiang#126.com (#替换为@)</p><h2 id="Star-趋势"><a href="#Star-趋势" class="headerlink" title="Star 趋势"></a>Star 趋势</h2><p><a href="https://starchart.cc/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener"><img src="https://starchart.cc/fluid-dev/hexo-theme-fluid.svg" srcset="/img/loading.gif" alt="Stargazers over time"></a></p>]]></content>
    
    
    <categories>
      
      <category>readme</category>
      
    </categories>
    
    
    <tags>
      
      <tag>readme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建Linux内核函数的man手册</title>
    <link href="/2019/08/05/%E5%88%9B%E5%BB%BALinux%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E7%9A%84man%E6%89%8B%E5%86%8C/"/>
    <url>/2019/08/05/%E5%88%9B%E5%BB%BALinux%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E7%9A%84man%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<p>自带的man手册只能查询C库的函数和linux系统调用，不能查询linux内核函数。如果做驱动开发，就很不方便查询linux的内核函数。<strong>我们可以通过linux内核生成Man手册</strong>。</p><ul><li>下载linux内核源码，并且编译通过</li><li>在顶层目录下执行,这一步时间有点长</li></ul><pre><code class="hljs bash">make mandocs</code></pre><ul><li>安装man手册，就是把生成的文件拷贝到系统目录下，因此需要sudo权限</li></ul><pre><code class="hljs bash">sudo make installmandocs</code></pre><ul><li>如果第一步出现错误，则执行下面的命令</li></ul><pre><code class="hljs bash">sudo apt-get install xmlto</code></pre><p>linux的内核函数在man 9中<br>执行<strong>man 9 register_chrdev</strong>效果如下：</p><p><img src="/img/%E5%88%9B%E5%BB%BALinux%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E7%9A%84man%E6%89%8B%E5%86%8C/1.svg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Linux环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式概述</title>
    <link href="/2019/08/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
    <url>/2019/08/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一个目标"><a href="#一个目标" class="headerlink" title="一个目标"></a>一个目标</h3><p><strong>管理变化，提高复用</strong></p><h3 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h3><p><strong>稳定点和变化点</strong><br><strong>抽象类和接口</strong></p><h3 id="两个手段"><a href="#两个手段" class="headerlink" title="两个手段"></a>两个手段</h3><ul><li><strong>分解</strong></li><li><strong>抽象</strong></li></ul><h3 id="八大原则"><a href="#八大原则" class="headerlink" title="八大原则"></a>八大原则</h3><ul><li>依赖倒置原则 DIP</li><li>开放封闭原则 OCP</li><li>单一职责原则 SRP</li><li>Liskov替换原则 LSP</li><li>接口隔离原则 ISP</li><li>对象组合优于类继承</li><li>封装变化点</li><li>面向接口编程</li></ul><h3 id="重构技巧"><a href="#重构技巧" class="headerlink" title="重构技巧"></a>重构技巧</h3><ul><li>静态  》》》 动态</li><li>早绑定 》》》 晚绑定</li><li>继承 》》》 组合</li><li>编译时依赖 》》》 运行时依赖</li><li>紧耦合 》》》  松耦合</li></ul><h3 id="什么时候不用模式"><a href="#什么时候不用模式" class="headerlink" title="什么时候不用模式"></a>什么时候不用模式</h3><ul><li>代码可读写很差</li><li>需求理解很浅</li><li>变化没有显现</li><li>不是系统的关键依赖点</li><li>项目没有复用价值</li><li>项目将要发布</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式</title>
    <link href="/2019/08/02/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/08/02/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>适配器模式，又叫<strong>Adapter</strong>模式，属于<strong>接口隔离</strong>模式的一种，常用于framework中新老接口的更新。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 — 《设计模式》 GoF</p><h3 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h3><p>在软件系统中，通常可以使用目标类的接口访问它所提供的服务，但是有时现有的类的实现可以满足客户的需要但是接口并不能满足客户的需求，这可能是现有类的方法名称与目标类的方法名不一致导致的，因此这时候就需要使用适配器模式，<strong>将现有类的接口转化为客户需要的类的接口</strong>，这个包装的类就叫<strong>适配器</strong>，它所包装的类叫被适配的类。</p><p>日常生活中也有这样的例子，如电源适配器，将220V的AC转换为12V的DC，等等</p><h3 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h3><ul><li>Target：目标接口</li><li>Adapter：适配器类，包装原有接口，重写目标接口的方法，类中组合了一个适配者类，这种适配器模式叫<strong>对象适配器</strong>，相比于<strong>类适配器</strong>更加灵活</li><li>Adaptee：适配者类</li><li>Client：客户类</li></ul><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p><strong>旧接口</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IAdaptee</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:IAdaptee();~IAdaptee();<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;&#125;;</code></pre><p><strong>旧接口的具体实现</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OldClass</span> :</span> <span class="hljs-keyword">public</span> IAdaptee&#123;<span class="hljs-keyword">public</span>:OldClass();~OldClass();<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span></span>;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OldClass::step1</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"step 1 running \n"</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OldClass::step2</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"step 2 running \n"</span>;&#125;</code></pre><p><strong>目标接口</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ITarget</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:ITarget();<span class="hljs-keyword">virtual</span> ~ITarget() = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;&#125;;</code></pre><p><strong>适配器</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IAdapter</span> :</span> <span class="hljs-keyword">public</span> ITarget&#123;IAdaptee *adaptee;<span class="hljs-keyword">public</span>:IAdapter(IAdaptee *adaptee);~IAdapter();<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;&#125;;IAdapter::IAdapter(IAdaptee *adaptee)&#123;<span class="hljs-keyword">this</span>-&gt;adaptee = adaptee;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IAdapter::process</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;adaptee-&gt;step1();adaptee-&gt;step2();&#125;</code></pre><p><strong>main函数</strong></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;IAdaptee *adaptee = <span class="hljs-keyword">new</span> OldClass;ITarget *target = <span class="hljs-keyword">new</span> IAdapter(adaptee);target-&gt;<span class="hljs-built_in">process</span>();&#125;</code></pre><ul><li>运行结果</li></ul><ul><li>在main函数中指定具体的实现，达到晚绑定的效果</li><li>适配器类继承目标接口，组合旧的接口，调用旧接口的方法重写新的接口函数，实现接口的转换</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>享元模式</title>
    <link href="/2019/08/01/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/08/01/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>享元模式，又叫<strong>Flyweight</strong>，属于<strong>对象性能</strong>模式中的一种，主要解决<strong>系统中大量的细粒度的对象</strong>而带来不必要的系统开销，主要是指内存方面的开销。</p><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>运用共享技术有效地支持大量细粒度的对象。 —《设计模式》 GoF</p><h3 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h3><p>系统中有大量的对象时，而且这些对象有些之间是相同的，或者说可以把这些对象分为几类，这种情况就可以使用相同的一类对象合并成使用相同的一个对象，因此系统就由之前<strong>很多重复的几类对象变为几个互不相同的对象</strong>，大大节约了系统的内存开销。<br>如何辨别这些对象是相同的？可以传入一个键值作为唯一标识码，如果这个键值相同，则返回其对应的对象，无需重复创建。</p><p>需要注意的事项，由于在内存中是多个业务共享了一个对象，为了避免改变这个对象，因此这个对象应该是只读的。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>假如现在需要画10个圆，现在有3中颜色，正常的设计应该是每一个圆对应一个对象，然后分别画出，但是由于每个圆的颜色只有3中，因此只要是颜色相同的圆，我们就可以使用同一个对象来创建，因此只需要3个对象即可。</p><p><strong>画圆类</strong></p><p>包括一个画圆的函数和string类型的颜色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Circle</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Circle(std::string color);</span><br><span class="line">~Circle();</span><br><span class="line">std::string color;</span><br><span class="line">virtual void shape();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Circle::Circle(std::string color)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;color &#x3D; color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Circle::shape()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;shape circle : &quot; &lt;&lt; this-&gt;color &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>画圆工厂类</strong></p><p>使用享元模式产生一个画圆的对象，使用一个map容器来存储所有互不相同的对象，这些对象通过颜色来区分，因此使用颜色作为键值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class ShapeFactory</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">&#x2F;* 创建一个对象池存储所有的对象，这是一个散列表，通过color找到对应的对象 *&#x2F;</span><br><span class="line">std::map &lt;std::string, Circle* &gt;  Circlepool;</span><br><span class="line">public:</span><br><span class="line">ShapeFactory();</span><br><span class="line">~ShapeFactory();</span><br><span class="line"></span><br><span class="line">Circle* createCircle(std::string color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Circle* ShapeFactory::createCircle(std::string color)</span><br><span class="line">&#123;</span><br><span class="line">std::map &lt;std::string, Circle*&gt; ::iterator item &#x3D; Circlepool.find(color);</span><br><span class="line">&#x2F;* 查找是否已经创建过了 *&#x2F;</span><br><span class="line">if (item !&#x3D; Circlepool.end())</span><br><span class="line">&#123;</span><br><span class="line">return Circlepool[color];</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;create new circle \n&quot;;</span><br><span class="line">Circle *circle &#x3D; new Circle(color);</span><br><span class="line">Circlepool[color] &#x3D; circle;</span><br><span class="line">return circle;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main函数</strong></p><p>先构造一个工厂，再调用createCircle产生对象，是否产生了新对象有内部的享元模式进行判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ShapeFactory *shapefactory &#x3D; new ShapeFactory;</span><br><span class="line">Circle *circle1 &#x3D; shapefactory-&gt;createCircle(&quot;red&quot;);</span><br><span class="line">circle1-&gt;shape();</span><br><span class="line"></span><br><span class="line">Circle *circle2 &#x3D; shapefactory-&gt;createCircle(&quot;red&quot;);</span><br><span class="line">circle2-&gt;shape();</span><br><span class="line"></span><br><span class="line">Circle *circle3 &#x3D; shapefactory-&gt;createCircle(&quot;blue&quot;);</span><br><span class="line">circle3-&gt;shape();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>可以看到，创建第二个红色圆形的时候并没有创建新的对象，而是使用了第一个创建的对象，而创建第三份白色圆的时候又创建了新的对象，这就是使用享元模式创建对象的过程。</p>]]></content>
    
    
    <categories>
      
      <category>C++设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象工厂</title>
    <link href="/2019/07/30/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <url>/2019/07/30/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</url>
    
    <content type="html"><![CDATA[<p>抽象工厂模式，又称<strong>Abstract Factory</strong>模式，相对于工厂模式，抽象工厂模式是<strong>将几个具有关联性的对象合并在一个工厂中创建</strong>。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>提供一个接口，让该接口负责创建一系列“相关或者相互依 赖的对象”，无需指定它们具体的类。   — 《设计模式》 GoF</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在工厂模式中，一个工厂接口产生一个抽象的工厂对象，一组具体的工厂产生每一个具体的对象，重载工厂方法，但是在实际使用中，我们有时候需要产生多个抽象的对象，并且每一个抽象的对象都对应各种不同的具体对象，这时我们可以<strong>使用抽象工厂将这些抽象的对象放在一个工厂中产生，下面的工厂继承抽象工厂，重载工厂方法返回一组具体的对象。</strong></p><p>抽象工厂方法可以产生一个产品族中的所有对象，比工厂方法效率更高，更简单。</p><p>Abstract Factory模式主要在于<strong>应对“新系列”的需求变动,其缺点在于难以应对“新对象”的需求变动</strong>。</p><h3 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h3><ul><li>AbstractFactory：抽象工厂，返回多个产品</li><li>ConcreteFactory：具体工厂，返回多个具体的产品</li><li>AbstractProduct ： 抽象产品，多个抽象产品组成产品族</li><li>Product： 具体产品</li></ul><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>本文举一个数据库操作的例子，数据库操作需要分为先获取指令，再连接两个步骤，而数据库又有不同的类型，如Sql和Oracle,可以把获取指令和连接看成两个抽象的产品，每个数据库对应这两个步骤有不同的操作，看着具体的产品，使用抽象工厂方法设计。</p><blockquote><p>这种连个维度的变化联想到了桥模式,但是这里不适合使用桥模式，原因在于获取指令和连接两个步骤对于不同的数据库来说不是随机组合的，而是绑定的，即如果获取指令使用的是Sql数据库，那么连接也必须是Sql数据库。</p></blockquote><p><strong>抽象产品</strong></p><p>抽象产品是指获取指令和连接两个类，都是接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class IDBCommand</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">IDBCommand();</span><br><span class="line">~IDBCommand();</span><br><span class="line"></span><br><span class="line">virtual void getCommond() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IDBConnection</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">IDBConnection();</span><br><span class="line">~IDBConnection();</span><br><span class="line"></span><br><span class="line">virtual void getConnection() &#x3D; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>具体的产品</strong></p><p>具体的产品分别继承自抽象产品，每个操作下面分别对应两个数据库，因此具体的产品有4种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class OracleCommand : public  IDBCommand</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">OracleCommand();</span><br><span class="line">virtual ~OracleCommand();</span><br><span class="line"></span><br><span class="line">virtual void getCommond();</span><br><span class="line">&#125;;</span><br><span class="line">void OracleCommand::getCommond()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;get oracle commond... \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OracleConnection : public IDBConnection</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">OracleConnection();</span><br><span class="line">virtual ~OracleConnection();</span><br><span class="line"></span><br><span class="line">virtual void getConnection();</span><br><span class="line">&#125;;</span><br><span class="line">void OracleConnection::getConnection()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;get oracle Connection... \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SqlCommand : public IDBCommand</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">SqlCommand();</span><br><span class="line">~SqlCommand();</span><br><span class="line"></span><br><span class="line">virtual void getCommond();</span><br><span class="line">&#125;;</span><br><span class="line">void SqlCommand::getCommond()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;get Sql commond... \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SqlConnection : public IDBConnection</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">SqlConnection();</span><br><span class="line">~SqlConnection();</span><br><span class="line"></span><br><span class="line">virtual void getConnection();</span><br><span class="line">&#125;;</span><br><span class="line">void SqlConnection::getConnection()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;get Sql Connection... \n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象工厂</strong></p><p>抽象工厂负责产生两个产品，即获取指令和连接<br>具体产生什么产品，放在具体的工厂中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class IDBFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">IDBFactory();</span><br><span class="line">~IDBFactory();</span><br><span class="line"></span><br><span class="line">virtual IDBCommand *getIDBCommand()    &#x3D; 0;</span><br><span class="line">virtual IDBConnection *getIDBConnection() &#x3D; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>具体的工厂</strong></p><p>负责产生Sql对应的产品和Oracle对应的产品</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class SqlDBFactory : public IDBFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">SqlDBFactory();</span><br><span class="line">~SqlDBFactory();</span><br><span class="line"></span><br><span class="line">virtual IDBCommand *getIDBCommand();</span><br><span class="line">virtual IDBConnection *getIDBConnection();</span><br><span class="line">&#125;;</span><br><span class="line">IDBCommand * SqlDBFactory::getIDBCommand()</span><br><span class="line">&#123;</span><br><span class="line">return new SqlCommand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IDBConnection * SqlDBFactory::getIDBConnection()</span><br><span class="line">&#123;</span><br><span class="line">return new SqlConnection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OracleDBFactory : public IDBFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">OracleDBFactory();</span><br><span class="line">~OracleDBFactory();</span><br><span class="line"></span><br><span class="line">virtual IDBCommand *getIDBCommand();</span><br><span class="line">virtual IDBConnection *getIDBConnection();</span><br><span class="line">&#125;;</span><br><span class="line">IDBCommand * OracleDBFactory::getIDBCommand()</span><br><span class="line">&#123;</span><br><span class="line">return new OracleCommand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IDBConnection * OracleDBFactory::getIDBConnection()</span><br><span class="line">&#123;</span><br><span class="line">return new OracleConnection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MainForm类</strong></p><p>这个类模拟使用数据库的类,这个类首先传入具体的工厂产生两个具体的产品，然后分别调用里面的函数。</p><p>MainForm作为上层应用应该是<strong>稳定的</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class MainForm</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">MainForm(IDBFactory *dbfactory);</span><br><span class="line">~MainForm();</span><br><span class="line"></span><br><span class="line">IDBFactory *dbfactory;</span><br><span class="line"></span><br><span class="line">void getdata();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MainForm::MainForm(IDBFactory *dbfactory)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;dbfactory &#x3D; dbfactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainForm::~MainForm()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainForm::getdata()</span><br><span class="line">&#123;</span><br><span class="line">IDBCommand *dbcommand &#x3D;dbfactory-&gt;getIDBCommand();</span><br><span class="line">IDBConnection *dbconnection &#x3D; dbfactory-&gt;getIDBConnection();</span><br><span class="line"></span><br><span class="line">dbcommand-&gt;getCommond();</span><br><span class="line">dbconnection-&gt;getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main函数测试</strong></p><p>先使用多态的方法创建一个工厂，再把这个工厂传入MainForm中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">IDBFactory *dbfactory   &#x3D; new SqlDBFactory;</span><br><span class="line">MainForm   *mainform    &#x3D; new MainForm(dbfactory);</span><br><span class="line">mainform-&gt;getdata();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2019/07/28/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/07/28/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>策略模式，又称<strong>strategy</strong>模式，是用于封装多样性的算法，避免支持不使用的算法带来的性能负担。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。             — 《设计模式》     GoF</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在软件系统中，常常会遇到许多算法可以实现同一功能的情况，可以将这些算法写到一个类中，通过if…else来判断和选择，如果需要增加一种算法，则需要修改代码，增加分支，违背了设计模式的<strong>封闭原则</strong>。</p><p>更好的方法是将这些算法分别写在单独的类中，在客户端中使用这些算法子类的抽象接口，在运行时使用多态来决定具体使用哪一个算法。</p><h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><ul><li>Strategy : 算法的抽象接口</li><li>ConcreteStrategy A/B/C : 具体的不同的算法</li><li>Context : 算法使用的上下文</li></ul><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>例子程序使用策略模式实现了一个加减乘除的计算功能。</p><p><strong>算法抽象接口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Calculate</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual ~Calculate();</span><br><span class="line">virtual float calculate(float a , float b) &#x3D; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>不同的算法子类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Add : public Calculate</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Add();</span><br><span class="line">~Add();</span><br><span class="line"></span><br><span class="line">float calculate(float a, float b);</span><br><span class="line">&#125;;</span><br><span class="line">float Add::calculate(float a, float b)</span><br><span class="line">&#123;</span><br><span class="line">return (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sub : public Calculate</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Sub();</span><br><span class="line">~Sub();</span><br><span class="line"></span><br><span class="line">float calculate(float a, float b);</span><br><span class="line">&#125;;</span><br><span class="line">float Sub::calculate(float a, float b)</span><br><span class="line">&#123;</span><br><span class="line">return (a - b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mul : public Calculate</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Mul();</span><br><span class="line">~Mul();</span><br><span class="line"></span><br><span class="line">float calculate(float a, float b);</span><br><span class="line">&#125;;</span><br><span class="line">float Mul::calculate(float a, float b)</span><br><span class="line">&#123;</span><br><span class="line">return (a * b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Div : public Calculate</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Div();</span><br><span class="line">~Div();</span><br><span class="line"></span><br><span class="line">float calculate(float a, float b);</span><br><span class="line">&#125;;</span><br><span class="line">float Div::calculate(float a, float b)</span><br><span class="line">&#123;</span><br><span class="line">return (a &#x2F; b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用算法的上下文</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class CalOrder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">CalOrder(Calculate *Cal, int a, int b);</span><br><span class="line">~CalOrder();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">Calculate *p_Cal;</span><br><span class="line">int data1;</span><br><span class="line">int data2;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">float calculate();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CalOrder::CalOrder (Calculate *Cal, int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;p_Cal &#x3D; Cal;</span><br><span class="line">this-&gt;data1 &#x3D; a;</span><br><span class="line">this-&gt;data2 &#x3D; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CalOrder::~CalOrder()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float CalOrder::calculate()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;p_Cal-&gt;calculate(this-&gt;data1, this-&gt;data2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main函数测试</strong><br>定义了一个具体的算法，和使用算法的上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Calculate *cal &#x3D; new Add;</span><br><span class="line">CalOrder *caloder &#x3D; new CalOrder(cal, 1, 2);</span><br><span class="line">std::cout &lt;&lt; &quot;ADD : &quot; &lt;&lt; caloder-&gt;calculate() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>策略模式属于<strong>组件协作</strong>模式的一种，基本思想是通过框架和应用程序的<strong>晚期绑定</strong>（手段：虚函数），实现框架和应用之间的松耦合。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/2019/07/28/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/07/28/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>工厂模式又称Factory Method，属于<strong>对象创建</strong>模式中的一种，用来支持对象稳定的创建。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。    — 《设计模式》  GoF</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>根据设计模式的依赖倒置原则，1 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口，2抽象接口不应该依赖于具体实现，而具体实现则应该依赖于抽象接口，因此如果代码像下面这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybook *book &#x3D; new Mathbook;</span><br></pre></td></tr></table></figure><p>这种写法虽然定义虽然是面向接口编程，但是new的却是一个具体的类，因此不符合依赖倒置原则，那么如何创建对象才符合DIP原则呢？</p><p>这就是工厂模式需要解决的问题，创建一个工厂类，通过内部的方法返回一个具体的对象。</p><p>具体实施方法：</p><ul><li>创建一个工厂接口，提供返回对象的纯虚方法</li><li>对于每一个具体的子类，创建一个具体的工厂类继承工厂接口</li></ul><p>缺点：</p><ul><li>要求每一个子类的构造方法的参数相同</li></ul><h3 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h3><ul><li>Creator : 需要产生对象的接口</li><li>Concretecreator : 需要产生对象的具体类</li><li>Product : 工厂类，负责产生具体的Concretecreator对象</li></ul><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p><strong>书本抽象类</strong></p><p>书本抽象类是所有书类的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Book</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Book();</span><br><span class="line">virtual ~Book();</span><br><span class="line">virtual void getbookname() &#x3D; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>两个书本类</strong></p><p>两个书本类是书本抽象类的实例化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class EnglishBook : public Book</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">EnglishBook();</span><br><span class="line">virtual ~EnglishBook();</span><br><span class="line">virtual void getbookname();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void EnglishBook::getbookname()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;this is English book\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MathBook : public Book</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">MathBook();</span><br><span class="line">virtual ~MathBook();</span><br><span class="line">virtual void getbookname();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void MathBook::getbookname()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;this is math book \n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工厂类的接口</strong></p><p>工厂类的接口是所有工厂子类的父类，每一个书本类都有对应的一个工厂类，在运行时决定采用哪个工厂类返回哪种类型的书本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class BookFactory </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    BookFactory();</span><br><span class="line">virtual ~BookFactory();</span><br><span class="line">virtual Book *Createbook() &#x3D; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>具体的工厂类</strong></p><p>每一个需要创建的子类都对应一个具体的工厂类，这个类负责返回这个子类的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class EnglishBookFactory : public BookFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">EnglishBookFactory();</span><br><span class="line">~EnglishBookFactory();</span><br><span class="line"></span><br><span class="line">virtual Book *Createbook();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Book * EnglishBookFactory::Createbook()</span><br><span class="line">&#123;</span><br><span class="line">return new EnglishBook;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MathBookFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">MathBookFactory();</span><br><span class="line">~MathBookFactory();</span><br><span class="line"></span><br><span class="line">virtual Book *Createbook();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Book * MathBookFactory::Createbook()</span><br><span class="line">&#123;</span><br><span class="line">return new MathBook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>界面显示类</strong></p><p>这个类用来调用book类里面的函数，显示book的名字，这里<strong>采用工厂模式的目的就是为了使这个类是稳定的</strong>，即不管书的类型怎么变化，无需修改这个类的代码，这也是设计模式的一个核心思想，<strong>需求变化通过添加代码实现，而不是修改代码</strong>。</p><p>可以看到这里面<strong>所有的类型都是接口，符合DIP原则</strong>。</p><p><strong>设计模式不可能完全把不稳定的东西去除，这是不符合实际场景的，但是可以将不稳定的部分放在一个范围内而不是整个代码中</strong>，MainForm通过其构造函数传入一个具体的工厂，然后创建具体的Book对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MainForm</span><br><span class="line">&#123;</span><br><span class="line">BookFactory *book_fac;</span><br><span class="line">public:</span><br><span class="line">MainForm(BookFactory *fac);</span><br><span class="line">~MainForm();</span><br><span class="line"></span><br><span class="line">void showbook();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MainForm::MainForm(BookFactory *fac)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;book_fac &#x3D; fac;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainForm::~MainForm()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainForm::showbook()</span><br><span class="line">&#123;</span><br><span class="line">Book *book &#x3D; this-&gt;book_fac-&gt;Createbook();&#x2F;&#x2F; 多态new</span><br><span class="line">book-&gt;getbookname();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main函数测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">BookFactory *fac &#x3D; new EnglishBookFactory;</span><br><span class="line">MainForm *mainform &#x3D; new MainForm(fac);</span><br><span class="line">mainform-&gt;showbook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>思考一个问题：上面的例子的MainForm中直接传入Book的对象指针不就行了吗？Book也是接口，因此MainForm也是稳定的<br>由此引出Factory模式的<strong>应用场景和局限性</strong>：</p><ul><li><p>工厂模式所实例化的对象常常具有<strong>私有的构造方法</strong>，因此这些类就不能扩展了</p></li><li><p>如果将所有的构造方法都用工厂实现，则常常会把构造函数设置为私有的，那么所有的new这个对象的代码都会失效</p></li><li><p>如果确实扩展了工厂方法所实例化的类，那么其子类必须具有自己的工厂类，否则调用工厂方法返回的是父类的实例而不是子类的实例</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桥接模式</title>
    <link href="/2019/07/27/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/07/27/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>桥模式</strong>，又叫<strong>Bridge模式</strong>，和之前的装饰模式有点类似，都属于<strong>单一职责模式</strong>，不同的是装饰模式的动机是动态的扩展对象的功能，而桥模式是为了应对一个场景中有两个或多个不同维度的变化，桥模式可以弱化他们的耦合性，使得它们可以按照各自的方向扩展。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将抽象部分(业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。   —《设计模式》 GoF</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>桥接模式的意图是将抽象与实现解耦，使得两者可以独立变化。</p><p>桥接模式主要应对的是某个类中有两个或两个以上的维度变化，如果只是用继承则会使设计变得非常臃肿，可以将这些变化维度分离，使它们可以各自变化，<strong>在运行时</strong>，使用多态机制将这些变化进行组合。</p><p>举个具体的例子，比如我们常用播放器，它可以播放MPEG、RMVB、AVI等格式的文件，同时它可以在不同的平台上运行，如windows，linux等，可以使用桥接模式设计该播放器。这里可以把不同的平台看成抽象的部分，不同的格式看成具体的实现部分。</p><p>或者是一个绘图软件，我们可以画圆形，正方形，三角形等，同时又需要使用不同的颜色，如红色，绿色，蓝色等，也可以使用桥接模式设计该绘图软件，假设有n种颜色，m种图形，那只需要写n+m个子类就可以达到n*m种组合方式的效果，无需写nxm个类。这里可以把不同的图形看成抽象的部分，不同的颜色看成具体的实现方式。</p><p><strong>桥接模式的难度在于需要开发者能正确识别出系统中两个独立变化的维度。</strong></p><h3 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h3><ul><li>Abstraction : 定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction：扩展Abstraction中的接口定义，可以有多个</li><li>Implementor：是具体实现的抽象类</li><li>ConcreteImplementor：实现Implementor接口，可以有多个</li></ul><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>实现了一个多平台的播放器，平台相关的设置代码放在不同平台的子类中，不同视频格式的编码算法放在不同的编码子类中，在这里，把不同的平台看成桥接模式的抽象部分，不同的编码方式看成是桥接模式的具体实现方法。</p><p><strong>播放器抽象类</strong><br>播放器抽象类是Abstraction，是一个抽象接口，里面含有Implementor类型的指针对象videoformat，也就是不同的编码方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class VideoPlayer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">VideoPlayer(VideoFormat* videoformat);</span><br><span class="line">virtual ~VideoPlayer() &#123;&#125;;</span><br><span class="line">virtual void play() &#x3D; 0;</span><br><span class="line"></span><br><span class="line">VideoFormat* videoformat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>不同的平台</strong><br>不同的平台是播放器抽象类的子类，具体包括windows平台和unix平台，属于RefinedAbstraction，重写播放器类的play函数，并且在构造函数中初始化编码方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class WindowsPlatform : public VideoPlayer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">WindowsPlatform(VideoFormat *videoformat);</span><br><span class="line">~WindowsPlatform();</span><br><span class="line"></span><br><span class="line">virtual void play();</span><br><span class="line">&#125;;</span><br><span class="line">WindowsPlatform::WindowsPlatform(VideoFormat *videoformat) : VideoPlayer(videoformat)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WindowsPlatform::~WindowsPlatform()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WindowsPlatform::play()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;in windows platform\n&quot;);</span><br><span class="line">this-&gt;videoformat-&gt;Encode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UnixPlatform : public VideoPlayer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">UnixPlatform(VideoFormat *videoformat);</span><br><span class="line">~UnixPlatform();</span><br><span class="line"></span><br><span class="line">virtual void play();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UnixPlatform::UnixPlatform(VideoFormat *videoformat) : VideoPlayer(videoformat)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UnixPlatform::~UnixPlatform()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UnixPlatform::play()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;in unix platform\n&quot;);</span><br><span class="line">this-&gt;videoformat-&gt;Encode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编码方式抽象类</strong><br>编码方式抽象类是从播放器中抽出来生成的一个抽象类，也就是桥接模式的Implementor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class VideoFormat</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">VideoFormat();</span><br><span class="line">virtual ~VideoFormat();</span><br><span class="line">virtual void Encode() &#x3D; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>不同的编码方式类</strong><br>不同的编码方式是对编码方式抽象类的扩展和具体实现，包括mpeg方式和avi方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Mpeg : public VideoFormat</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Mpeg();</span><br><span class="line">~Mpeg();</span><br><span class="line"></span><br><span class="line">virtual void Encode();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Mpeg::Encode()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;start encode mpeg image... \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Avi : public VideoFormat</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Avi();</span><br><span class="line">~Avi();</span><br><span class="line"></span><br><span class="line">virtual void Encode();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Avi::Encode()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;start encode avi image... \n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main测试函数</strong><br>main函数中先构造一个mpeg的编码方式，然后动态的加载到播放器中实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">VideoFormat *videoplatform &#x3D; new Mpeg;</span><br><span class="line">VideoPlayer *videoplayer &#x3D; new WindowsPlatform(videoplatform);</span><br><span class="line">videoplayer-&gt;play();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>一个系统存在两个或多个独立变化的维度，且都需要扩展，对于多个维度的系统，在抽象类中增加其他维度的指针对象即可</li><li>不希望因为继承导致类的个数急剧增加的系统</li><li>通过桥接模式可以使得抽象角色和具体的角色的搭配有更多的灵活性</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰模式</title>
    <link href="/2019/07/27/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/07/27/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>修饰模式</strong>，又叫<strong>Decorator模式</strong>,是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（<strong>消除重复代码 &amp; 减少子类个数</strong>）。   — 《设计模式》  GoF</p><h3 id="Motivation-动机"><a href="#Motivation-动机" class="headerlink" title="Motivation 动机"></a>Motivation 动机</h3><p>一般有两种方式可以实现给一个类或对象增加行为：</p><ul><li><strong>继承机制</strong>，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li><li><strong>关联机制</strong>，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)</li></ul><p>装饰模式可以在不需要创建更多子类的情况下，<strong>将对象的功能加以扩展</strong>，通过多态机制可以在<strong>运行时选择装配</strong>某一个具体构件，而不需要在每一个具体构件下面创建子类，增强了代码的复用性,符合GoF给出的定义，消除重复代码和减少子类个数。同时也符合设计模式的开闭原则，即扩展对象的功能时只需要增加装饰类即可，无需修改代码。</p><h3 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h3><ul><li>Component : 抽象构件</li><li>ConcreteComponent: 具体构件，可以有多个</li><li>Decorator: 抽象装饰类</li><li>ConcreteDecorator: 具体装饰类，可以有多个</li></ul><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>** 书本类 **</p><p>书本类是一个抽象构件，包括书的名字，页数和价格，都是纯虚函数，因此这是一个虚基类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class book</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual ~book();</span><br><span class="line"></span><br><span class="line">virtual void name(char *p_name) &#x3D; 0;</span><br><span class="line">virtual int page() &#x3D; 0;</span><br><span class="line">virtual int price() &#x3D; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>** 数学书和英语书 **</p><ul><li>这是两个具体的抽象构件，对比上面的模式结构图，即把ConcreteComponent扩展成两个。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class MathBook : public book</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">MathBook();</span><br><span class="line">~MathBook();</span><br><span class="line"></span><br><span class="line">virtual void name(char *p_name);</span><br><span class="line">virtual int page();</span><br><span class="line">virtual int price();</span><br><span class="line">&#125;;</span><br><span class="line">MathBook::MathBook()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MathBook::~MathBook()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MathBook::name(char *p_name)</span><br><span class="line">&#123;</span><br><span class="line">memcpy(p_name, &quot;math book\0&quot;, sizeof(&quot;math book\0&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int MathBook::page()</span><br><span class="line">&#123;</span><br><span class="line">return 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int MathBook::price()</span><br><span class="line">&#123;</span><br><span class="line">return 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EnglishBook : public book</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">EnglishBook();</span><br><span class="line">~EnglishBook();</span><br><span class="line"></span><br><span class="line">virtual void name(char *p_name);</span><br><span class="line">virtual int page();</span><br><span class="line">virtual int price();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EnglishBook::EnglishBook()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EnglishBook::~EnglishBook()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EnglishBook::name (char *p_name)</span><br><span class="line">&#123;</span><br><span class="line">memcpy(p_name, &quot;English book\0&quot;, sizeof(&quot;English book\0&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int EnglishBook::page()</span><br><span class="line">&#123;</span><br><span class="line">return 200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int EnglishBook::price()</span><br><span class="line">&#123;</span><br><span class="line">return 80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 抽象装饰类 **</p><p>装饰类继承book类，这里面没有方法，只有一个book类的指针对象,这个类用于被具体的装饰类继承，book类的指针对象用来在运行时动态的选择装饰哪一个具体的构件，这里指数学书或英语书。<br><strong>这里说一下为什么类里面包含了book类的指针对象，还要继承book</strong>：继承是为了接口的规范性，让子类必须重写父类的接口，包含是为了在运行时动态的加载具体的构件，这样的设计非常巧妙，这也是这个模式的核心所在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class DecratorBook : public book</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">DecratorBook(book *book1);</span><br><span class="line">~DecratorBook();</span><br><span class="line"></span><br><span class="line">&#x2F;* 运行时决定是哪种book *&#x2F;</span><br><span class="line">book *my_book;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DecratorBook::DecratorBook(book *book1):my_book(book1)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DecratorBook::~DecratorBook()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 两个具体装饰类 **<br>具体装饰类继承自抽象装饰类，在构造函数中传入book的指针对象来初始化父类的my_book指针，动态的选择装饰哪一个具体构件，在这里是数学书或者英语书<br>这里我们把读书和买书当成是对书的功能的扩展。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">class GetBook : public DecratorBook</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">GetBook(book* my_book);</span><br><span class="line">~GetBook();</span><br><span class="line"></span><br><span class="line">virtual void name(char *p_name);</span><br><span class="line">virtual int page();</span><br><span class="line">virtual int price();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GetBook::GetBook(book* my_book) : DecratorBook(my_book)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GetBook::~GetBook()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GetBook::name(char *p_name)</span><br><span class="line">&#123;</span><br><span class="line">char name[100];</span><br><span class="line">my_book-&gt;name(name);</span><br><span class="line"></span><br><span class="line">printf(&quot;I get book %s , %d ￥ \n&quot;, name, my_book-&gt;price());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetBook::page()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;this book page is %d \n&quot;, my_book-&gt;page());</span><br><span class="line">return my_book-&gt;page();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetBook::price()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;this book price is %d \n&quot;, my_book-&gt;price());</span><br><span class="line">return  my_book-&gt;price();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ReadBook : public DecratorBook</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ReadBook(book* my_book);</span><br><span class="line">~ReadBook();</span><br><span class="line"></span><br><span class="line">virtual void name(char *p_name);</span><br><span class="line">virtual int page();</span><br><span class="line">virtual int price();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReadBook::ReadBook(book *my_book) : DecratorBook(my_book)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReadBook::~ReadBook()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ReadBook::name(char *p_name)</span><br><span class="line">&#123;</span><br><span class="line">char name[100];</span><br><span class="line">my_book-&gt;name(name);</span><br><span class="line"></span><br><span class="line">printf(&quot;I read book %s , %d pages \n&quot;, name, my_book-&gt;page());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ReadBook::page()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;this book page is %d \n&quot;, my_book-&gt;page());</span><br><span class="line">return my_book-&gt;page();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ReadBook::price()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;this book price is %d \n&quot;, my_book-&gt;price());</span><br><span class="line">return my_book-&gt;page();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main函数测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">book* mathbook &#x3D; new MathBook;</span><br><span class="line">book* englishbook &#x3D; new EnglishBook;</span><br><span class="line"></span><br><span class="line">GetBook *getbook &#x3D; new GetBook(mathbook);</span><br><span class="line">getbook-&gt;name(NULL);</span><br><span class="line"></span><br><span class="line">ReadBook *readbook &#x3D; new ReadBook(mathbook); </span><br><span class="line">readbook-&gt;name(NULL);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p>两种模式的比较：</p><ul><li>使用继承<br>可以看到随着组合的增加，子类的个数成倍的增加</li></ul><ul><li>使用Decrator<br>对于每一种书扩展的动作是一样的，不需要每次都继承一个子类，可以把这些动作都提取出来，减少了代码的重复性，不管有多少种组合方式，只需要在实用的时候动态的加载具体的构件即可。</li></ul><blockquote><p>Decorator类在接口上表现为is-a Component的继承关系，即 Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类，这里指具体的英语书或者数学书<br>继承是为了接口的规范性，组合是为了动态的加载具体的构件，<strong>在代码中看到即有继承又有组合的方式，大部分都是使用了Decrator模式</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/2019/07/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/07/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>观察者模式</strong>，又叫<strong>Observer模式或者Event模式</strong>，是用来对事件进行通知的模式，在UI框架中使用的比较多。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。 — 《设计模式》 GoF</p><h3 id="Motivation-动机"><a href="#Motivation-动机" class="headerlink" title="Motivation 动机"></a>Motivation 动机</h3><p>为了给某些对象建立一种<strong>通知依赖</strong>关系，即一个对象发生变化，所有的依赖对象都会得到通知。使用面向对象的技术，使得这种依赖关系弱化，具体实现方法：抽象出一个通知类，把通知的结果或者形式封装起来。</p><p>目标发送通知时，无需指定哪个观察者，通知会自动传播给所有的观察者<br>观察者自己觉得是否需要订阅通知，目标对象对此一无所知</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p><strong>目标对象</strong><br>目标对象包括一个自动生成随机数的函数，一个发送通知的函数，订阅通知的函数和取消订阅通知的函数。<br>这个类中添加和删除订阅都是基于抽象的观察者类而不依赖具体的实现，抽象的观察者类是稳定的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class ValueChange</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ValueChange();</span><br><span class="line">~ValueChange();</span><br><span class="line"></span><br><span class="line">&#x2F;* list 支持多个观察者 *&#x2F;</span><br><span class="line">list&lt;IProgress*&gt;  progressList;</span><br><span class="line"></span><br><span class="line">&#x2F;* 数据变化 *&#x2F;</span><br><span class="line">void ChangeValue();</span><br><span class="line">&#x2F;* 发送通知 *&#x2F;</span><br><span class="line">void onProcess(int data);</span><br><span class="line">&#x2F;* 添加通知 *&#x2F;</span><br><span class="line">void attachProcess(IProgress *progress);</span><br><span class="line">&#x2F;* 删除通知 *&#x2F;</span><br><span class="line">void detachProdess(IProgress *progress);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ValueChange::ValueChange()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ValueChange::~ValueChange()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 数据变化 *&#x2F;</span><br><span class="line">void ValueChange::ChangeValue()</span><br><span class="line">&#123;</span><br><span class="line">int i &#x3D; rand() % 10;</span><br><span class="line">onProcess(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 发送通知 *&#x2F;</span><br><span class="line">void ValueChange::onProcess(int data)</span><br><span class="line">&#123;</span><br><span class="line">list&lt;IProgress *&gt;::iterator itor &#x3D; progressList.begin();</span><br><span class="line">while (itor !&#x3D; progressList.end())</span><br><span class="line">&#123;</span><br><span class="line">(*itor)-&gt;Doprogress(data);</span><br><span class="line">itor++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 添加通知 *&#x2F;</span><br><span class="line">void ValueChange::attachProcess(IProgress *progress)</span><br><span class="line">&#123;</span><br><span class="line">progressList.push_back(progress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 删除通知 *&#x2F;</span><br><span class="line">void ValueChange::detachProdess(IProgress *progress)</span><br><span class="line">&#123;</span><br><span class="line">progressList.remove(progress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>观察者类</strong><br>观察者类是一个接口类，包括一个纯虚函数 : 显示数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class IProgress</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual ~IProgress();</span><br><span class="line">virtual void Doprogress(int data) &#x3D; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>** 两个通知类 **<br>两个通知类继承观察者类，重写观察者类里面的纯虚函数，实现具体的通知方式，如打印数据或者打印 * 符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Progress1 : public IProgress</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Progress1();</span><br><span class="line">~Progress1();</span><br><span class="line"></span><br><span class="line">void Doprogress(int data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Progress1::~Progress1()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Progress1::Doprogress(int data)</span><br><span class="line">&#123;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">printf(&quot;data &#x3D; %d\n&quot;, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Progress2 : public IProgress</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Progress2();</span><br><span class="line">~Progress2();</span><br><span class="line"></span><br><span class="line">void Doprogress(int data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Progress2::Progress2()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Progress2::~Progress2()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Progress2::Doprogress(int data)</span><br><span class="line">&#123;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">for (i &#x3D; 0; i &lt; data; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;*&quot;);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主函数</strong><br>主函数实现一个目标对象并且订阅了两个观察者，调用目标对象的随机数函数，查看事件的通知形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i &#x3D; 10;</span><br><span class="line">ValueChange *val &#x3D; new ValueChange;</span><br><span class="line">IProgress *pro1 &#x3D; new Progress1;</span><br><span class="line">IProgress *pro2 &#x3D; new Progress2;</span><br><span class="line">val-&gt;attachProcess(pro1);</span><br><span class="line">val-&gt;attachProcess(pro2);</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">val-&gt;ChangeValue();</span><br><span class="line">i--;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125; while (i);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3>]]></content>
    
    
    <categories>
      
      <category>C++设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板模式</title>
    <link href="/2019/07/25/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/07/25/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>本文介绍23种设计模式的第一种，<strong>模板模式</strong>，英文是<strong>Template Method</strong>，这是一个非常常用的设计模式。从封装变化角度来分类，模板模式属于<strong>组件协作模式</strong>的一种。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟 (变化)到子类中。Template Method使得子类可以不改变 (复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。    —《设计模式》 GoF</p><h3 id="Motivation-动机"><a href="#Motivation-动机" class="headerlink" title="Motivation 动机"></a>Motivation 动机</h3><p>学习设计模式需要知道这个设计模式是用来干嘛的，解决哪一类问题的，这点很关键，但是设计模式的学习又不仅仅只是这些，重点是要学会根据具体的场景找出<strong>稳定和不稳定的分界线</strong>，在这个分界线处，就是需要使用设计模式的地方。</p><p>假设这样的场景，你需要基于framework开发一个APP，这是日常开发中很常用的场景。一般的方法是，厂家提供给你库，你调用库内部的方法写自己的业务，这样毫无疑问是可以的。<br>但是有一个更加简单的办法，就是厂家在framework把所有的业务流程全部写完，在不确定的位置使用<strong>虚函数</strong>（C++）或者是<strong>函数指针</strong>（C语言）代替，而你不需要知道全部的业务范围，只需要把重写虚函数或者实现一个函数指针对应的函数即可，这就是<strong>Template Method</strong>。</p><p>这里面有<strong>两个概念</strong>，早绑定和晚绑定</p><ul><li><strong>早绑定</strong>：写的晚的代码依赖于写的早的代码，也就是我们日常使用的开发方法</li><li><strong>晚绑定</strong>：写的早的代码依赖于写的晚的代码，也就是我们所说的<strong>Template Method</strong>模式，framework依赖于app的函数才能正确的运行</li></ul><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p><strong>framework 类</strong><br>有两个确定的步骤，两个不确定的步骤，和整个业务流程函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class framework</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">framework();</span><br><span class="line">~framework();</span><br><span class="line"></span><br><span class="line">&#x2F;* 确定的步骤 *&#x2F;</span><br><span class="line">void step1();</span><br><span class="line">void step3();</span><br><span class="line"></span><br><span class="line">&#x2F;* 不确定的步骤 *&#x2F;</span><br><span class="line">virtual void step2();</span><br><span class="line">virtual void step4();</span><br><span class="line"></span><br><span class="line">&#x2F;* 流程 *&#x2F;</span><br><span class="line">void main_loop();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">framework::framework()&#123;&#125;</span><br><span class="line"></span><br><span class="line">framework::~framework()&#123;&#125;</span><br><span class="line"></span><br><span class="line">void framework::step1()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;framework step 1 running ...\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void framework::step2()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;framework step 2 running ...\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void framework::step3()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;framework tep 3 running ...\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void framework::step4()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;framework step 4 running ...\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void framework::main_loop()</span><br><span class="line">&#123;</span><br><span class="line">step1();</span><br><span class="line">step2();</span><br><span class="line">step3();</span><br><span class="line">step4();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两个APP</strong><br>继承固件库，重写固件库里的虚函数即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 第一个APP *&#x2F;</span><br><span class="line">class App : public framework</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">App();</span><br><span class="line">~App();</span><br><span class="line"></span><br><span class="line">void step2();</span><br><span class="line">void step4();</span><br><span class="line">&#125;;</span><br><span class="line">App::App()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">App::~App()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void App::step2()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;App step 2 running ...\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void App::step4()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;App step 4 running ...\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 第二个APP *&#x2F;</span><br><span class="line">class App2 : public framework</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">App2();</span><br><span class="line">~App2();</span><br><span class="line"></span><br><span class="line">void step2();</span><br><span class="line">void step4();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">App2::App2()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">App2::~App2()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void App2::step2()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;App2 step 2 running ...\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void App2::step4()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;App2 step 4 running ...\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;);</span><br><span class="line"></span><br><span class="line">framework *work &#x3D; new App;</span><br><span class="line">work-&gt;main_loop();</span><br><span class="line">printf(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;);</span><br><span class="line"></span><br><span class="line">framework *work2 &#x3D; new App2;</span><br><span class="line">work2-&gt;main_loop();</span><br><span class="line">printf(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><strong>类图</strong></p><blockquote><p>估计很多人尤其新手，在开发应用程序的时候会有种只见树木，不见森林的感觉，就是因为固件库使用了这种设计模式，封装了业务逻辑，而我们只需要重写部分代码即可。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程</title>
    <link href="/2019/07/21/%E7%BA%BF%E7%A8%8B/"/>
    <url>/2019/07/21/%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>线程基础知识包含两个部分，1是线程的基础概念，线程控制的API和线程属性设置的API，具体可以参考man手册，2是线程间同步的方法，有互斥锁，读写锁，条件变量，信号量等，以及使用信号量实现生产者消费者模型。   </p><p>线程，<strong>light weight process 轻量级的进程</strong>，是内核调度的基本单位，<strong>ps –Lf pid</strong> 查看指定线程的lwp号，lwp号和进程ID很相似，不是线程ID，线程ID是进程中区分不同的线程所使用的。</p><p>线程同步，一般用在<strong>多个线程，共同操作一个共享资源</strong>的情况。</p><ul><li>右键单独打开图片可以放大，，，</li></ul><blockquote><p>线程的一些基础知识和API就讲这么多，至于具体的细节知识，如条件变量，哲学家吃饭模型等放在单独的篇幅中</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unix环境编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix环境编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>守护进程</title>
    <link href="/2019/07/15/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    <url>/2019/07/15/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="进程组与会话"><a href="#进程组与会话" class="headerlink" title="进程组与会话"></a>进程组与会话</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>进程组，也称之为作业，顾名思义，代表一个或多个进程的集合，设计进程组的概念是为了简化对多个进程的管理。<br>父进程创建子进程的时候，默认父子进程位于同一个进程组，进程组的ID就是第一个进程的ID，第一个进程成为进程组的组长。<br>只要进程组有一个进程存在，进程组就存在，与组长进程是否终止无关。<br>进程组生存期：进程组的最后一个进程终止。<br>一个进程可以为自己或者子进程设置进程组ID</p><h3 id="进程组操作函数"><a href="#进程组操作函数" class="headerlink" title="进程组操作函数"></a>进程组操作函数</h3><ul><li>getpgrp 获取当前进程的进程组ID</li><li>getpgid 获取指定进程的进程组ID</li><li>setpgid 改变进程默认所属的进程组，通常可用来加入一个现有的进程组或创建一个新进程组</li></ul><h3 id="会话"><a href="#会话" class="headerlink" title="会话###"></a>会话###</h3><p>会话是一个进程组或者多个进程组的集合，通常一个会话开始于用户登录，终止与用户退出，在此期间，该用户运行的所有程序都属于这个会话<br><strong>创建一个会话需要注意以下几个事项：</strong></p><ul><li>创建会话的进程不能是某个进程组的组长</li><li>创建会话的进程成为这个会话的会长和会话里第一个进程组的组长</li><li>新会话丢弃原有的控制终端，该会话没有控制终端</li><li>建立新会话步骤，先fork一个子进程，然后父进程退出，子进程调用setsid</li></ul><p>会话相关的两个函数：</p><ul><li>getsid 查看当前进程的会话ID</li><li>setsid 创建一个会话，并以自己的ID为会话ID</li></ul><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>daemon进程，即守护进程是指linux后台服务程序，通常独立于控制终端并且周期性的执行某种任务，名字一般以d结尾<br>linux的系统服务进程，没有控制终端，不能直接和用户交互等都是守护进程，如nfs服务器，ftp服务器</p><p><strong>创建守护进程模型</strong></p><p>创建守护进程的过程实际上是创建一个新的会话，跳出控制终端建立的会话，达到脱离于终端运行的目的。创建守护进程模型有以下几个步骤：</p><ul><li>创建子进程，退出父进程</li><li>子进程调用setsid创建会话，成为会话第一个进程组的组长</li><li>改变当前目录为根目录，不是必须，为了防止当前目录被删除</li><li>重设文件权限掩码umask为0</li><li>重定向标准输入，标准输出和标准错误到/dev/null</li><li>开始守护进程的逻辑</li></ul><p><strong>示例代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 创建一个守护进程</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">pid_t pid;</span><br><span class="line">int i;</span><br><span class="line">pid &#x3D; fork();</span><br><span class="line"></span><br><span class="line">&#x2F;* 干掉父进程 *&#x2F;</span><br><span class="line">if (pid &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 创建会话期 *&#x2F;</span><br><span class="line">pid &#x3D; setsid();</span><br><span class="line">printf(&quot;pid &#x3D; %d \n&quot;, getpid());</span><br><span class="line">if (pid &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;setsid error :&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 改变文件掩码 *&#x2F;</span><br><span class="line">umask(0);</span><br><span class="line"></span><br><span class="line">&#x2F;* 切换目录到根目录 *&#x2F;</span><br><span class="line">chdir(&quot;&#x2F;&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;* 重定位标准输入、输出、错误到&#x2F;dev&#x2F;null *&#x2F;</span><br><span class="line">for (i&#x3D;0; i&lt;3; i++)</span><br><span class="line">&#123;</span><br><span class="line">close(i);</span><br><span class="line">&#125;</span><br><span class="line">open(&quot;&#x2F;dev&#x2F;null&quot;,O_RDWR);</span><br><span class="line">dup(0);</span><br><span class="line">dup(0);</span><br><span class="line"></span><br><span class="line">int fd;</span><br><span class="line">time_t t;</span><br><span class="line">char *t_buffer;</span><br><span class="line">fd &#x3D; open(&quot;timelog&quot;, O_CREAT | O_RDWR, 0644);</span><br><span class="line">if (fd &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;fd error:&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">t &#x3D; time(0);</span><br><span class="line">t_buffer &#x3D; asctime(localtime(&amp;t));</span><br><span class="line">write(fd, t_buffer, strlen(t_buffer));</span><br><span class="line">sleep(5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序首先创建了一个守护进程，在守护进程里每隔5秒打印当前系统的时间到timelog日志文件里。<br>由于切换工作目录为根目录，因此执行的时候需要加上sudo权限，运行结果：</p><p>可以看到，这个守护进程的所属用户已经变成了root用户，父进程为1号进程，tty为？,表示不属于任何终端</p><p>使用<strong>sudo killall + 守护进程的名字</strong>可以杀掉守护进程</p><h2 id="daemon函数"><a href="#daemon函数" class="headerlink" title="daemon函数"></a>daemon函数</h2><p>除了上述方法可以创建一个守护进程外，也可以使用daemon函数创建一个守护进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int daemon(int nochdir, int noclose);</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li>nochdir：=0 将当前目录更改至“/”</li><li>noclose：=0 将标准输入、标准输出、标准错误重定向至“/dev/null”</li></ul><p><strong>返回值</strong></p><ul><li>成功返回0</li><li>失败返回-1</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unix环境编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix环境编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mmap</title>
    <link href="/2019/07/14/mmap/"/>
    <url>/2019/07/14/mmap/</url>
    
    <content type="html"><![CDATA[<p>Linux操作系统提供的IPC方法有很多，如文件，管道，信号，共享内存，消息队列，套接字，命名管道等，常用的进程间通信方法有：</p><ul><li>管道 (使用最简单)</li><li>信号 (开销最小)</li><li>共享映射区 (无血缘关系)</li><li>本地套接字 (最稳定)</li></ul><h2 id="mmap函数基本用法"><a href="#mmap函数基本用法" class="headerlink" title="mmap函数基本用法"></a>mmap函数基本用法</h2><p>上述IPC方法中的共享映射区就是使用mmap函数实现的,该函数的功能是<strong>将磁盘文件的内容映射到内存中</strong>，在不适用read和write函数的情况下，使用地址（指针）完成I/O操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset);</span><br><span class="line">int munmap(void *addr, size_t length); &#x2F;* 删除共享映射区 *&#x2F;</span><br></pre></td></tr></table></figure><p><strong>参数解析：</strong></p><ul><li>addr: 建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL</li><li>length： 欲创建映射区的大小</li><li>prot：    映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</li><li>flags：    标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAP_SHARED:  会将映射区所做的操作反映到物理设备（磁盘）上</span><br><span class="line">MAP_PRIVATE: 映射区所做的修改不会反映到物理设备</span><br></pre></td></tr></table></figure><ul><li>fd：     用来建立映射区的文件描述符</li><li>offset： 映射文件的偏移(<strong>4k的整数倍</strong>)</li></ul><p><strong>返回值：</strong></p><ul><li>成功返回共享内存的首地址</li><li>失败返回 MAP_FAILED（(void *) -1）</li></ul><h2 id="mmap函数注意事项"><a href="#mmap函数注意事项" class="headerlink" title="mmap函数注意事项"></a>mmap函数注意事项</h2><p>先看一个示例程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int fd_test;</span><br><span class="line">unsigned char *buf &#x3D; NULL;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">fd_test &#x3D; open(&quot;temp&quot;, O_RDWR | O_CREAT, 0644);</span><br><span class="line">if (fd_test &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;open err&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 删除文件的目录项，使之具备被删除的条件,没有真正被删除</span><br><span class="line"> * 在所有占有该文件描述符的进程结束后该文件被删除</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F;unlink(&quot;temp&quot;);&#x2F;* 程序结束后删除temp *&#x2F;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">printf(&quot;请输入文件的大小\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">ret &#x3D; ftruncate(fd_test, n); &#x2F;* 设置文件的大小 *&#x2F;</span><br><span class="line">if (ret &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;ftruncate err:&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct stat fd_stat;</span><br><span class="line">ret &#x3D; fstat(fd_test, &amp;fd_stat);&#x2F;* 获取文件的大小 *&#x2F;</span><br><span class="line">if (ret &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;fstat err:&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">int fd_len &#x3D; fd_stat.st_size;</span><br><span class="line">printf(&quot;fd_len &#x3D; %d \n&quot;,fd_len);</span><br><span class="line"></span><br><span class="line">&#x2F;* 映射一个与文件大小相同的共享内存区域 *&#x2F;</span><br><span class="line">buf &#x3D; (unsigned char *)mmap(NULL, fd_len, PROT_READ | PROT_WRITE, MAP_SHARED, </span><br><span class="line">fd_test, 0);</span><br><span class="line">if (buf &#x3D;&#x3D; MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;mmap failed&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int buf_len &#x3D; strlen((char *)buf);</span><br><span class="line">printf(&quot;buf len &#x3D; %d \n&quot;, buf_len);</span><br><span class="line">printf(&quot;修改前文件的内容：\n%s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line">char rcv_buf[1024];</span><br><span class="line">printf(&quot;输入写入文件的数据:\n&quot;);</span><br><span class="line"></span><br><span class="line">while ( fgets(rcv_buf, sizeof(rcv_buf), stdin) !&#x3D; NULL )</span><br><span class="line">&#123;</span><br><span class="line">if (strlen(rcv_buf) &lt;&#x3D; 1)</span><br><span class="line">continue;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memcpy(buf, rcv_buf, strlen(rcv_buf));</span><br><span class="line">printf(&quot;修改后文件的内容：\n%s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line">close(fd_test);</span><br><span class="line">munmap(buf, 10);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中使用了几个系统调用，</p><ul><li>unlink，删除文件的目录项，使之具备被删除的条件,没有真正被删除，在所有占有该文件描述符的进程结束后该文件被删除,如果在程序结束后就无需使用这个文件，则调用它</li><li>ftruncate，设置文件的大小</li><li>fstat， 获取文件的大小 </li></ul><p><strong>mmap函数的核心在注意事项，主要有以下几个</strong></p><ul><li>新创建的文件无法mmap，必须要有实际的大小，可以使用ftruncate函数设置文件实际大小</li><li>对映射区的权限要小于等于打开文件的权限，映射的过程中隐藏了一次读操作，因此文件权限至少是可读</li><li>最后一个参数offset必须是4K的整数倍</li><li>映射的内存超出了文件的大小，不报错，但无法写入超出的部分</li><li>一定要检查返回值</li></ul><p>运行结果：</p><p>可以看到，设置文件的大小为10，但写入的数据超过10，虽然写入了共享内存区域，但是超出文件大小的部分并没有写入文件中</p><h2 id="mmap函数用于进程间通信"><a href="#mmap函数用于进程间通信" class="headerlink" title="mmap函数用于进程间通信"></a>mmap函数用于进程间通信</h2><p>实质上mmap是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。<strong>mmap可以用于父子间通信，也可以用于无血缘关系进程间通信</strong>，前提是必须要使用MAP_SHARED选项</p><h3 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h3><p>使用映射区必须要使用一个文件来创建共享内存,比较麻烦，也可以使用匿名映射来创建共享映射区，方法是使用MAP_ANONYMOUS (或MAP_ANON) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p &#x3D; mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</span><br></pre></td></tr></table></figure><p>该方法只可能在Linux操作系统使用，无法在类Unix操作系统使用。</p>]]></content>
    
    
    <categories>
      
      <category>Unix环境编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix环境编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>makefile基础</title>
    <link href="/2019/07/14/makefile%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/07/14/makefile%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>makefile是GUN执行make调用的程序，用来组织项目中的文件按照一定的规则被编译，其核心是规则</p></blockquote><h3 id="程序的编译过程"><a href="#程序的编译过程" class="headerlink" title="程序的编译过程"></a>程序的编译过程</h3><p>先来看看程序的编译过程</p><p>大体上分为四步：</p><ul><li>预处理 </li><li>编译，生成.s文件</li><li>汇编，生成.o文件，是二进制文件</li><li>链接，将多个.o文件链接在一起，生成可执行文件ELF文件</li></ul><p>file命令查看文件格式：</p><h3 id="makefile语法"><a href="#makefile语法" class="headerlink" title="makefile语法"></a>makefile语法</h3><p>Makefile的基本格式很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标 : 依赖1 依赖2 ...</span><br><span class="line">[TAB]命令</span><br></pre></td></tr></table></figure><p>执行命令的条件：</p><ul><li>当目标文件不存在</li><li>或者某个依赖比目标文件新</li></ul><h3 id="makefile通配符"><a href="#makefile通配符" class="headerlink" title="makefile通配符"></a>makefile通配符</h3><ul><li>%.o 表示某个.o文件</li><li>*.o 表示所有的.o文件</li><li>$@ 表示目标</li><li>$&lt; 表示第1个依赖文件</li><li>$^ 表示所有依赖文件</li></ul><h3 id="makefile变量的两个特色"><a href="#makefile变量的两个特色" class="headerlink" title="makefile变量的两个特色"></a>makefile变量的两个特色</h3><p>Makefile中变量分为两类，一类是<strong>即时变量</strong>，另一类是<strong>延时变量</strong>，这在GUN make中文手册中被翻译为Makefile变量的两个特色</p><p>A := xxx     </p><ul><li>A的值即刻确定，在定义时即确定    </li></ul><p>B = xxx     </p><ul><li>B的值使用到时才确定</li></ul><p>:=   即时变量<br>=    延时变量<br>?=   延时变量, 如果是第1次定义才起效, 如果在前面该变量已定义则忽略这句<br>+=   附加, 它是即时变量还是延时变量取决于前面的定义 </p><h3 id="makefile函数"><a href="#makefile函数" class="headerlink" title="makefile函数"></a>makefile函数</h3><p><strong>使用这些函数的目的是为了替代手动输入大量的.c或者.o文件组成的字符串(大项目中可能有成千上万个文件)，因此这些函数的输出都是字符串</strong></p><blockquote><p>makefile所有的函数都有返回值，我们使用函数也是为了读取它的返回值</p></blockquote><ul><li><strong>查找所有</strong><blockquote><p>查找当前目录下所有的.c文件</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src &#x3D; $(wildcard .&#x2F;*.c)</span><br></pre></td></tr></table></figure><p>返回一个字符串，如下：</p><ul><li><strong>按格式替换</strong><blockquote><p>替换当前目录下的.c为.o的形式,.c来源于上面的src变量,注意这里是一对一替换，因此是%而不是*</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj &#x3D; $(patsubst .&#x2F;%.c, .&#x2F;%.o, $(src))</span><br></pre></td></tr></table></figure><p>返回也是一个字符串，注意这只是修改了字符串中每个文件的后缀生成一个新的字符串，并不生成文件，结果如下：</p><ul><li><strong>替换所有</strong><blockquote><p>将obj里面的文件依次取出并放在f中,并改成f.d的形式,注意f是变量，要加上$(f),输出这个字符串</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oobj&#x3D;$(foreach f, $(obj), $(f).d)</span><br></pre></td></tr></table></figure><p>结果如下：</p><ul><li><strong>过滤文件</strong><blockquote><p>将src里面的符合xx.c形式的文件取出来，注意这里是依次取出，因此是%</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj&#x3D;$(filter %.c, $(src))</span><br></pre></td></tr></table></figure><p>输出结果：</p><ul><li><strong>反过滤函数</strong></li></ul><p>filter-out用法与filter相反，不再介绍</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>这个代码会生成两个目标，适用于编译多个可执行文件，上面的输出信息写在终极目标的命令中，因为终极目标不需要执行任何gcc指令<br>.PHONY : clean，声明一个伪目标，在文件夹下有文件名为clean的文件时，依然会执行makefile里面的clean指令，否则会执行这个clean文件，做个试验测试一下即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CC &#x3D; gcc</span><br><span class="line">CFLAGS &#x3D; -Wall -g</span><br><span class="line"></span><br><span class="line"># 查找，获取的也是一个字符串</span><br><span class="line">src &#x3D; $(wildcard .&#x2F;*.c)</span><br><span class="line"># 替换指定格式的文件</span><br><span class="line">obj &#x3D; $(patsubst .&#x2F;%.c, .&#x2F;%.o, $(src))</span><br><span class="line"># 替换所有</span><br><span class="line">dbj&#x3D;$(foreach f, $(obj), $(f).d)</span><br><span class="line"># 过滤文件</span><br><span class="line">fbj&#x3D;$(filter %.c, $(src))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target : client server</span><br><span class="line">echo $(fbj)</span><br><span class="line"></span><br><span class="line">client : client.o sckutil.o </span><br><span class="line">$(CC) $(CFLAGS) -o $@ $^</span><br><span class="line"></span><br><span class="line">server : server.o sckutil.o </span><br><span class="line">$(CC) $(CFLAGS) -o $@ $^</span><br><span class="line"></span><br><span class="line">%.o:%.c </span><br><span class="line">$(CC) -c -o $@ $&lt;</span><br><span class="line"></span><br><span class="line"># 伪目标</span><br><span class="line">.PHONY : clean</span><br><span class="line">clean:</span><br><span class="line">rm -rf *.o client server</span><br></pre></td></tr></table></figure><blockquote><p>以上是学习makefile必备的基础知识，知识来源于积累，，，</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Makefile</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下的静态库与动态库</title>
    <link href="/2019/07/13/Linux%E4%B8%8B%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <url>/2019/07/13/Linux%E4%B8%8B%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Linux下的库文件分为动态库和静态库，都是二进制文件，动态库的后缀为.so，静态库的后缀为.a</p></blockquote><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p><strong>静态库的命名规则：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lib + 静态库的名字 + .a</span><br></pre></td></tr></table></figure><p><strong>制作步骤：</strong></p><p>1) 生成对应的.o文件 ： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c xxx.c</span><br></pre></td></tr></table></figure><p>2) 将生成的.o文件打包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs xxx.a xxx.o</span><br></pre></td></tr></table></figure><p><strong>发布静态库</strong><br>发布静态库就是要发布.a文件和对应的头文件，头文件提供了库文件的接口</p><p><strong>示例：</strong><br>我的文件夹下有一个sckutil.c的套接字库文件，现在将它打包，并使用它编译一下TCP客户端client.c</p><p>看一下生成文件的大小：</p><p><strong>优缺点：</strong></p><ul><li>库里面的程序直接拷贝到应用程序中，发布应用程序时无需再发布库文件，但是会导致应用程序过大。如果一个系统多个应用程序都链接到相同的库文件，会导致一份代码多个拷贝的情况，浪费系统资源</li><li>无需动态链接，程序运行速度相对较快</li></ul><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p><strong>静态库的命名规则：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lib + 动态库的名字 + .so</span><br></pre></td></tr></table></figure><p><strong>动态库的三种名称：</strong></p><ul><li>soname，动态库的软链接名称,指向realname</li><li>realname, 动态库的真实名称，带有版本号信息，如 libsckutil.so.xxx，xxx是版本号</li><li>linkername，编译过程中使用的动态库的名称，如sckutil，linkername也是指向realname的，编译过程中使用-L指定动态库的位置，-l指定是哪个动态库</li></ul><p><strong>制作步骤：</strong></p><p>1) 生成位置无关的.o文件 ，加-fPIC选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -c xxx.c</span><br></pre></td></tr></table></figure><p>2) 将生成的.o文件打包： -shared选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libxxx.so xxx.o</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>可以看到，使用动态库之后文件的大小已经大大减少。</p>]]></content>
    
    
    <categories>
      
      <category>Unix环境编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix环境编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ipc小工具</title>
    <link href="/2019/07/12/ipc%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <url>/2019/07/12/ipc%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>分享一个ipc小工具，功能是清除某个用户下的ipc对象，这个对于我们开发时清理环境是很有用的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">echo &quot;check params...&quot;</span><br><span class="line">if [ $# !&#x3D; &quot;2&quot; ];then</span><br><span class="line">echo  &quot;usage: $0 user smg|shm|sem|all&quot;</span><br><span class="line">exit 1</span><br><span class="line">elif [ $2 !&#x3D; &quot;shm&quot; -a $2 !&#x3D; &quot;sem&quot; -a $2 !&#x3D; &quot;smg&quot; -a $2 !&#x3D; &quot;all&quot; ]; then</span><br><span class="line">echo &quot;usage: $0 user smg|shm|sem|all&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;delete the shm...&quot;</span><br><span class="line">if [ $2 &#x3D; &quot;shm&quot; -o $2 &#x3D; &quot;all&quot; ];then</span><br><span class="line">START&#x3D;&#96;ipcs|sed -n &#39;&#x2F;Shared&#x2F;&#x3D;&#39;&#96;</span><br><span class="line">END&#x3D;&#96;ipcs|sed -n &#39;&#x2F;Semaphore&#x2F;&#x3D;&#39;&#96;</span><br><span class="line">for i in &#96;ipcs | sed -n &quot;$&#123;START&#125;,$&#123;END&#125;p&quot; | grep $1 | awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">do</span><br><span class="line">ipcrm shm $i</span><br><span class="line">echo -e $i</span><br><span class="line">done</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;delete the sem...&quot;</span><br><span class="line">if [ $2 &#x3D; &quot;sem&quot; -o $2 &#x3D; &quot;all&quot; ];then</span><br><span class="line">START&#x3D;&#96;ipcs|sed -n &#39;&#x2F;Semaphore&#x2F;&#x3D;&#39;&#96;</span><br><span class="line">for i in &#96;ipcs | sed -n &quot;$&#123;START&#125;,$$p&quot; | grep $1 | awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">do</span><br><span class="line">ipcrm sem $i</span><br><span class="line">echo -e $i</span><br><span class="line">done</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;delete the msg...&quot;</span><br><span class="line">if [ $2 &#x3D; &quot;msg&quot; -o $2 &#x3D; &quot;all&quot; ];then</span><br><span class="line">START&#x3D;&#96;ipcs|sed -n &#39;&#x2F;Message&#x2F;&#x3D;&#39;&#96;</span><br><span class="line">END&#x3D;&#96;ipcs|sed -n &#39;&#x2F;Shared&#x2F;&#x3D;&#39;&#96;</span><br><span class="line">for i in &#96;ipcs | sed -n &quot;$&#123;START&#125;,$&#123;END&#125;p&quot; | grep $1 | awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">do</span><br><span class="line">ipcrm msg $i</span><br><span class="line">echo -e $i</span><br><span class="line">done</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>使用方法：</p>]]></content>
    
    
    <categories>
      
      <category>SHELL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SHELL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPC机制</title>
    <link href="/2019/07/12/IPC%E6%9C%BA%E5%88%B6/"/>
    <url>/2019/07/12/IPC%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>IPC，Inter-Process Communication，进程间通信<br>ipcs : 查看当前系统的IPC机制使用情况</p></blockquote><p>IPC进程间通信机制的料不多，信号量是一个比较难得点，但是要根据实际项目的场景进行分析，纸上谈兵是没有意义的。</p><h3 id="通过种子文件获取KEY-L的值"><a href="#通过种子文件获取KEY-L的值" class="headerlink" title="通过种子文件获取KEY_L的值"></a>通过种子文件获取KEY_L的值</h3><p>如果各个进程都需要获取相同的IPC对象的ID，因此需要相同的KEY_L，也就是IPC秘钥，可以通过ftok函数来获取相同的key，使用方法很简单</p><ul><li>在目录下建立一个种子文件，注意不能删除这个文件</li><li>所有的进程都调用ftok，第一个参数就是这个文件的路径和名字，第二个参数调相同的值，不为0即可</li></ul><h3 id="信号量的小工具分享"><a href="#信号量的小工具分享" class="headerlink" title="信号量的小工具分享"></a>信号量的小工具分享</h3><ul><li>分享一个信号量小工具，包括了信号量的所有操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;sem.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">union semun &#123;</span><br><span class="line">int              val;    &#x2F;&#x2F; Value for SETVAL </span><br><span class="line">struct semid_ds *buf;    &#x2F;&#x2F; Buffer for IPC_STAT, IPC_SET </span><br><span class="line">unsigned short  *array;  &#x2F;&#x2F; Array for GETALL, SETALL</span><br><span class="line">struct seminfo  *__buf;  &#x2F;&#x2F; Buffer for IPC_INFO</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 创建信号量 *&#x2F;</span><br><span class="line">int sem_creat(key_t key)</span><br><span class="line">&#123;</span><br><span class="line">int semid;</span><br><span class="line">semid &#x3D; semget(key, 1, 0666 | IPC_CREAT | IPC_EXCL);</span><br><span class="line">if (semid &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;semget error&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">return semid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 删除信号量 *&#x2F;</span><br><span class="line">int sem_delete(int semid)</span><br><span class="line">&#123;</span><br><span class="line">semctl(semid, 0, IPC_RMID, NULL);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 打开信号量 *&#x2F;</span><br><span class="line">int sem_open(key_t key)</span><br><span class="line">&#123;</span><br><span class="line">int semid;</span><br><span class="line">semid &#x3D; semget(key, 1, 0666);</span><br><span class="line">if (semid &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;semget error&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">return semid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设置信号量的值 *&#x2F;</span><br><span class="line">int sem_setval(int semid, int val)</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line">union semun su;</span><br><span class="line">&#x2F;* 表示资源的个数 *&#x2F;</span><br><span class="line">su.val &#x3D; val;</span><br><span class="line">ret &#x3D; semctl(semid, 0, SETVAL, su);</span><br><span class="line">if (ret &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;semctl error&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 获取信号量的值 *&#x2F;</span><br><span class="line">int sem_getval(int semid)</span><br><span class="line">&#123;</span><br><span class="line">int val &#x3D; 0;</span><br><span class="line">val &#x3D; semctl(semid, 0, GETVAL, NULL);</span><br><span class="line">if (val &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;semctl error&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;val : %d \n&quot;, val);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 信号量p操作 *&#x2F;</span><br><span class="line">int sem_p(int semid)</span><br><span class="line">&#123;</span><br><span class="line">struct sembuf sp &#x3D; &#123;0, -1, 0&#125;;</span><br><span class="line">semop(semid, &amp;sp, 1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 信号量v操作 *&#x2F;</span><br><span class="line">int sem_v(int semid)</span><br><span class="line">&#123;</span><br><span class="line">struct sembuf sv &#x3D; &#123;0, 1, 0&#125;;</span><br><span class="line">semop(semid, &amp;sv, 1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 获取信号量权限 *&#x2F;</span><br><span class="line">int sem_getmode(int semid)</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line">int val;</span><br><span class="line"></span><br><span class="line">struct semid_ds buf;</span><br><span class="line">ret &#x3D; semctl(semid, 0, IPC_STAT, &amp;buf);</span><br><span class="line">if (ret &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;semctl error&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">val &#x3D; buf.sem_perm.mode;</span><br><span class="line">printf(&quot;mode : 0%o \n&quot;,val);</span><br><span class="line">return val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设置信号量权限 *&#x2F;</span><br><span class="line">int sem_setmode(int semid, int mode)</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">struct semid_ds buf;</span><br><span class="line">buf.sem_perm.mode &#x3D; mode;</span><br><span class="line">ret &#x3D; semctl(semid, 0, IPC_SET, &amp;buf);</span><br><span class="line">if (ret &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;semctl error&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void usage()</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr,&quot;semtool -c 创建信号量\n&quot;);</span><br><span class="line">fprintf(stderr,&quot;semtool -d 删除信号量\n&quot;);</span><br><span class="line">fprintf(stderr,&quot;semtool -p 信号量p操作\n&quot;);</span><br><span class="line">fprintf(stderr,&quot;semtool -v 信号量v操作\n&quot;);</span><br><span class="line">fprintf(stderr,&quot;semtool -s&lt;val&gt; 信号量设置初始值\n&quot;);</span><br><span class="line">fprintf(stderr,&quot;semtool -g 获取信号量的值\n&quot;);</span><br><span class="line">fprintf(stderr,&quot;semtool -f 打开权限\n&quot;);</span><br><span class="line">fprintf(stderr,&quot;semtool -m&lt;mode&gt; 设置权限\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int opt;</span><br><span class="line">opt &#x3D; getopt(argc, argv, &quot;cdpvs:gfm:&quot;);</span><br><span class="line">if (opt &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">usage();</span><br><span class="line">exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key_t key;</span><br><span class="line">key &#x3D; ftok(&quot;.&quot;,&#39;s&#39;);</span><br><span class="line">int semid;</span><br><span class="line"></span><br><span class="line">switch (opt)</span><br><span class="line">&#123;</span><br><span class="line">case &#39;c&#39;:</span><br><span class="line">semid &#x3D; sem_creat(key);</span><br><span class="line">break;</span><br><span class="line">case &#39;d&#39;:</span><br><span class="line">semid &#x3D; sem_open(key);</span><br><span class="line">sem_delete(semid);</span><br><span class="line">break;</span><br><span class="line">case &#39;p&#39;:</span><br><span class="line">semid &#x3D; sem_open(key);</span><br><span class="line">sem_p(semid);</span><br><span class="line">sem_getval(semid);</span><br><span class="line">break;</span><br><span class="line">case &#39;v&#39;:</span><br><span class="line">semid &#x3D; sem_open(key);</span><br><span class="line">sem_v(semid);</span><br><span class="line">sem_getval(semid);</span><br><span class="line">break;</span><br><span class="line">case &#39;s&#39;:</span><br><span class="line">semid &#x3D; sem_open(key);</span><br><span class="line">sem_setval(semid, atoi(optarg));</span><br><span class="line">sem_getval(semid);</span><br><span class="line">break;</span><br><span class="line">case &#39;g&#39;:</span><br><span class="line">semid &#x3D; sem_open(key);</span><br><span class="line">sem_getval(semid);</span><br><span class="line">break;</span><br><span class="line">case &#39;f&#39;:</span><br><span class="line">semid &#x3D; sem_open(key);</span><br><span class="line">sem_getmode(semid);</span><br><span class="line">break;</span><br><span class="line">case &#39;m&#39;:</span><br><span class="line">semid &#x3D; sem_open(key);</span><br><span class="line">sem_setmode(semid, atoi(optarg));</span><br><span class="line">break;</span><br><span class="line">case &#39;?&#39;:</span><br><span class="line">usage();</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用这个小工具进行信号量的创建，使用，删除，pv操作，运行结果：</p>]]></content>
    
    
    <categories>
      
      <category>Unix环境编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix环境编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>管道</title>
    <link href="/2019/07/11/%E7%AE%A1%E9%81%93/"/>
    <url>/2019/07/11/%E7%AE%A1%E9%81%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>管道是一种进程间通信的方式，也就是 | 符号的含义</p></blockquote><p>图片来自于xmind导出的svg格式,右键打开图片，查看大图。。。</p><p>要讲的东西不多，直接看代码</p><h3 id="父子进程通信例子"><a href="#父子进程通信例子" class="headerlink" title="父子进程通信例子"></a>父子进程通信例子</h3><p><strong>示例程序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">int fcntl(int fd, int cmd, ... &#x2F;&#x2F; arg  );</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">void handler(int signum)</span><br><span class="line">&#123;</span><br><span class="line">if (signum &#x3D;&#x3D; SIGPIPE)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;rcv sig %d \n&quot;,signum);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line">int pipefd[2];</span><br><span class="line">signal(SIGPIPE, handler);</span><br><span class="line">&#x2F;* </span><br><span class="line">pipefd[0] 用于读 </span><br><span class="line">pipefd[1] 用于写 </span><br><span class="line">*&#x2F;</span><br><span class="line">ret &#x3D; pipe(pipefd);</span><br><span class="line">if (ret &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;pipe err&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">pid_t pid;</span><br><span class="line">pid &#x3D; fork();</span><br><span class="line">if (pid &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;fork err&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">if (pid &#x3D;&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">close(pipefd[0]);</span><br><span class="line"></span><br><span class="line">sleep(2);</span><br><span class="line">write(pipefd[1], &quot;childssssssssssss&quot;, 10);</span><br><span class="line"></span><br><span class="line">sleep(2);</span><br><span class="line">write(pipefd[1], &quot;childssssssssssss&quot;, 10);</span><br><span class="line"></span><br><span class="line">printf(&quot;child quit...\n&quot;);</span><br><span class="line">close(pipefd[1]);</span><br><span class="line"></span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char buf[1024];</span><br><span class="line">memset(buf,0,sizeof(buf));</span><br><span class="line">close(pipefd[1]);</span><br><span class="line">&#x2F;*</span><br><span class="line">fcntl 更改管道描述符属性为非阻塞&#x2F;阻塞</span><br><span class="line">*&#x2F;</span><br><span class="line">int flag;</span><br><span class="line">flag &#x3D; fcntl(pipefd[0], F_SETFL);</span><br><span class="line">&#x2F;&#x2F;flag |&#x3D; O_NONBLOCK;</span><br><span class="line">flag &amp;&#x3D; ~O_NONBLOCK;</span><br><span class="line">fcntl(pipefd[0], F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">ret &#x3D; read(pipefd[0], buf, sizeof(buf));</span><br><span class="line">if (ret &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;read err&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (ret &#x3D;&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;read err&quot;);</span><br><span class="line">&#125;</span><br><span class="line">buf[ret] &#x3D; &#39;\0&#39;;</span><br><span class="line">printf(&quot;rcv : %s \n&quot;,buf);</span><br><span class="line"></span><br><span class="line">close(pipefd[0]);</span><br><span class="line">wait(NULL);</span><br><span class="line">printf(&quot;parent quit...\n&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子进程关闭读，父进程关闭写，只能有子进程想父进程写数据</li><li>子进程向写两次数据</li><li>父进程读到第一次的数据之后关闭管道的读端，此时子进程再次写管道会接收到SIGPIPE信号，该信号默认动作是退出进程，这里注册了一个新的信号处理函数</li><li>父进程等待子进程退出，父进程退出</li></ul><h3 id="实现ls-wc-w"><a href="#实现ls-wc-w" class="headerlink" title="实现ls | wc -w"></a>实现ls | wc -w</h3><p>该命令是统计当前目录下文件和目录的单词数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">实现 ls | wc -w</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line">int pipefd[2];</span><br><span class="line"></span><br><span class="line">&#x2F;* pipefd[0] 用于读 pipefd[1] 用于写 *&#x2F;</span><br><span class="line">ret &#x3D; pipe(pipefd);</span><br><span class="line">if (ret &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;pipe err&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">pid_t pid;</span><br><span class="line">pid &#x3D; fork();</span><br><span class="line"></span><br><span class="line">&#x2F;* 子进程执行ls 写管道 *&#x2F;</span><br><span class="line">if (pid &#x3D;&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">close(pipefd[0]);</span><br><span class="line">&#x2F;* 复制管道的输出到标准输出 *&#x2F;</span><br><span class="line">dup2(pipefd[1],STDOUT_FILENO);</span><br><span class="line">close(pipefd[1]);</span><br><span class="line"></span><br><span class="line">execlp(&quot;ls&quot;, &quot;ls&quot;, NULL);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 父进程执行wc -c 读管道 *&#x2F;</span><br><span class="line">else if (pid &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">close(pipefd[1]);</span><br><span class="line">&#x2F;* 复制管道的读到标准输入 *&#x2F;</span><br><span class="line">dup2(pipefd[0],STDIN_FILENO);</span><br><span class="line">close(pipefd[1]);</span><br><span class="line">execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-w&quot;, NULL);</span><br><span class="line">&#125;</span><br><span class="line">wait(NULL);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子进程复制管道的输出替换原来的标准输出，并拉起ls程序</li><li>父进程复制管道的输入替换原来的标准输入，并拉起wc -w程序</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unix环境编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix环境编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>socket应用编程(2)</title>
    <link href="/2019/07/11/socket%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B(2)/"/>
    <url>/2019/07/11/socket%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B(2)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍的内容是在socket应用编程(1)的基础上进行一些错误的分析，返回值的判断以及对基本的API进行封装，目的是增强服务器的鲁棒性，可以应对复杂的网络环境，理解TCP/IP的11种状态以及使用代码复现某些状态是非常关键的，可以帮助你在发送错误的时候发现问题出在了什么地方。<br>本文除了介绍socket应用编程进阶的一些知识点之外，还将介绍TCP/IP协议的11种状态<br>netstat -na | grep xxx可以查看某个端口的连接状态，xxx表示端口</p></blockquote><p>图片来自于xmind导出的svg格式,右键打开图片，查看大图。。。</p><h3 id="TCP-IP协议的11种状态"><a href="#TCP-IP协议的11种状态" class="headerlink" title="TCP/IP协议的11种状态"></a>TCP/IP协议的11种状态</h3><p>TCP/IP的这11种状态的某些中间状态是TCP/IP协议栈自动推着连接往前走的，不需要上层参与，但是对于一些没有输入箭头的状态，如图中的FIN_WAIT_1等状态需要上层应用调用close才能使连接往下进行</p><p><strong>三次握手</strong></p><ul><li>TCP/IP协议需要确定双方的身份，服务器先监听套接字，客户端发起连接，会发生SYN报文到客户端，客户端返回一个SYN报文和一个应答信号给客户端，然后双方进入ESTABLSH状态，至此已经完成连接，accept从完成连接的队列里拿出连接并返回一个新的套接字</li></ul><p><strong>四次断开</strong></p><ul><li>客户端（或服务器）显式的调用close系统调用（前提是引用计数减少为0），会发送FIN报文给服务器，服务器接收到FIN报文时会返回ACK信号给客户端，同时服务器read调用会返回0，此时，客户端接收到ACK报文会到达FIN_WAIT_2状态，也就是半连接状态，客户端必须一直等服务器显式调用close之后才能进入TIME_WAIT状态，同时客户端会返回ACK信号给服务器，服务器会进入CLOSED状态，客户端的TIME_WAIT状态会持续一段时间，原因防止(ACK y+1)发送失败，便于重发。</li><li>通过read调用是否返回0来判断对方是否已经关闭，如果返回0，则调用close，关闭套接字</li></ul><p><strong>CLOSING状态</strong></p><ul><li>上图少了一种状态，就是closing状态，两端同时关闭将产生closing状态，最后双方都进入TIME_WAIT状态</li></ul><blockquote><p>socket编程对于返回值的判断十分关键，这可以精准的定位到问题所在。</p></blockquote><h3 id="select函数用法"><a href="#select函数用法" class="headerlink" title="select函数用法"></a>select函数用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;time.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">fd_set rfds;</span><br><span class="line">struct timeval tv;</span><br><span class="line">int retval;</span><br><span class="line"></span><br><span class="line">&#x2F;* Watch stdin (fd 0) to see when it has input. *&#x2F;</span><br><span class="line">FD_ZERO(&amp;rfds);</span><br><span class="line">FD_SET(0, &amp;rfds);</span><br><span class="line"></span><br><span class="line">&#x2F;* Wait up to five seconds. *&#x2F;</span><br><span class="line">tv.tv_sec &#x3D; 5;</span><br><span class="line">tv.tv_usec &#x3D; 0;</span><br><span class="line"></span><br><span class="line">retval &#x3D; select(1, &amp;rfds, NULL, NULL, &amp;tv);</span><br><span class="line">&#x2F;* Don&#39;t rely on the value of tv now! *&#x2F;</span><br><span class="line"></span><br><span class="line">if (retval &#x3D;&#x3D; -1)</span><br><span class="line">perror(&quot;select()&quot;);</span><br><span class="line">else if (retval)</span><br><span class="line">printf(&quot;Data is available now.\n&quot;);</span><br><span class="line">&#x2F;* FD_ISSET(0, &amp;rfds) will be true. *&#x2F;</span><br><span class="line">else</span><br><span class="line">printf(&quot;No data within five seconds.\n&quot;);</span><br><span class="line"></span><br><span class="line">exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过select管理标准输入，5s内无输入则返回,代码来自man手册示例程序。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unix环境编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix环境编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>socket应用编程(1)</title>
    <link href="/2019/07/11/socket%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B(1)/"/>
    <url>/2019/07/11/socket%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B(1)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍tcp/ip协议的基本知识，属于入门可能还不算的知识点，但是应该是必须掌握的。</p></blockquote><p>最基础的知识点大概是这样，有几个部分补充一下。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>tcp/ip协议栈模型：</p><ul><li>对等通信的概念是指服务器和客户端之间的通信只能是对等的协议层之间的通信，也就是说应用层与应用层通信，IP层与IP层通信，IP层是无法与应用层通信的</li><li>TCP/IP嵌入内核是因为网卡驱动收发大量数据的时候，切换到用户态会非常耗时，直接把TCP/IP放在内核中会减少数据传输的时间</li></ul><h3 id="TCP-IP客户端服务器基本编程模型"><a href="#TCP-IP客户端服务器基本编程模型" class="headerlink" title="TCP/IP客户端服务器基本编程模型"></a>TCP/IP客户端服务器基本编程模型</h3><ul><li>长连接是指服务器客户端发送数据后不立马断开，而是一直保持连接状态</li><li>短连接是指服务器客户端发送数据后立马断开</li><li>具体采用哪种连接方式视情况而定</li></ul><h3 id="测试字节序与IP地址转换测试程序"><a href="#测试字节序与IP地址转换测试程序" class="headerlink" title="测试字节序与IP地址转换测试程序"></a>测试字节序与IP地址转换测试程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa&#x2F;inet.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">#include &lt;netinet&#x2F;in.h&gt;</span><br><span class="line">#include &lt;arpa&#x2F;inet.h&gt;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 测试字节序 *&#x2F;</span><br><span class="line">unsigned int a&#x3D; 0x12345678;</span><br><span class="line">unsigned int b;</span><br><span class="line">unsigned char *p &#x3D; &amp;a;</span><br><span class="line">printf(&quot;0x%2x 0x%2x 0x%2x 0x%2x \n&quot;,p[0],p[1],p[2],p[3]);</span><br><span class="line">(p[0]&#x3D;&#x3D;0x78)? printf(&quot;本系统是小字节序\n&quot;) : printf(&quot;本系统是大字节序\n&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;字节序转换为网络字节序 ...\n&quot;);</span><br><span class="line">b &#x3D; htonl(a);</span><br><span class="line">p &#x3D; &amp;b;</span><br><span class="line">printf(&quot;0x%2x 0x%2x 0x%2x 0x%2x \n&quot;,p[0],p[1],p[2],p[3]);</span><br><span class="line">(p[0]&#x3D;&#x3D;0x78)? printf(&quot;网络字节序是小字节序\n&quot;) : printf(&quot;网络字节序是大字节序\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* IP字符串 与 iPv4:32bit  与  in_addr 的转换 *&#x2F;</span><br><span class="line">struct in_addr T_addr;</span><br><span class="line">const char *ip &#x3D; &quot;192.168.3.123&quot;;</span><br><span class="line">in_addr_t addr;</span><br><span class="line">char *ip2;</span><br><span class="line"></span><br><span class="line">&#x2F;* 字符串转in_addr结构 *&#x2F;</span><br><span class="line">inet_aton(ip,&amp;T_addr);</span><br><span class="line">printf(&quot;ipv4 %u \n&quot;,T_addr.s_addr);</span><br><span class="line"></span><br><span class="line">&#x2F;* 字符串转32bit *&#x2F;</span><br><span class="line">addr &#x3D; inet_addr(ip);</span><br><span class="line">printf(&quot;ipv4 %u \n&quot;,addr);</span><br><span class="line"></span><br><span class="line">&#x2F;* in_addr结构转字符串 *&#x2F;</span><br><span class="line">ip2 &#x3D; inet_ntoa(T_addr);</span><br><span class="line">&#x2F;&#x2F; printf(&quot;0x%x  0x%x \n&quot;,(unsigned int)ip2,(unsigned int)(&amp;T_addr));</span><br><span class="line">printf(&quot;%s \n&quot;,ip2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果：x86架构是小字节序，网络字节序是大字节序。。。。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unix环境编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix环境编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号</title>
    <link href="/2019/07/11/%E4%BF%A1%E5%8F%B7/"/>
    <url>/2019/07/11/%E4%BF%A1%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>信号实际上是一种软中断，如ARM的SWI指令可以产生软中断。</p></blockquote><p><strong>信号的料基本上就这么多，再提炼总结一下就是以下几点：</strong></p><ul><li><strong>signal函数和sigaction函数的对比</strong>，结论：后者传递信号的同时可以传递数据</li><li><strong>可靠信号与不可靠信号的对比</strong>，结论：前者linux内核会维护一个队列，存储所有未达的可靠信号，后者没有队列，因此易造次信号丢失</li><li><strong>信号的传递过程</strong>，内核会先检查信号阻塞状态字block，如果状态字该bit为1，linux内核则不会继续传递该信号</li><li><strong>pending状态字</strong>，即信号未决状态字，只要该信号被阻塞，pending状态字的对应bit位就会被置为1，可以通过检查该状态字，查看哪些信号被阻塞，通过对其的介绍可以知道，该状态字是由内核进行维护，应用程序是不可写可读的</li></ul><p><strong>kill -l 可以查看所有的信号，signal的默认动作和含义在man 7 signal</strong></p><p>画框的信号应该要知道：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>2</td><td>SIGINT</td><td>ctrl+c退出</td></tr><tr><td>3</td><td>SIGQUIT</td><td>ctrl+\退出</td></tr><tr><td>6</td><td>SIGABRT</td><td>abort()系统调用</td></tr><tr><td>9</td><td>SIGKILL</td><td>停止进程(此信号不能被忽略或捕获)</td></tr><tr><td>10</td><td>SIGUSR1</td><td>用户定义信号1</td></tr><tr><td>12</td><td>SIGUSR2</td><td>用户定义信号2</td></tr><tr><td>13</td><td>SIGPIPE</td><td>向没有读者的管道写入数据，默认动作为退出进程，很重要</td></tr><tr><td>14</td><td>SIGALRM</td><td>警告信号</td></tr><tr><td>17</td><td>SIGCHLD</td><td>子进程已经停止或退出</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unix环境编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix环境编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程</title>
    <link href="/2019/07/11/%E8%BF%9B%E7%A8%8B/"/>
    <url>/2019/07/11/%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文从整体上介绍linux进程的相关知识点，以及应该知道和了解的点，对于某些简单的点，会在框图下面给出解释，对于复杂的内容，会以单独的篇幅详细解释。</p></blockquote><ul><li>右键可以单独打开图片</li></ul><p>进程需要掌握的点如上图所示，左边是一些进程涉及到的知识点，右边是应知应会的一些API函数，这里边需要有几个点注意：</p><h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><h3 id="wait返回后判断子进程退出状态"><a href="#wait返回后判断子进程退出状态" class="headerlink" title="wait返回后判断子进程退出状态"></a>wait返回后判断子进程退出状态</h3><p>这部分内容应该是man手册里面的，不应该出现在这里。。。<br><strong>示例程序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">#define ERR_EXIT(m) \</span><br><span class="line">do&#123;\</span><br><span class="line">perror(m);\</span><br><span class="line">exit(EXIT_FAILURE);\</span><br><span class="line">&#125;while(0)</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">pid_t pid;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line">int status;</span><br><span class="line"></span><br><span class="line">pid &#x3D; fork();</span><br><span class="line">if (pid &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">ERR_EXIT(&quot;fork error :&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (pid &#x3D;&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;this is child %d \n&quot;,getpid());</span><br><span class="line">exit(10);</span><br><span class="line">&#x2F;&#x2F;abort();</span><br><span class="line">&#125;</span><br><span class="line">ret &#x3D; wait(&amp;status);</span><br><span class="line">if (ret &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">ERR_EXIT(&quot;wait error :&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (WIFEXITED(status)) &#x2F;&#x2F; 正常退出</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;正常退出 : %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">&#125;</span><br><span class="line">else if (WIFSIGNALED(status)) &#x2F;&#x2F; 异常退出</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;异常退出 : %d\n&quot;, WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line">else if (WIFSTOPPED(status)) &#x2F;&#x2F; 进程停止</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;进程停止 : %d\n&quot;, WSTOPSIG(status));</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="父进程等待子进程退出的问题"><a href="#父进程等待子进程退出的问题" class="headerlink" title="父进程等待子进程退出的问题"></a>父进程等待子进程退出的问题</h3><ul><li>父进程等待子进程退出有两个点需要注意一下，一是wait函数在有一个子进程返回时会立马返回，在多个子进程的情况下会导致其他的子进程没有收尸，二是wait调用的可中断睡眠，在接收到信号时，wait函数也会返回，需要作进一步判断。。。</li></ul><p><strong>示例程序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">#define ERR_EXIT(m) \</span><br><span class="line">do&#123;\</span><br><span class="line">perror(m);\</span><br><span class="line">exit(EXIT_FAILURE);\</span><br><span class="line">&#125;while(0)</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">pid_t pid;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line">int i;</span><br><span class="line">int num;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入子进程个数:&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line"></span><br><span class="line">for (i&#x3D;0; i&lt;num; i++)</span><br><span class="line">&#123;</span><br><span class="line">pid &#x3D; fork();</span><br><span class="line">if(pid &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">ERR_EXIT(&quot;fork error :&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (pid &#x3D;&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;this is child %d \n&quot;,getpid());</span><br><span class="line">sleep(1);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 收尸所有的僵尸进程 *&#x2F;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">ret &#x3D; wait(NULL);</span><br><span class="line">printf(&quot;子进程退出,mypid \n&quot;);</span><br><span class="line">if (ret &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">if(errno &#x3D;&#x3D; EINTR)&#x2F;&#x2F; 父进程阻塞过程中可能被别的信号中断</span><br><span class="line">&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;父进程退出 ....\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父进程创建了n个子进程，子进程先退出，父进程收尸，调用wait收尸所有的子进程，在阻塞期间可能会由别的信号使wait返回，应该判断errno的值并继续等待，运行结果：</li></ul><h3 id="sleep不可中断写法"><a href="#sleep不可中断写法" class="headerlink" title="sleep不可中断写法"></a>sleep不可中断写法</h3><p>sleep函数会将进程进行休眠，但是sleep函数属于可中断睡眠，在进程接收到信号之后会立刻返回，返回值为剩下的秒数，利用这个特点，可以让sleep在接收到信号之后继续睡眠，直到睡眠时间结束为止。</p><p><strong>示例程序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">n &#x3D; sleep(10);&#x2F;&#x2F; 返回剩余的秒数  可中断睡眠</span><br><span class="line">printf(&quot;keep sleeping ... \n&quot;);</span><br><span class="line">&#125;while(n&gt;0);</span><br></pre></td></tr></table></figure><blockquote><p>进程里面还有一些有料的点，后面单独讲。。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unix环境编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix环境编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UNIX环境编程概述</title>
    <link href="/2019/07/10/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
    <url>/2019/07/10/UNIX%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>回头看之前写的几篇unix环境编程的博客实在是惨不忍睹，像是在记流水账。于是在精心设计好框架之后重新写一下unix环境编程的内容，毕竟这块还是比较重要的也是比较基础的。无论是做嵌入式开发还是服务器开发，无论是驱动还是应用，这块都是绕不开的。之前写的内容都重写一下，另外新加一些。<br>以后博客的内容对于基础知识框架以框图的形式一笔带过，主要的内容放在重难点或者项目实用的或者是一些好玩的东西，博客的内容尽量简短，避免长篇大论。</p></blockquote><h2 id="unix环境编程知识框架"><a href="#unix环境编程知识框架" class="headerlink" title="unix环境编程知识框架"></a>unix环境编程知识框架</h2><ul><li>unix环境编程需要掌握的大概内容如上面的图所示，适用于系统工程师，系统工程师的工作更偏向于软件的底层框架，如果你偏向于网络编程方向，那你应该更加关注socket编程。这也是各个公司在面试嵌入式软件开发时很可能会问到的问题，大概率出自这里面，对于刚毕业的应届生，一般对于linux内核实现应该会问的很少（这里我是猜的，因为我也没毕业。。。）</li><li>另外，这只是一个整体框图，对于每一个部分的内容接下来会以单独的篇幅给出，也是以框图的形式，对于难点则会另外单开一篇。宗旨不变，减少篇幅，提炼精华。</li></ul><h2 id="如何入门嵌入式开发？"><a href="#如何入门嵌入式开发？" class="headerlink" title="如何入门嵌入式开发？"></a>如何入门嵌入式开发？</h2><p>相信很多同学尤其是本科刚毕业或者没有毕业的同学，对于单片机的知识已经很熟悉了，但是又不希望于只停留在单片机的层面上（本人最开始就是这种情况），那如何进入嵌入式的领域呢？<br>首先说说我的例子，我在本科学的单片机，学习STM32,然后接触了操作系统ucosIII,本科毕业后找了一份实习，做单片机开发，刚入职也应付不了单片机的工作，后来慢慢锻炼，感觉对于单片机开发应该是轻车熟路了。后来读研，在学习给老师做项目，最开始是一个硬件的项目，因为这个画了很多PCB，刚开始画了不能用不满意，重画，打板测试，再重画，再打板，后来终于能用了，顺利交付了项目，通过这个项目也锻炼了PCB Layout的能力。后来又有了一些上位机的项目，因此又学习了QT，QT开发到现在为止我也不知道自己是什么水平，但是对于简单的UI还是能搞得定的，到这算是入门嵌入式之前。<br>后来，我买了韦东山老师的视频和开发板，开始打开嵌入式的大门，由于我有单片机和硬件的基础，地址空间的概念在学ucosIII操作系统也玩的挺明白了，因此对于第一期视频我觉得还是挺简单的，但是ARM汇编和makefile还有代码重定位还是属实给我上了一课。对于BootLoader和移植那一块的东西，我觉得能手写一个boot是最好的，对boot的理解也最到位，移植和文件系统这块我是学完了之后移植了4.9的内核到开发板上，内核版本越高移植越简单。。。<br>后来按照顺序学习第二期，我就感觉有点吃力了，对于unix环境不了解，对于内核的子系统不了解，对于用户空间和内核空间也不了解，对于shell也不懂，因此老师调用的很多API只能达到看看的程度，根本不理解，但我还是硬着头皮学完了第二期，毕竟对于内核的那些机制是不需要其他知识只需要C语言好就行了，比如输入子系统，分离分层驱动模型什么的。。。在第二期学完之后，我突然意识到这种水平是没法去做嵌入式开发的，因为只了解了某些点，知识根本不全面，因此我就开始补充应用层的知识，也就是现在所要介绍的unix环境编程，还有shell的一些基础用法，之后也会有专题介绍，等把这些都学完之后，我感觉我与内核亲切了许多，感觉自己学的很多东西现在可以连起来了，虽然对于一些机制还是不怎么了解。。。<br>总结一下从单片机转嵌入式应该是以下的顺序：</p><ul><li>unix环境编程，建立内核与应用交互的概念</li><li>shell编程，熟悉内核脚本，建立亲切感</li><li>ARM汇编，裸机开发，boot学习，内核移植等，，，</li><li>驱动框架学习</li><li>设备树</li><li>。。。</li></ul><p>为什么没有写linux入门啥的，我觉得那些东西没必要单独学，在学习其他知识的过程中会慢慢掌握，还有，嵌入式开发很考验经验，但是对于在学校的学生无法实习的，最好也能做一两个小项目练手，但是千万别沉迷于项目忘记了学习，不学习你永远不会去做更有价值的事情，你永远不会更上一个台阶。。。个人观点。。。</p><h2 id="unix环境编程入门知识"><a href="#unix环境编程入门知识" class="headerlink" title="unix环境编程入门知识"></a>unix环境编程入门知识</h2><ul><li>对于unix环境编程首先是要时时刻刻建立起内核和应用程序的关系，<strong>要从内核的角度看应用开发</strong>，各种调度的机制是内核帮我们实现的，因此程序首先要进入内核态，在内核完成调度之后再切换回用户态。</li><li>进程三态是十分重要的知识点，等待的程序不可能直接运行，要先进入就绪态，等待内核调度，内核会从就绪队列中按照调度算法拿出相应的应用程序开始运行。。。</li><li>学习方式需要强调一下，学习unix环境编程应该侧重于<strong>学习内核的机制，而不是API</strong>，<strong>API查询应该统一去man手册查询而不是任何的书籍</strong>。学习机制的好处在于对于一些不好解释的现象可以从内核的角度进行解释。。。</li></ul><p>需要了解的主要知识点都在图上了，想深入理解还是建议自己去查。在网上这么多资源中找到真正能让你理解的，这也是一种能力。。。</p><hr><p>图片是矢量图，可以右键查看大图。。。</p>]]></content>
    
    
    <categories>
      
      <category>Unix环境编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix环境编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通用Makefile</title>
    <link href="/2019/06/24/%E9%80%9A%E7%94%A8Makefile/"/>
    <url>/2019/06/24/%E9%80%9A%E7%94%A8Makefile/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍一种适用于管理大型项目的通用Makefile写法，不同的项目可直接套用，分为三个部分，子目录makefile，顶层目录makefile和顶层目录的makefile.build</p></blockquote><h3 id="子目录Makefile写法"><a href="#子目录Makefile写法" class="headerlink" title="子目录Makefile写法"></a>子目录Makefile写法</h3><blockquote><p>子目录Makefile写法比较简单,如果有子目录的话加上dir/</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj-y +&#x3D; xxx.o</span><br><span class="line">#进入子目录test</span><br><span class="line">obj-y +&#x3D; test&#x2F;</span><br></pre></td></tr></table></figure><h3 id="顶层目录Makefile写法"><a href="#顶层目录Makefile写法" class="headerlink" title="顶层目录Makefile写法"></a>顶层目录Makefile写法</h3><p>顶层目录Makefile也比较简单，主要包括以下几个功能：</p><ul><li>定义obj-y来指定根目录下要编进程序去的文件、子目录</li><li>定义工具链、编译参数、链接参数，并用export导出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#交叉编译工具链</span><br><span class="line">CROSS_COMPILE &#x3D; </span><br><span class="line">#编译选项</span><br><span class="line">AS&#x3D; $(CROSS_COMPILE)as</span><br><span class="line">LD&#x3D; $(CROSS_COMPILE)ld</span><br><span class="line">CC&#x3D; $(CROSS_COMPILE)gcc</span><br><span class="line">CPP&#x3D; $(CC) -E</span><br><span class="line">AR&#x3D; $(CROSS_COMPILE)ar</span><br><span class="line">NM&#x3D; $(CROSS_COMPILE)nm</span><br><span class="line"></span><br><span class="line">STRIP&#x3D; $(CROSS_COMPILE)strip</span><br><span class="line">OBJCOPY&#x3D; $(CROSS_COMPILE)objcopy</span><br><span class="line">OBJDUMP&#x3D; $(CROSS_COMPILE)objdump</span><br><span class="line"></span><br><span class="line"># 导出变量给子makefile使用</span><br><span class="line">export AS LD CC CPP AR NM</span><br><span class="line">export STRIP OBJCOPY OBJDUMP</span><br><span class="line"></span><br><span class="line"># 编译选项</span><br><span class="line">CFLAGS :&#x3D; -Wall -O2 -g</span><br><span class="line">CFLAGS +&#x3D; -I $(shell pwd)&#x2F;include</span><br><span class="line"></span><br><span class="line">#链接选项：没有链接库</span><br><span class="line">LDFLAGS :&#x3D; </span><br><span class="line"></span><br><span class="line">export CFLAGS LDFLAGS</span><br><span class="line"></span><br><span class="line"># 导出顶层目录</span><br><span class="line">TOPDIR :&#x3D; $(shell pwd)</span><br><span class="line">export TOPDIR</span><br><span class="line"></span><br><span class="line">obj-y +&#x3D; main.o</span><br><span class="line">obj-y +&#x3D; a&#x2F;</span><br><span class="line">obj-y +&#x3D; b&#x2F;</span><br><span class="line"></span><br><span class="line">TARGET :&#x3D; test</span><br><span class="line"></span><br><span class="line"># make的默认目标</span><br><span class="line"># 把子目录下的built-in.o文件链接成目标</span><br><span class="line">all:</span><br><span class="line"># 进入某个目录，使用Makefile.build来编译</span><br><span class="line">make -C .&#x2F; -f $(TOPDIR)&#x2F;Makefile.build</span><br><span class="line">$(CC) $(LDFLAGS) -o $(TARGET) built-in.o</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm -f $(shell find -name &quot;*.o&quot;)</span><br><span class="line">rm -f $(TARGET)</span><br><span class="line"></span><br><span class="line">distclean:</span><br><span class="line">rm -f $(shell find -name &quot;*.o&quot;)</span><br><span class="line">rm -f $(shell find -name &quot;*.d&quot;)</span><br><span class="line">rm -f $(TARGET)</span><br></pre></td></tr></table></figure><h3 id="顶层目录Makefile-build写法"><a href="#顶层目录Makefile-build写法" class="headerlink" title="顶层目录Makefile.build写法"></a>顶层目录Makefile.build写法</h3><blockquote><p>顶层目录Makefile.build写法比较复杂，而且难以理解，我在代码中都给了注释</p></blockquote><p><strong>makefile的分析需要从终极目标一层一层往下分析：</strong></p><p>1 –build是第一个目标，make最终要生成这个目标<br>2 –build依赖于子目录$(subdir-y) 和当前目录的built-in.o，$(subdir-y)在之前定义，是子目录，built-in.o是当前目录的built-in.o文件，下面分别处理这两个依赖，看步骤3、4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__build : $(subdir-y) built-in.o</span><br></pre></td></tr></table></figure><p>3 进入子目录，<strong>递归</strong>使用Makefile.build进行编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(subdir-y):</span><br><span class="line">make -C $@ -f $(TOPDIR)&#x2F;Makefile.build</span><br></pre></td></tr></table></figure><p>4 built-in.o文件，依赖于当前目录所有的.o文件$(cur_objs)和子目录的built-in.o文件$(subdir_objs)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">built-in.o : $(cur_objs) $(subdir_objs)</span><br><span class="line">$(LD) -r -o $@ $^</span><br></pre></td></tr></table></figure><p>5 .o文件依赖于.c文件，执行Makefile文件里的CC指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">$(CC) $(CFLAGS) -Wp,-MD,$(dep_files) -c -o $@ $&lt;</span><br></pre></td></tr></table></figure><ul><li><strong>完整代码</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">PHONY :&#x3D; __build</span><br><span class="line"># 第一个目标</span><br><span class="line">__build:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj-y :&#x3D;</span><br><span class="line">subdir-y :&#x3D;</span><br><span class="line"></span><br><span class="line"># Makefile中含有obj-y，知道编译哪些子目录</span><br><span class="line">include Makefile</span><br><span class="line"></span><br><span class="line"># 子目录</span><br><span class="line"># 例：obj-y :&#x3D; a.o b.o c&#x2F; d&#x2F;,那么 subdir-y :&#x3D; c&#x2F; d&#x2F;，那么怎么把 c&#x2F; d&#x2F;取出来？</span><br><span class="line"># filter 函数：obj-y中符合 %&#x2F; 形式的文件取出来 </span><br><span class="line"># patsubst函数：把%&#x2F; 替换成 % </span><br><span class="line">subdir-y:&#x3D; $(patsubst %&#x2F;,%,$(filter %&#x2F;, $(obj-y)))</span><br><span class="line"></span><br><span class="line"># 子目录下的built-in.o文件</span><br><span class="line"># c&#x2F;built-in.o d&#x2F;built-in.o,取出子目录下的built-in.o文件</span><br><span class="line">subdir_objs :&#x3D; $(foreach f,$(subdir-y),$(f)&#x2F;built-in.o)</span><br><span class="line"></span><br><span class="line"># 取出当前目录下的.o文件</span><br><span class="line"># obj-y :&#x3D; a.o b.o c&#x2F; d&#x2F; 取出a.o b.o</span><br><span class="line"># filter-out 函数：从 obj-y 中把不匹配 %&#x2F; 的文本取出来,即取出文件，过滤掉目录</span><br><span class="line">cur_objs :&#x3D; $(filter-out %&#x2F;, $(obj-y))</span><br><span class="line"></span><br><span class="line"># 依赖文件，形式 .xx.o.d</span><br><span class="line"># foreach : 修改cur_objs里面的.o 为 .(xx.o).d 的形式</span><br><span class="line">dep_files :&#x3D; $(foreach f,$(cur_objs),.$(f).d)</span><br><span class="line"></span><br><span class="line"># 取出已经存在的.x.o.d文件放在dep_files里面</span><br><span class="line">dep_files :&#x3D; $(wildcard $(dep_files))</span><br><span class="line"></span><br><span class="line"># 如果dep_files不为空，则包含进来</span><br><span class="line">ifneq ($(dep_files),)</span><br><span class="line">  include $(dep_files)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"># __build 依赖于子目录和当前目录下的built-in.o</span><br><span class="line">__build : $(subdir-y) built-in.o</span><br><span class="line"></span><br><span class="line">PHONY +&#x3D; $(subdir-y)</span><br><span class="line"></span><br><span class="line"># 递归，进入子目录，使用Makefile.build进行编译</span><br><span class="line">$(subdir-y):</span><br><span class="line">make -C $@ -f $(TOPDIR)&#x2F;Makefile.build</span><br><span class="line"></span><br><span class="line"># built-in.o 依赖于当前目录下的.o文件 和 子目录下的built-in.o文件</span><br><span class="line">built-in.o : $(cur_objs) $(subdir_objs)</span><br><span class="line">$(LD) -r -o $@ $^</span><br><span class="line"></span><br><span class="line"># 延时变量</span><br><span class="line">dep_files &#x3D; .$@.d</span><br><span class="line"></span><br><span class="line"># 生成.o文件和依赖文件</span><br><span class="line">%.o : %.c</span><br><span class="line">$(CC) $(CFLAGS) -Wp,-MD,$(dep_files) -c -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">.PHONY : $(PHONY)</span><br></pre></td></tr></table></figure><blockquote><p>这种Makefile的写法适合项目，修改起来比较方便，可以直接套用。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Makefile</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从0移植4.9内核(1)</title>
    <link href="/2019/06/14/%E4%BB%8E0%E7%A7%BB%E6%A4%8D4.9%E5%86%85%E6%A0%B8(1)/"/>
    <url>/2019/06/14/%E4%BB%8E0%E7%A7%BB%E6%A4%8D4.9%E5%86%85%E6%A0%B8(1)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>简单说明：从搭建环境，安装虚拟机开始移植4.9内核到jz2440开发板，目的是复习Linux交叉编译环境和系统构建的过程</p></blockquote><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装ubuntu虚拟机18-04"><a href="#安装ubuntu虚拟机18-04" class="headerlink" title="安装ubuntu虚拟机18.04"></a>安装ubuntu虚拟机18.04</h3><ul><li>下载地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.ubuntu.com&#x2F;download&#x2F;desktop</span><br></pre></td></tr></table></figure><blockquote><p>注意虚拟机的网卡需要设置为桥接模式</p></blockquote><h3 id="下载linux内核4-9"><a href="#下载linux内核4-9" class="headerlink" title="下载linux内核4.9"></a>下载linux内核4.9</h3><ul><li>下载地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.kernel.org</span><br></pre></td></tr></table></figure><ul><li>解压过程分为两步</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xz -d linux-4.9.180.tar.xz</span><br><span class="line">tar xvf linux-4.9.180.tar</span><br></pre></td></tr></table></figure><ul><li>开启SSH服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server </span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;ssh start (如果没启动，手动启动)</span><br></pre></td></tr></table></figure><h3 id="安装arm-linux-gcc工具链"><a href="#安装arm-linux-gcc工具链" class="headerlink" title="安装arm-linux-gcc工具链"></a>安装arm-linux-gcc工具链</h3><ul><li>下载，解压，版本号:4.4.3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gcc-4.4.3.tar.gz</span><br><span class="line">tar -zxvf arm-linux-gcc-4.4.3.tar.gz</span><br></pre></td></tr></table></figure><ul><li>在/usr/local目录中新建文件夹，并解压</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir &#x2F;usr&#x2F;local&#x2F;arm</span><br><span class="line">sudo cp * &#x2F;usr&#x2F;local&#x2F;arm -rf</span><br></pre></td></tr></table></figure><ul><li>设置环境变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;environment</span><br><span class="line">添加 &#x2F;usr&#x2F;local&#x2F;arm&#x2F;bin</span><br></pre></td></tr></table></figure><h2 id="内核的配置过程分析"><a href="#内核的配置过程分析" class="headerlink" title="内核的配置过程分析"></a>内核的配置过程分析</h2><blockquote><p>在开始配置编译内核之前先来分析一下和内核编译息息相关的几个文件，Kconfig、.config、makefile，以及内核的编译过程</p></blockquote><ul><li>Linux内核配置有2中不同的方法，make menuconfig是最常用的方法，本文重点分析make menuconfig的过程，这三种方法殊途同归。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make .config &#x2F; make xxx_defconfig</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><h3 id="makefile-Kconfig-config之间的关系"><a href="#makefile-Kconfig-config之间的关系" class="headerlink" title="makefile/Kconfig/.config之间的关系"></a>makefile/Kconfig/.config之间的关系</h3><blockquote><p>Makefile ：编译源文件的方法<br>Kconfig: 文本文件，内核的配置菜单，提供所有的配置选项<br>.config: 编译内核所依据的配置,菜单里选中的菜     </p></blockquote><p><strong>Makefile：(drivers/Makefile)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 直接编译 *&#x2F;</span><br><span class="line">obj-y+&#x3D; cdrom&#x2F;</span><br><span class="line">obj-y+&#x3D; auxdisplay&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 条件编译：根据.config的CONFIG_XXX来决定是否编译 *&#x2F;</span><br><span class="line">&#x2F;* CONFIG_XXX变量的取值是通过.config文件来集中赋值的 *&#x2F;</span><br><span class="line">obj-$(CONFIG_PCCARD)+&#x3D; pcmcia&#x2F;</span><br><span class="line">obj-$(CONFIG_DIO)+&#x3D; dio&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 条件编译：只有make modules才会被编译 *&#x2F;</span><br><span class="line">obj-m+&#x3D; cdrom&#x2F;</span><br></pre></td></tr></table></figure><p><strong>Kconfig</strong><br>— 决定make menuconfig时展示的菜单项</p><ul><li>示例(drivers/leds/Kconfig）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">config LEDS_S3C24XX</span><br><span class="line">tristate &quot;LED Support for Samsung S3C24XX GPIO LEDs&quot;</span><br><span class="line">depends on LEDS_CLASS</span><br><span class="line">depends on ARCH_S3C24XX</span><br><span class="line">help</span><br><span class="line">This option enables support for LEDs connected to GPIO lines</span><br><span class="line">on Samsung S3C24XX series CPUs, such as the S3C2410 and S3C2440.</span><br><span class="line"></span><br><span class="line">config ： 关键字，表示一个配置选项的开始</span><br><span class="line"></span><br><span class="line">tristate : 显示为&lt; &gt;,&quot;LED Support for Samsung S3C24XX GPIO LEDs&quot;:make menuconfig 时显示的</span><br><span class="line">配置项名称，表示是否编译进内核，y&#x2F;m&#x2F;n</span><br><span class="line"></span><br><span class="line">bool：显示为[]，即无法配置成模块</span><br><span class="line"></span><br><span class="line">dependon ： 该选项依赖于另一个选项，只有依赖项被选中时，才能配置当前项</span><br><span class="line"></span><br><span class="line">select ： 反向依赖，该项选中时，同时选中select后面定义的那一项</span><br><span class="line"></span><br><span class="line">help: 帮助信息</span><br><span class="line"></span><br><span class="line">source：</span><br><span class="line">source &quot;arch&#x2F;$SRCARCH&#x2F;Kconfig&quot; --- (顶层makefile) ： 目录层次迭代，使各个</span><br><span class="line">目录管理自己的配置内容。</span><br></pre></td></tr></table></figure><p><strong>.config</strong></p><ul><li><p>内核编译参考文件，查看里面内容可以知道哪些驱动被编译进内核</p></li><li><p>Kconfig提供了编译选项，.config提供当前选中了哪些选项，在make menuconfig的时候修改的选项在保存后会同步到.config文件中</p></li><li><p>– 不建议直接修改.config</p></li></ul><p><strong>总结：三者之间的关系</strong></p><ul><li>makefile里面的条件编译的选项都是在.config里面集中定义的</li><li>Kconfig在make menuconfig的时候提供界面的选项，.config提供当前选中的选项，前者相当于菜单，后者相当于选中的菜，makefile就是炒这些菜的方法</li><li>make menuconfig 修改时会更新.config里面的配置项</li></ul><h3 id="make-menuconfig过程分析"><a href="#make-menuconfig过程分析" class="headerlink" title="make menuconfig过程分析"></a>make menuconfig过程分析</h3><p><strong>涉及到的文件：</strong></p><blockquote><p>1 Linux内核根目录下的scripts文件夹<br>2 arch/$ARCH/Kconfig文件、各层目录下的Kconfig文件<br>3 Linux内核根目录下的makefile文件、各层目录下的makefile文件<br>4 Linux内核根目录下的的.config文件、arm/$ARCH/下的config文件<br>5 Linux内核根目录下的 include/generated/autoconf.h文件</p></blockquote><p><strong>1 读取scripts文件夹中，存放的是make menuconfig 配置界面相关的文件</strong><br></p><p><strong>2 读取arch/$ARCH/Kconfig以及各子目录下的Kcondig ，生成配置条目</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ARCH 由根目录下的makefile决定：</span><br><span class="line">257 ARCH?&#x3D; arm</span><br><span class="line">258 CROSS_COMPILE?&#x3D; arm-linux-</span><br><span class="line">Kconfig文件中为配置信息的宏定义，与我们在make menuconfig图形界面看到的信息一致</span><br></pre></td></tr></table></figure><p><strong>3 读取内核目录下的.config文件，生成配置选项:[*]编译进内核 [M]编译为模块 []不编译</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arch&#x2F;arm&#x2F;configs ： 存放了一些配置模板</span><br><span class="line">可以通过cp &#x2F;arch&#x2F;arm&#x2F;configs&#x2F;xx_defconfig .config来使用这些配置模板 </span><br><span class="line">通过图形界面变更配置选项会自动更新到.config文件中 </span><br><span class="line">make disclean 会删除.config</span><br></pre></td></tr></table></figure><p><strong>4 编译过程根据.config生成 Linux内核根目录下的 include/config/auto.conf文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_EEPROM_93CX6&#x3D;m </span><br><span class="line">CONFIG_DM9000&#x3D;y </span><br><span class="line">根目录Makefile以及子目录的Makefile根据auto.conf生成编译条件 </span><br><span class="line">obj-$(CONFIG_DM9000) +&#x3D; dm9000.o &#x2F;&#x2F;obj-m +&#x3D; dm9000.o</span><br></pre></td></tr></table></figure><p><strong>5 编译过程根据.config生成Linux内核根目录下的 include/linux/autoconf.h文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.config 或 auto.conf 中定义要编译为 m 模块的项，如： </span><br><span class="line">CONFIG_DEBUG_NX_TEST&#x3D;m </span><br><span class="line">在 autoconf.h 中会被定义为： </span><br><span class="line">#define CONFIG_DEBUG_NX_TEST_MODULE 1 </span><br><span class="line"></span><br><span class="line">.config或auto.conf 中定义为编译为 y 的选项,如： </span><br><span class="line">CONFIG_DM9000&#x3D; y </span><br><span class="line">在 autoconf.h 中会被定义为： </span><br><span class="line">#define CONFIG_DM9000 1 </span><br><span class="line"></span><br><span class="line">autoconf.h中是站在源码的角度，供源码使用的C语言宏定义。</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 确定架构arch，读取arch目录的Kconfig中的配置，生成编译条目</span><br><span class="line"></span><br><span class="line">2 读取内核根目录下的.config选项，将配置信息显示在图像界面上[*] [M] []</span><br><span class="line"></span><br><span class="line">3 图像界面的改动会自动保存到.config文件中</span><br><span class="line"></span><br><span class="line">4 编译过程根据.config形成auto.config,它决定了makefile中各个文件的编译类型</span><br><span class="line">auto.config 相对于.config少了注释和增加了一些变量，顶层目录下的makefile包含auto.conf文件</span><br><span class="line"></span><br><span class="line">5 编译时生成autoconfig.h,以C语言宏的形式表达个各个文件是否被编译，源码中</span><br><span class="line">  会判断某文件是否被编译进行不同的处理。</span><br></pre></td></tr></table></figure><h2 id="配置编译内核"><a href="#配置编译内核" class="headerlink" title="配置编译内核"></a>配置编译内核</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*修改顶层makefile*&#x2F;</span><br><span class="line">257 ARCH?&#x3D; arm</span><br><span class="line">258 CROSS_COMPILE?&#x3D; arm-linux-</span><br><span class="line"></span><br><span class="line">&#x2F;* 复制默认的配置文件到顶层文件目录下的.config文件 *&#x2F;</span><br><span class="line">cd &#x2F;work&#x2F;sys&#x2F;linux-4.9.180&#x2F;arch&#x2F;arm&#x2F;configs</span><br><span class="line">cp  s3c2410_defconfig  &#x2F;work&#x2F;sys&#x2F;linux-4.9.180&#x2F;.config</span><br><span class="line"></span><br><span class="line">&#x2F;* 安装缺少的库 *&#x2F;</span><br><span class="line">sudo apt-get install libc6-dev</span><br><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br><span class="line"></span><br><span class="line">&#x2F;* 配置,裁剪内核  *&#x2F;</span><br><span class="line">make menuconfig</span><br><span class="line">make uImage</span><br><span class="line">出现错误 ：&#x2F;usr&#x2F;local&#x2F;arm&#x2F;bin&#x2F;arm-linux-gcc: 15: exec: &#x2F;usr&#x2F;local&#x2F;arm&#x2F;bin&#x2F;.arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">原因：64位的系统缺少32位的库</span><br><span class="line">根据错误提示安装32位的库：</span><br><span class="line">sudo apt-get install lib32z1</span><br><span class="line">sudo apt-get install lib32stdc++6</span><br><span class="line">再次make uImage </span><br><span class="line"></span><br><span class="line">错误：arch&#x2F;arm&#x2F;boot&#x2F;Makefile:79: recipe for target &#39;arch&#x2F;arm&#x2F;boot&#x2F;uImage&#39; failed</span><br><span class="line">解决：sudo apt-get install u-boot-tools</span><br><span class="line"></span><br><span class="line">再次make uImage ,即可编译通过</span><br><span class="line">Image Name:   Linux-4.9.180</span><br><span class="line">Created:      Sun Jun  9 23:09:38 2019</span><br><span class="line">Image Type:   ARM Linux Kernel Image (uncompressed)</span><br><span class="line">Data Size:    3150272 Bytes &#x3D; 3076.44 KiB &#x3D; 3.00 MiB</span><br><span class="line">Load Address: 30108000</span><br><span class="line">Entry Point:  30108000</span><br><span class="line"></span><br><span class="line">下载内核到开发板上：</span><br><span class="line">tftp 30000000 uImage</span><br><span class="line">bootm 30000000</span><br><span class="line">可以打印出内核信息，但是并不能正常启动内核，因此需要修改内核</span><br></pre></td></tr></table></figure><h2 id="修改内核"><a href="#修改内核" class="headerlink" title="修改内核"></a>修改内核</h2><p><strong>设置机器ID</strong>        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Error: unrecognized&#x2F;unsupported machine ID (r1 &#x3D; 0x000000c1).</span><br><span class="line"></span><br><span class="line">Available machine support:</span><br><span class="line"></span><br><span class="line">ID (hex)        NAME</span><br><span class="line">000002de        Simtec-Anubis</span><br><span class="line">00000707        AT2440EVB</span><br><span class="line">000007cf        MINI2440</span><br><span class="line">000002a9        NexVision - Nexcoder 2440</span><br><span class="line">0000034a        Simtec-OSIRIS</span><br><span class="line">00000250        IPAQ-RX3715</span><br><span class="line">0000016a        SMDK2440</span><br><span class="line"></span><br><span class="line">设置：</span><br><span class="line">上面是.config文件中配置成y的机器类型：因此set machid 选择单板和其中最相近的一个单板即可。</span><br><span class="line">uboot设置机器ID参数  set machid 0x16a;save</span><br></pre></td></tr></table></figure><p><strong>修改时钟</strong>              </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">linux-4.9.180&#x2F;arch&#x2F;arm&#x2F;mach-s3c24xx$ vi mach-smdk2440.c</span><br><span class="line">static void __init smdk2440_init_time(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;s3c2440_init_clocks(16934400);</span><br><span class="line">s3c2440_init_clocks(12000000);</span><br><span class="line">samsung_timer_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改MTD分区</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">与uboot里面设置的一样</span><br><span class="line">arch\arm\mach-s3c24xx\common-smdk.c</span><br><span class="line">static struct mtd_partition smdk_default_nand_part[] &#x3D; &#123;</span><br><span class="line">[0] &#x3D; &#123;</span><br><span class="line">.name&#x3D; &quot;u-boot&quot;,</span><br><span class="line">.size&#x3D; SZ_256K,</span><br><span class="line">.offset&#x3D; 0,</span><br><span class="line">&#125;,</span><br><span class="line">[1] &#x3D; &#123;</span><br><span class="line">.name&#x3D; &quot;params&quot;,</span><br><span class="line">.offset &#x3D; MTDPART_OFS_APPEND,</span><br><span class="line">.size&#x3D; SZ_128K,</span><br><span class="line">&#125;,</span><br><span class="line">[2] &#x3D; &#123;</span><br><span class="line">.name&#x3D; &quot;kernel&quot;,</span><br><span class="line">.offset &#x3D; MTDPART_OFS_APPEND,</span><br><span class="line">.size&#x3D; SZ_4M,</span><br><span class="line">&#125;</span><br><span class="line">[3] &#x3D; &#123;</span><br><span class="line">.name&#x3D; &quot;rootfs&quot;,</span><br><span class="line">.offset &#x3D; MTDPART_OFS_APPEND,</span><br><span class="line">.size&#x3D; MTDPART_SIZ_FULL,</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下载内核并启动，nandflash已经正确显示分区，看到内核panic信息：mount root 错误，没有挂接到正确的文件系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VFS: Cannot open root device &quot;mtdblock3&quot; or unknown-block(0,0): error -6</span><br></pre></td></tr></table></figure><p>原因可能是：</p><blockquote><p>1 MTD分区和boot的分区对不上,找不到根文件系统<br>2 nand flash中对应的位置没有根文件系统<br>3 命令行参数设置的不对<br>4 内核中没有对应的文件系统</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">由于uboot设置的nandflash分区内核部分为2M,而4.9的内核大于2M,</span><br><span class="line">因此需要修改uboot的nandflash分区</span><br><span class="line"></span><br><span class="line">修改uboot2012:</span><br><span class="line">1 修改分区 </span><br><span class="line">&#x2F;include&#x2F;configs&#x2F;smdk2440.h</span><br><span class="line">#define MTDPARTS_DEFAULT        &quot;mtdparts&#x3D;jz2440-0:256k(u-boot),&quot;       \</span><br><span class="line">                                    &quot;128k(params),&quot;         \</span><br><span class="line">                                    &quot;4m(kernel),&quot;   \</span><br><span class="line">                                    &quot;-(rootfs)&quot;             \</span><br><span class="line">重新 make</span><br></pre></td></tr></table></figure><p>2 u-boot nandflash 操作方法介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">烧写u-boot:</span><br><span class="line">tftp 30000000 u-boot.bin; protect off all; erase 0 0x3ffff; cp.b 30000000 0 40000</span><br><span class="line"></span><br><span class="line">tftp烧写内核到nandflash:</span><br><span class="line">tftp 30000000 uImage</span><br><span class="line">nand erase.part kernel</span><br><span class="line">nand write 30000000 kernel</span><br><span class="line"></span><br><span class="line">tftp烧写jffs文件系统：</span><br><span class="line">tftp 30000000 fs_mini_mdev.jffs2</span><br><span class="line">nand erase.part rootfs</span><br><span class="line">&#x2F;                        目标地址  大小&#x2F;</span><br><span class="line">nand write.jffs2 30000000 260000 5b89a8</span><br><span class="line">set boota rgs console&#x3D;ttySAC0 root&#x3D;&#x2F;dev&#x2F;mtdblock3 rootfstype&#x3D;jffs2</span><br><span class="line"></span><br><span class="line">tftp烧写yaffs文件系统：  </span><br><span class="line">tftp 30000000 fs_qtopia.yaffs2</span><br><span class="line">nand erase.part rootfs</span><br><span class="line">&#x2F;                        目标地址  大小&#x2F;</span><br><span class="line">nand write.yaffs 30000000 260000 889bc0</span><br></pre></td></tr></table></figure><blockquote><p>到此为止，内核和u-boot需要修改的部分以及修改完成，下一步制作最小根文件系统</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux系统构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux系统构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从0移植4.9内核(2)</title>
    <link href="/2019/06/14/%E4%BB%8E0%E7%A7%BB%E6%A4%8D4.9%E5%86%85%E6%A0%B8(2)/"/>
    <url>/2019/06/14/%E4%BB%8E0%E7%A7%BB%E6%A4%8D4.9%E5%86%85%E6%A0%B8(2)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>简单说明：从搭建环境，安装虚拟机开始移植4.9内核到jz2440开发板，目的是复习Linux交叉编译环境和系统构建的过程</p></blockquote><h2 id="构建最小根文件系统"><a href="#构建最小根文件系统" class="headerlink" title="构建最小根文件系统"></a>构建最小根文件系统</h2><blockquote><p>根文件系统和文件系统的区别：<br>文件系统是对一个存储设备上的数据进行组织的机制，这种机制有利于用户和操作系统交互<br>根文件系统是一种文件系统,不仅具有普通文件系统存储数据文件的功能,还是内核启动mount<br>的第一个文件系统</p></blockquote><h3 id="Linux进程启动分析"><a href="#Linux进程启动分析" class="headerlink" title="Linux进程启动分析"></a>Linux进程启动分析</h3><ul><li>内核源码分析：init/main.c<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static int noinline init_post(void)</span><br><span class="line">&#x2F;* 创建标准输入,标准输出,标准错误 *&#x2F;</span><br><span class="line">if (sys_open((const char __user *) &quot;&#x2F;dev&#x2F;console&quot;, O_RDWR, 0) &lt; 0)</span><br><span class="line">printk(KERN_WARNING &quot;Warning: unable to open an initial console.\n&quot;);</span><br><span class="line">(void) sys_dup(0);</span><br><span class="line">(void) sys_dup(0);</span><br><span class="line"></span><br><span class="line">&#x2F;* execute_command 在 boot命令行参数中设置为 init&#x3D;&#x2F;linuxrc *&#x2F;</span><br><span class="line">if (execute_command) </span><br><span class="line">&#x2F;* 启动第一个程序,是死循环，不会退出 *&#x2F;</span><br><span class="line">run_init_process(execute_command);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 第一个应用程序一般是execute_command 或者是&quot;&#x2F;sbin&#x2F;init&quot;,一般不会调用到后面的 *&#x2F;</span><br><span class="line">run_init_process(&quot;&#x2F;sbin&#x2F;init&quot;);</span><br><span class="line">run_init_process(&quot;&#x2F;etc&#x2F;init&quot;);</span><br><span class="line">run_init_process(&quot;&#x2F;bin&#x2F;init&quot;);</span><br><span class="line">run_init_process(&quot;&#x2F;bin&#x2F;sh&quot;);</span><br></pre></td></tr></table></figure></li></ul><p><strong>init程序的执行过程 ：（配置文件/etc/inittab）</strong></p><blockquote><p>1 读取配置文件<br>2 解析配置文件<br>    2.1 配置文件指定应用程序<br>    2.2 指定何时执行<br>3 执行用户程序</p></blockquote><p><strong>init程序就是busybox</strong><br><strong>linuxrc 和 /sbin/init 都是busybox的链接，都指向 /bin/busybox</strong><br>busybox根据<strong>/etc/inittab</strong>里面的项进行系统初始化，最后执行 <strong>/etc/init.d/rcS</strong> 脚本<br><strong>busybox 的 执行顺序：/sbin/init &gt; /etc/inittab &gt; /etc/init.d/rcS</strong></p><ul><li>/etc/inittab 格式 —根据busybox的文档inittab</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br><span class="line">1 id &#x3D;&gt; &#x2F;dev&#x2F;id   用作终端：stdin,stdout... 可以省略</span><br><span class="line">2 runlevels ： 忽略</span><br><span class="line">3 action ： 执行时机，  </span><br><span class="line">sysinit,</span><br><span class="line">respawn,</span><br><span class="line">askfirst,</span><br><span class="line">wait,</span><br><span class="line">once,</span><br><span class="line">restart,</span><br><span class="line">ctrlaltdel,</span><br><span class="line">shutdown</span><br><span class="line">4 process ： 应用程序或脚本</span><br></pre></td></tr></table></figure><p><strong>由此可以推出：init程序需要准备东西(即最小根文件系统)</strong></p><blockquote><p>1 /dev/console  /dev/null<br>2 /etc/inittab 文件<br>3 配置文件里指定的应用程序<br>4 C库(glibc)<br>5 init程序本身，来源于busybox</p></blockquote><h3 id="制作最小根文件系统"><a href="#制作最小根文件系统" class="headerlink" title="制作最小根文件系统"></a>制作最小根文件系统</h3><h4 id="配置，编译busybox"><a href="#配置，编译busybox" class="headerlink" title="配置，编译busybox"></a>配置，编译busybox</h4><p>下载链接 ： <a href="https://busybox.net/downloads/">https://busybox.net/downloads/</a><br>下载版本：1.20.0</p><p>配置安装方法：查看INSTALL文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig     # This creates a file called &quot;.config&quot;</span><br><span class="line">make                # This creates the &quot;busybox&quot; executable</span><br><span class="line">make install        # or make CONFIG_PREFIX&#x3D;&#x2F;path&#x2F;from&#x2F;root install</span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xjf busybox-1.20.0.tar.bz2</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd busybox-1.20.0.tar.bz2</span><br><span class="line">make menuconfig 完成后保存，因为需要生成.config配置文件</span><br></pre></td></tr></table></figure><p>设置交叉编译工具链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi Makefile</span><br><span class="line">CROSS_COMPILE ?&#x3D;arm-linux-</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">创建安装的文件夹，-p表示递归创建</span><br><span class="line">sudo mkdir &#x2F;work&#x2F;nfs_root&#x2F;first_fs -p</span><br><span class="line"></span><br><span class="line">安装,安装有错误要修改文件夹的权限</span><br><span class="line">make CONFIG_PREFIX&#x3D;&#x2F;work&#x2F;nfs_root&#x2F;first_fs install</span><br><span class="line"></span><br><span class="line">查看文件夹，已经创建了相应的目录了:</span><br><span class="line">zhanghui@ubuntu:&#x2F;work&#x2F;nfs_root&#x2F;first_fs$ ls</span><br><span class="line">bin  linuxrc  sbin  usr</span><br></pre></td></tr></table></figure><h4 id="构建最小根文件系统：（按照init进程分析的结果）"><a href="#构建最小根文件系统：（按照init进程分析的结果）" class="headerlink" title="构建最小根文件系统：（按照init进程分析的结果）####"></a>构建最小根文件系统：（按照init进程分析的结果）####</h4><p><strong>1 创建/dev/console  /dev/null设备节点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir dev</span><br><span class="line">&#x2F;&#x2F; 查看虚拟机的 &#x2F;dev&#x2F;console &#x2F;dev&#x2F;null 节点信息：</span><br><span class="line">zhanghui@ubuntu:&#x2F;work&#x2F;nfs_root&#x2F;first_fs&#x2F;dev$ ls &#x2F;dev&#x2F;console &#x2F;dev&#x2F;null -l</span><br><span class="line">crw------- 1 root root 5, 1 Jun 12 00:26 &#x2F;dev&#x2F;console</span><br><span class="line">crw-rw-rw- 1 root root 1, 3 Jun 12 00:24 &#x2F;dev&#x2F;null</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建设备节点，字符设备&#x2F;主&#x2F;次设备号</span><br><span class="line">sudo mknod console c 5 1 </span><br><span class="line">sudo mknod null c 1 3</span><br></pre></td></tr></table></figure><p><strong>2 创建/etc/inittab</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir etc</span><br><span class="line">vi inittab</span><br><span class="line">console::askfirst:-&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p><strong>3 安装C库</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C库的位置在：</span><br><span class="line">zhanghui@ubuntu:&#x2F;work&#x2F;sys&#x2F;opt&#x2F;FriendlyARM&#x2F;toolschain&#x2F;4.4.3&#x2F;lib$ ls</span><br><span class="line"></span><br><span class="line">gcc            libcloog.so.0.0.0  libgmpxx.la        libmpc.la        libmpfr.so        libmp.so.3       libppl_c.so.2.1.0  libpwl.la</span><br><span class="line">ldscripts      libgmp.la          libgmpxx.so        libmpc.so        libmpfr.so.1      libmp.so.3.1.14  libppl.la          libpwl.so</span><br><span class="line">libcloog.la    libgmp.so          libgmpxx.so.4      libmpc.so.2      libmpfr.so.1.2.2  libppl_c.la      libppl.so          libpwl.so.4</span><br><span class="line">libcloog.so    libgmp.so.3        libgmpxx.so.4.1.0  libmpc.so.2.0.0  libmp.la          libppl_c.so      libppl.so.7        libpwl.so.4.0.0</span><br><span class="line">libcloog.so.0  libgmp.so.3.5.0    libiberty.a        libmpfr.la       libmp.so          libppl_c.so.2    libppl.so.7.1.0</span><br><span class="line"></span><br><span class="line">创建lib目录：</span><br><span class="line">mkdir &#x2F;work&#x2F;nfs_root&#x2F;first_fs&#x2F;lib</span><br><span class="line"></span><br><span class="line">拷贝C库到lib目录：</span><br><span class="line">cp *.so* &#x2F;work&#x2F;nfs_root&#x2F;first_fs&#x2F;lib -d</span><br></pre></td></tr></table></figure><p><strong>4 指定应用程序</strong><br> — 没有应用程序</p><p><strong>5 完善最小根文件系统</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">创建proc文件系统  </span><br><span class="line">mkdir proc</span><br><span class="line"></span><br><span class="line">在&#x2F;etc&#x2F;inittab中加上：</span><br><span class="line">::sysinit:&#x2F;etc&#x2F;init.d&#x2F;rcS</span><br><span class="line">再创建init.d&#x2F;rcS脚本文件</span><br><span class="line">mkdir init.d</span><br><span class="line">vi rcS   </span><br><span class="line">sudo chmod +x rcS</span><br><span class="line">&#x2F;&#x2F; 自动挂载proc文件系统</span><br><span class="line">mount -t  proc none &#x2F;proc </span><br><span class="line"></span><br><span class="line">另外一种方法：</span><br><span class="line">vi rcS</span><br><span class="line">#mount -t  proc none &#x2F;proc </span><br><span class="line">mount -a  </span><br><span class="line">mount -a 依赖于&#x2F;etc&#x2F;fstab</span><br><span class="line">创建fstab, vi fstab  添加</span><br><span class="line"> proc     &#x2F;proc     proc   defaults  0      0</span><br></pre></td></tr></table></figure><ul><li>fstab的格式： 执行mount -a 后将挂接proc tmpfs 文件系统</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># device mount-pount type  options   dump  fsck order </span><br><span class="line">  proc     &#x2F;proc     proc   defaults  0      0</span><br><span class="line">  tmpfs    &#x2F;tmp      tmpfs  defaults  0      0</span><br></pre></td></tr></table></figure><p><strong>6 增加udev机制(自动创建设备节点)</strong></p><p>— busybox里面的简化版本 mdev</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir sys</span><br><span class="line">vi etc&#x2F;fstab</span><br><span class="line">添加：</span><br><span class="line">sysfs    &#x2F;sys   sysfs  defaults  0  0</span><br><span class="line">tmpfs    &#x2F;dev   tmpfs  defaults  0  0</span><br><span class="line">vi etc&#x2F;init.d&#x2F;rcS</span><br><span class="line">添加：</span><br><span class="line">mkdir &#x2F;dev&#x2F;pts</span><br><span class="line">mount -t devpts devpts &#x2F;dev&#x2F;pts</span><br><span class="line">echo &#x2F;sbin&#x2F;mdev &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure><h2 id="制作根文件系统映像文件"><a href="#制作根文件系统映像文件" class="headerlink" title="制作根文件系统映像文件"></a>制作根文件系统映像文件</h2><h3 id="制作yaffs2文件系统"><a href="#制作yaffs2文件系统" class="headerlink" title="制作yaffs2文件系统"></a>制作yaffs2文件系统</h3><ul><li>制作工具 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yaffs_source_util_larger_small_page_nand.tar.bz2 （韦东山）</span><br><span class="line">tar xjf yaffs_source_util_larger_small_page_nand.tar.bz2</span><br><span class="line">cd &#x2F;work&#x2F;sys&#x2F;Development_util_ok&#x2F;yaffs2&#x2F;utils(里面含有makefile)</span><br><span class="line">make</span><br></pre></td></tr></table></figure><ul><li>编译结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">zhanghui@ubuntu:&#x2F;work&#x2F;sys&#x2F;Development_util_ok&#x2F;yaffs2&#x2F;utils$ ls -l</span><br><span class="line">total 144</span><br><span class="line">-rw------- 1 zhanghui zhanghui  1770 Jul  7  2008 Makefile</span><br><span class="line">-rwxrwxr-x 1 zhanghui zhanghui 22768 Jun 12 01:22 mkyaffs2image</span><br><span class="line">-rw------- 1 zhanghui zhanghui 19669 Jul  7  2008 mkyaffs2image.c</span><br><span class="line">-rw-rw-r-- 1 zhanghui zhanghui 12408 Jun 12 01:22 mkyaffs2image.o</span><br><span class="line">-rwxrwxr-x 1 zhanghui zhanghui 18496 Jun 12 01:22 mkyaffsimage</span><br><span class="line">-rw------- 1 zhanghui zhanghui 16206 Feb 28  2008 mkyaffsimage.c</span><br><span class="line">-rw-rw-r-- 1 zhanghui zhanghui 11160 Jun 12 01:22 mkyaffsimage.o</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">我们使用 mkyaffs2image 这个工具</span><br><span class="line">拷贝到系统目录：</span><br><span class="line">sudo cp mkyaffs2image &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;mkyaffs2image</span><br><span class="line"></span><br><span class="line">切换到最小根文件系统目录的上一级：</span><br><span class="line">cd &#x2F;work&#x2F;nfs_root&#x2F;</span><br><span class="line"></span><br><span class="line">创建映像：</span><br><span class="line">&#x2F;* 目录    名称  *&#x2F;</span><br><span class="line"> mkyaffs2image first_fs first_fs.yaffs2</span><br><span class="line"> </span><br><span class="line">创建成功：</span><br><span class="line">zhanghui@ubuntu:&#x2F;work&#x2F;nfs_root$ ls</span><br><span class="line">first_fs  first_fs.yaffs2</span><br></pre></td></tr></table></figure><h3 id="制作jffs2文件系统"><a href="#制作jffs2文件系统" class="headerlink" title="制作jffs2文件系统"></a>制作jffs2文件系统</h3><ul><li>u-boot 命令行参数设置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set bootargs noinitrd console&#x3D;ttySAC0,115200 root&#x3D;&#x2F;dev&#x2F;mtdblock3 </span><br><span class="line">rootfstype&#x3D;jffs2 init&#x3D;&#x2F;linuxrc</span><br></pre></td></tr></table></figure><ul><li>制作jffs2文件系统</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">工具：</span><br><span class="line">mtd-utils-05.07.23.tar.bz2</span><br><span class="line">zlib-1.2.3.tar.gz</span><br><span class="line"></span><br><span class="line">解压</span><br><span class="line">tar xzf zlib-1.2.3.tar.gz</span><br><span class="line"></span><br><span class="line">配置</span><br><span class="line">.&#x2F;configure --shared --prefix&#x3D;&#x2F;usr</span><br><span class="line"></span><br><span class="line">编译 安装</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">解压</span><br><span class="line">tar xjf mtd-utils-05.07.23.tar.bz2</span><br><span class="line">cd mtd-utils-05.07.23&#x2F;util&#x2F;</span><br><span class="line">make</span><br><span class="line">sudo make install </span><br><span class="line"></span><br><span class="line">制作：</span><br><span class="line">cd &#x2F;work&#x2F;nfs_root&#x2F;</span><br><span class="line">mkfs.jffs2 -n -s 2048 -e 128KiB -d first_fs -o  first_fs.jffs2</span><br></pre></td></tr></table></figure><h2 id="搭建NFS文件系统"><a href="#搭建NFS文件系统" class="headerlink" title="搭建NFS文件系统"></a>搭建NFS文件系统</h2><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1 安装nfs文件系统</span><br><span class="line">sudo apt-get install nfs-kernel-server</span><br><span class="line">sudo vi &#x2F;etc&#x2F;exports 添加：</span><br><span class="line">&#x2F;work&#x2F;nfs_root&#x2F;first_fs  192.168.3*(rw,sync,no_subtree_check)</span><br><span class="line"></span><br><span class="line">sudo service portmap restart</span><br><span class="line">sudo service nfs-kernel-server restart</span><br><span class="line"></span><br><span class="line">2 虚拟机允许：</span><br><span class="line">sudo vi &#x2F;etc&#x2F;exports</span><br><span class="line">添加网络文件系统目录</span><br><span class="line"></span><br><span class="line">3 本地挂载</span><br><span class="line">sudo mount -t nfs -o nolock 192.168.3.61:&#x2F;work&#x2F;nfs_root&#x2F;first_fs &#x2F;mnt</span><br></pre></td></tr></table></figure><h3 id="单板"><a href="#单板" class="headerlink" title="单板"></a>单板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 手动挂载：</span><br><span class="line">mount -t nfs -o nolock 192.168.1.19:&#x2F;work&#x2F;nfs_root&#x2F;first_fs &#x2F;mnt</span><br><span class="line"></span><br><span class="line">2 直接从NFS启动：设置启动参数</span><br><span class="line">1 服务器IP</span><br><span class="line">2 设置自己的IP</span><br><span class="line"></span><br><span class="line">命令行格式：</span><br><span class="line">参考内核文档 ：Documentation&#x2F;filesystems&#x2F;nfs&#x2F;nfsroot.txt</span><br><span class="line"></span><br><span class="line">root&#x3D;&#x2F;dev&#x2F;nfs</span><br><span class="line">nfsroot&#x3D;[&lt;server-ip&gt;:]&lt;root-dir&gt;[,&lt;nfs-options&gt;] </span><br><span class="line">ip&#x3D;&lt;client-ip&gt;:&lt;server-ip&gt;:&lt;gw-ip&gt;:&lt;netmask&gt;::eth0:off</span><br><span class="line"></span><br><span class="line">gw-ip ：网关，随便写</span><br><span class="line">netmask ： 子网掩码  255.255.255.0</span><br></pre></td></tr></table></figure><h2 id="下载文件系统并测试"><a href="#下载文件系统并测试" class="headerlink" title="下载文件系统并测试"></a>下载文件系统并测试</h2><blockquote><p>至此,应该做的准备工作已经全部做完，现在验证内核是否能成功启动（实际移植顺序应该是边移植边验证）</p></blockquote><p>1 内核本身不支持yaffs2文件系统，因此yaffs2文件系统暂时不支持<br>2 网卡驱动还没有移植，因此NFS文件系统还不能用<br>3 因此，首先使用jffs2验证</p><ul><li>过程中遇到的一些错误及其处理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1 注意最小文件系统的lib库需要复制</span><br><span class="line">&#x2F;opt&#x2F;FriendlyARM&#x2F;toolschain&#x2F;4.4.3&#x2F;arm-none-linux-gnueabi&#x2F;lib</span><br><span class="line">里面的库文件</span><br><span class="line">arm-none-linux-gnueabi 是新的工具链</span><br><span class="line"></span><br><span class="line">2 配置内核增加EABI接口：</span><br><span class="line">make menuconfig</span><br><span class="line">Kernel Features ---&gt;</span><br><span class="line">        [*] Use the ARM EABI to compile the kernel</span><br><span class="line">        [*] Allow old ABI binaries to run with this kernel (EXPERIMENTAL)</span><br><span class="line"></span><br><span class="line">EABI简介：ABI 指的是应用程序二进制接口，类比及API，ABI是二进制级别的兼容。</span><br><span class="line">  E指的是Embedded，嵌入的</span><br><span class="line">好处：</span><br><span class="line">支持软件浮点和硬件实现浮点功能混用</span><br><span class="line">系统调用的效率更高</span><br><span class="line">后今后的工具更兼容</span><br><span class="line">软件浮点的情况下，EABI的软件浮点的效率要比OABI高很多</span><br><span class="line"></span><br><span class="line">3 无法创建节点错误：</span><br><span class="line">can&#39;t open &#x2F;dev&#x2F;ttySAC0: No such file or directory</span><br><span class="line">解决方法：</span><br><span class="line">make menuconfig 搜索 DEVTMPFS 把相关自动创建节点的配置项设置为Y即可</span><br></pre></td></tr></table></figure><ul><li>到现在为止，内核已经成功启动！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; # ls</span><br><span class="line">bin      etc      linuxrc  sbin     tmp</span><br><span class="line">dev      lib      proc     sys      usr</span><br><span class="line">&#x2F; #</span><br></pre></td></tr></table></figure><ul><li>接下来，</li></ul><blockquote><p>1 移植DM9000网卡驱动，挂载NFS文件系统<br>2 移植yaffs文件系统<br>3 移植LCD驱动</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux系统构建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux系统构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-哈希表</title>
    <link href="/2019/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C/"/>
    <url>/2019/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>哈希表，又称散列表，通过键-值对(key-indexed)的方式将数据存储在一片连续的内存中，注意哈希表的结构是数组结构（连续存储区域）</strong></p><blockquote><p>这里解释一下什么是健和值，健相当于数组中的值，值就是数组的下标index，哈希也就是把数组的值和数组的下标建立起了一定的关系，一般是通过值直接确定下标。    </p></blockquote><ul><li>那么哈希表是用来做什么的呢？      </li><li>答：最适合解决的问题是   <strong>查找与给定值相等的记录</strong>，并且可以*<em>快速插入 *</em></li></ul><p>也就是说，我可以通过我知道的这个值，快速的确定这个数组里面有没有这个值，而且这个速度是比二分法查找等算法快得多的，它的算法复杂度一直为O(1).</p><ul><li>那么是怎么通过数组链的值（健）找到对应的数组下标（值）的呢?</li><li>答：健和值之间有一个转换函数，叫做<strong>哈希函数</strong>或者叫<strong>散列函数</strong>，index = F(key)，输入key,即可算出key在<strong>散列表</strong>（哈希表）中的索引</li></ul><p>散列表查找步骤：</p><ul><li>存储时，通过哈希函数计算散列地址，并按照此散列地址记录   </li><li>查找记录时，通过<strong>同样的散列函数</strong>计算散列地址</li></ul><blockquote><p>哈希是一种存储方法，也是一种查找方法</p></blockquote><p>哈希表查找需要注意两个问题：</p><ul><li><p>1 散列函数的选取，有很多种选取的方法，本文的例子是最常用的<strong>除留余数法</strong>，<strong>index = key % p (p &lt;= HASHSIZE)</strong>,p的取值等于或小于哈希表的长度。<br>一个好的哈希函数，可以使得不同的数据会产生更多不同的索引，便于存储</p></li><li><p>2 如果不同的数据产生了相同的索引，那就需要采用新的办法来处理这个问题，一般是有三种方法      </p></li></ul><p><strong>开放定址法</strong>，即<strong>f`(key) = (f(key)+d) % HASHSIZE</strong>，哈希函数得到的数据索引中已经有值的时候，对这个addr进行上述操作，d取值为1…(HASHSIZE-1)<br><strong>再散列函数</strong>，<strong>f(key)=RH(key)(1=1 ,2,…,k)</strong>,RH为不同的散列函数<br><strong>链地址法</strong>，在当前的位置增加一个链表节点，存储相同索引的不同数据即可</p><ul><li>散列表的结构，elem是一个动态数组的首地址，count是数据个数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define HASHSIZE 12</span><br><span class="line">#define NO_DATA -12345</span><br><span class="line">typedef struct HashTable</span><br><span class="line">&#123;</span><br><span class="line">int *elem;</span><br><span class="line">int count;</span><br><span class="line">&#125;HashTable,*HashTable_ptr;&#x2F;&#x2F; 散列表首地址 + 散列表数据个数</span><br></pre></td></tr></table></figure><ul><li>初始化散列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 初始化散列表 *&#x2F;</span><br><span class="line">void init_HashTable(HashTable_ptr H)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">H-&gt;elem &#x3D; malloc(HASHSIZE * sizeof(int));</span><br><span class="line">for(i&#x3D;0;i&lt;HASHSIZE;i++)</span><br><span class="line">&#123;</span><br><span class="line">H-&gt;elem[i] &#x3D; NO_DATA;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入值到散列表,就是上述的第一步操作，按照散列函数的方式将值插入到散列表中，对于冲突问题，这里采取的是开放定址法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 插入key到散列表 *&#x2F;</span><br><span class="line">void inset_HashTable(HashTable_ptr H,int key)</span><br><span class="line">&#123;</span><br><span class="line">int addr &#x3D; HASH(key);</span><br><span class="line">while(H-&gt;elem[addr] !&#x3D; NO_DATA)&#x2F;&#x2F; 如果这一项有值了，往后存储</span><br><span class="line">&#123;</span><br><span class="line">addr &#x3D; (addr+1) % HASHSIZE;</span><br><span class="line">&#x2F;&#x2F; 开放定址法 : 以HASH函数得到的索引为key,产生新的索引</span><br><span class="line">&#125;</span><br><span class="line">H-&gt;elem[addr] &#x3D; key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查找数据的索引，按照相同的散列函数，得到散列表的索引，如果开放定址法的输出又回到了最初的值，表明散列表的没有这个需要查找的值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 查找关键字的地址 *&#x2F;</span><br><span class="line">int search_HashTable(HashTable_ptr H,int key)</span><br><span class="line">&#123;</span><br><span class="line">int addr &#x3D; HASH(key);</span><br><span class="line">while(H-&gt;elem[addr] !&#x3D; key)</span><br><span class="line">&#123;</span><br><span class="line">addr &#x3D; (addr+1) % HASHSIZE;&#x2F;&#x2F; 同样的方法查找</span><br><span class="line">if(addr &#x3D;&#x3D; HASH(key))&#x2F;&#x2F; 查找回到原点，说明数据不存在</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;no data \r\n&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int a[] &#x3D; &#123;12,67,56,16,25,37,22,29,15,47,48,34&#125;;</span><br><span class="line"></span><br><span class="line">HashTable hash;</span><br><span class="line">HashTable_ptr H &#x3D; &amp;hash;</span><br><span class="line">init_HashTable(H);</span><br><span class="line"></span><br><span class="line">for(i&#x3D;0;i&lt;HASHSIZE;i++)</span><br><span class="line">&#123;</span><br><span class="line">inset_HashTable(H,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;插入之后的哈希表为：&quot;);</span><br><span class="line">for(i&#x3D;0;i&lt;HASHSIZE;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,H-&gt;elem[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;搜索到2的地址为: %d \r\n&quot;,search_HashTable(H,2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于查找类的题，别再盲目的遍历啦，可以先创建一个散列表再进行查找。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-队列</title>
    <link href="/2019/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    <url>/2019/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>队列是只允许在一端进行插入操作，另一端进行删除操作的线性表</strong>    </p><ul><li>队列是一种<strong>先进先出（First In First Out）</strong>结构，简称FIFO，允许插入的一端成为对尾，允许删除的一端成为队头，可以类比于实际生活中的队列。</li></ul><p>本文介绍两种队列的存储结构的实现，分别是连续存储结构和链式存储结构，连续存储结构一般又称为环形缓冲区。以下的代码均在ubuntu16.04上运行，测试过。</p><h2 id="一-环形缓冲区"><a href="#一-环形缓冲区" class="headerlink" title="一 环形缓冲区"></a>一 环形缓冲区</h2><p><strong>队列的连续存储结构通过数组实现，队头删除数据之后，对尾添加的数据在超过数组长度时，需要插入数组前部（队头被删除的数据位置），这样，数组首尾相连，形成一个环形数组</strong></p><ul><li>队列的存储结构如下，一个数组，一个指向队头的数组index，front，一个指向对尾的index,rear，最后一个是队列中的数据个数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_SIZE 10</span><br><span class="line">typedef struct SqQueue</span><br><span class="line">&#123;</span><br><span class="line">int data[MAX_SIZE];&#x2F;&#x2F; 存储数据的数组</span><br><span class="line">int front;&#x2F;&#x2F; 头指针</span><br><span class="line">int rear;&#x2F;&#x2F; 尾指针</span><br><span class="line">int flag;&#x2F;&#x2F; 队列中数据的个数</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><ul><li>初始化一个环形缓冲区,这个环形缓冲区的位置分配在堆中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void init_queue(SqQueue **S)</span><br><span class="line">&#123;</span><br><span class="line">*S &#x3D; malloc(sizeof(struct SqQueue));&#x2F;&#x2F; 动态内存分配</span><br><span class="line">(*S)-&gt;front &#x3D; 0;</span><br><span class="line">(*S)-&gt;rear  &#x3D; 0;</span><br><span class="line">(*S)-&gt;flag  &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对尾添加数据,如果队列中的数据超过了最大值，说明缓冲区已满，否则在rear位置插入一个数据，并将rear+1,在rear到达数组尾部时，让rear置为0，即指向数组首地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void addQueue(SqQueue *S,int data)   &#x2F;&#x2F; 队尾添加数据</span><br><span class="line">&#123;</span><br><span class="line">if(S-&gt;flag &gt;&#x3D; MAX_SIZE)</span><br><span class="line">return;</span><br><span class="line">S-&gt;data[S-&gt;rear] &#x3D; data;</span><br><span class="line">S-&gt;rear ++;</span><br><span class="line">if(S-&gt;rear &#x3D;&#x3D; MAX_SIZE) S-&gt;rear &#x3D; 0;</span><br><span class="line">S-&gt;flag++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>队头删除数据,也就是让队头index+1，并且让flag减一即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void delQueue(SqQueue *S)    &#x2F;&#x2F; 队头删除数据</span><br><span class="line">&#123;</span><br><span class="line">if(S-&gt;flag &lt;&#x3D; 0) </span><br><span class="line">return;</span><br><span class="line">S-&gt;front ++;</span><br><span class="line">if(S-&gt;front &#x3D;&#x3D; MAX_SIZE) S-&gt;front &#x3D; 0;</span><br><span class="line">S-&gt;flag--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回队列中的元素个数,也就是返回flag的数值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int queueLength(SqQueue *S)</span><br><span class="line">&#123;</span><br><span class="line">return S-&gt;flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历环形缓冲区，打印出所有的数值,从队头打印到对尾，如果超过数组范围，仍然是回到数组首位</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void printall(SqQueue *S) </span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int count &#x3D; S-&gt;front;</span><br><span class="line">if(S-&gt;flag &#x3D;&#x3D; 0) return;</span><br><span class="line">for(i&#x3D;0;i&lt;S-&gt;flag;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,S-&gt;data[count]);</span><br><span class="line">count++;</span><br><span class="line">if(count &gt;&#x3D; MAX_SIZE)count &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-链式队列"><a href="#二-链式队列" class="headerlink" title="二 链式队列"></a>二 链式队列</h2><p><strong>链式队列是一种带有限制的链表，优点在于没有长度的限制</strong></p><ul><li>链式队列的存储结构,封装了一个单链表，并且加入了队头指针，对尾指针和队列的长度。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct QNode</span><br><span class="line">&#123;</span><br><span class="line">int data;</span><br><span class="line">struct QNode *next;</span><br><span class="line">&#125;QNode,*QNodePtr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct LinkQueue</span><br><span class="line">&#123;</span><br><span class="line">QNodePtr front;&#x2F;&#x2F; 表头，删除数据</span><br><span class="line">QNodePtr rear;&#x2F;&#x2F; 表尾，添加数据</span><br><span class="line">int count;&#x2F;&#x2F; 队列长度</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><ul><li>在队尾插入数据，也就是在链表的尾部增加节点，先把旧队尾rear的next指向新增的节点，再把rear更新为这个新增的节点。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void add_LinkQueue(LinkQueue *Q,int data) &#x2F;&#x2F; 队尾增加节点</span><br><span class="line">&#123;</span><br><span class="line">QNodePtr s &#x3D; malloc(sizeof(struct QNode));</span><br><span class="line">s-&gt;data &#x3D; data;</span><br><span class="line">s-&gt;next &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">Q-&gt;count++;</span><br><span class="line">Q-&gt;rear-&gt;next &#x3D; s;     &#x2F;&#x2F; 先前节点的next指向s </span><br><span class="line"></span><br><span class="line">Q-&gt;rear &#x3D; s;&#x2F;&#x2F; 现在的节点更新为s</span><br><span class="line">Q-&gt;rear-&gt;next &#x3D; NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在队头删除数据,注意这里删除的是首节点的下一个节点，并且把首节点的next指向下下个节点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void del_LinkQueue(LinkQueue *Q)&#x2F;&#x2F;删除队头的下一个节点（队头不删）</span><br><span class="line">&#123;</span><br><span class="line">QNodePtr p;</span><br><span class="line">if(Q-&gt;count &#x3D;&#x3D; 0) return;</span><br><span class="line"></span><br><span class="line">p &#x3D; Q-&gt;front-&gt;next;</span><br><span class="line">Q-&gt;front-&gt;next &#x3D; p-&gt;next;</span><br><span class="line"></span><br><span class="line">if(Q-&gt;rear &#x3D;&#x3D; p) Q-&gt;rear &#x3D; Q-&gt;front; &#x2F;&#x2F; 如果删除的恰好是尾结点</span><br><span class="line">Q-&gt;count --;</span><br><span class="line">free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历整个队列,从头结点的下一个节点一直输出至队尾节点。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void printall(LinkQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">QNodePtr p &#x3D; Q-&gt;front; </span><br><span class="line"></span><br><span class="line">printf(&quot;count &#x3D; %d\r\n&quot;,Q-&gt;count);</span><br><span class="line"></span><br><span class="line">if(Q-&gt;count &#x3D;&#x3D; 0) return;</span><br><span class="line"></span><br><span class="line">for(i&#x3D;0;i&lt; Q-&gt;count;i++)&#123;</span><br><span class="line">printf(&quot;%d\r\n&quot;,p-&gt;next-&gt;data);</span><br><span class="line">p &#x3D; p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>队列还有其他别的操作，如插入，删除某个特定的节点等，但是这都是建立在对队列这个数据结构非常了解的基础上的，只要真正了解了这个数据结构，就很容易实现。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-二叉树</title>
    <link href="/2019/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2019/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><strong>二叉树是一种非线性数据结构，本文实现的是二叉树的三种遍历方法，以及一种二叉搜索树，即左孩子节点的值小于根节点的值小于右孩子节点的值</strong></p><blockquote><p>对二叉树不了解的需要先了解二叉树，本文说的比较简练实用</p></blockquote><ul><li>二叉树的结构,二叉树的链式结构非常简单，即一个数据节点，加上两个孩子节点。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BitNode</span><br><span class="line">&#123;</span><br><span class="line">int data;</span><br><span class="line">struct BitNode *left_child,*right_child;</span><br><span class="line"></span><br><span class="line">&#125;BitNode,*BitNode_ptr;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历方法总结起来一共分为三步：     </p><ul><li>按照顺序访问节点，前序，中序，后序，分别对应<br>1 从根节点到左右孩子<br>2 左孩子到根节点再到右节点<br>3 左右孩子节点再到根节点    </li><li>有孩子节点的优先遍历孩子节点      </li><li>访问到根节点就输出数据    <blockquote><p>把握住这三步，对于二叉树的遍历基本没有问题,对于前中后序遍历步骤不用记，前就是从上到下，后就是从下到上，中就是下到上再到下</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 前序遍历 *&#x2F;</span><br><span class="line">&#x2F;* 根-&gt;左-&gt;右 *&#x2F;</span><br><span class="line">void preOrder(BitNode_ptr T)</span><br><span class="line">&#123;</span><br><span class="line">if(T &#x3D;&#x3D; NULL)</span><br><span class="line">return;</span><br><span class="line">printf(&quot;%d &quot;,T-&gt;data);  &#x2F;&#x2F; 访问根节点</span><br><span class="line">preOrder(T-&gt;left_child); &#x2F;&#x2F; 访问左节点</span><br><span class="line">preOrder(T-&gt;right_child);&#x2F;&#x2F; 访问右节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 中序遍历 *&#x2F;</span><br><span class="line">&#x2F;* 左-&gt;根-&gt;右 *&#x2F;</span><br><span class="line">void InOrder(BitNode_ptr T)</span><br><span class="line">&#123;</span><br><span class="line">if(T &#x3D;&#x3D; NULL)</span><br><span class="line">return;</span><br><span class="line">InOrder(T-&gt;left_child);   &#x2F;* 访问左节点 *&#x2F;</span><br><span class="line">&#x2F;* 一直遍历到最后的左节点才开始返回打印数据 *&#x2F;</span><br><span class="line">printf(&quot;%d &quot;,T-&gt;data);   &#x2F;* 访问根节点 *&#x2F;</span><br><span class="line">InOrder(T-&gt;right_child);   &#x2F;* 访问右节点 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 后序遍历 *&#x2F;</span><br><span class="line">&#x2F;* 左-&gt;右-&gt;根  &#x2F; 右-&gt;左-&gt;根 *&#x2F;</span><br><span class="line">void PostOrder(BitNode_ptr T)</span><br><span class="line">&#123;</span><br><span class="line">if(T &#x3D;&#x3D; NULL)</span><br><span class="line">return;</span><br><span class="line">PostOrder(T-&gt;left_child);  &#x2F;* 访问左节点 *&#x2F;</span><br><span class="line">PostOrder(T-&gt;right_child);    &#x2F;* 访问右节点 *&#x2F;</span><br><span class="line">printf(&quot;%d &quot;,T-&gt;data);    &#x2F;* 访问根节点 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><blockquote><p>对于二叉树的掌握需要对递归有一定的理解</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 1 创建一个二叉树节点 *&#x2F;</span><br><span class="line">BitNode_ptr create_bitnode(int data)</span><br><span class="line">&#123;</span><br><span class="line">BitNode_ptr t &#x3D; malloc(sizeof(struct BitNode));</span><br><span class="line">t-&gt;left_child &#x3D; NULL;</span><br><span class="line">t-&gt;right_child &#x3D; NULL;</span><br><span class="line">t-&gt;data &#x3D; data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 2 将二叉树节点插入到二叉树中（以二叉搜索树的方式） *&#x2F;</span><br><span class="line">void add_bitree(BitNode_ptr T,BitNode_ptr t)</span><br><span class="line">&#123;</span><br><span class="line">if(T &#x3D;&#x3D; NULL)  &#x2F;&#x2F; 根节点</span><br><span class="line">&#123;</span><br><span class="line">T &#x3D; t;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(t-&gt;data &lt; T-&gt;data)&#x2F;&#x2F; 小于 放在左节点，有孩子节点先判断孩子节点</span><br><span class="line">&#123;</span><br><span class="line">if(T-&gt;left_child !&#x3D; NULL)</span><br><span class="line">add_bitree(T-&gt;left_child,t);</span><br><span class="line">else</span><br><span class="line">T-&gt;left_child &#x3D; t;</span><br><span class="line">&#125;</span><br><span class="line">else  &#x2F;&#x2F; 大于等于  放在右节点，有孩子节点先判断孩子节点</span><br><span class="line">&#123;</span><br><span class="line">if(T-&gt;right_child !&#x3D; NULL)</span><br><span class="line">add_bitree(T-&gt;right_child,t);</span><br><span class="line">else </span><br><span class="line">T-&gt;right_child &#x3D; t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 返回二叉树的深度 *&#x2F;</span><br><span class="line">int bit_tree_depth(BitNode_ptr T)</span><br><span class="line">&#123;</span><br><span class="line">static int depth &#x3D; 0;</span><br><span class="line">int left_depth &#x3D; 0,right_depth &#x3D; 0;</span><br><span class="line"></span><br><span class="line">if(T &#x3D;&#x3D; NULL)</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">left_depth  &#x3D; bit_tree_depth(T-&gt;left_child);</span><br><span class="line">right_depth &#x3D; bit_tree_depth(T-&gt;right_child);</span><br><span class="line"></span><br><span class="line">depth &#x3D; right_depth&gt;left_depth ? right_depth : left_depth;</span><br><span class="line"></span><br><span class="line">return depth + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;* 创建根节点 *&#x2F;</span><br><span class="line">T &#x3D; create_bitnode(10);</span><br><span class="line">BitNode_ptr t;</span><br><span class="line"></span><br><span class="line">&#x2F;* 创建各个节点 *&#x2F;</span><br><span class="line">t &#x3D; create_bitnode(9);</span><br><span class="line">add_bitree(T,t);</span><br><span class="line"></span><br><span class="line">    t &#x3D; create_bitnode(20);</span><br><span class="line">add_bitree(T,t);</span><br><span class="line"></span><br><span class="line">t &#x3D; create_bitnode(15);</span><br><span class="line">add_bitree(T,t);</span><br><span class="line"></span><br><span class="line">t &#x3D; create_bitnode(35);</span><br><span class="line">add_bitree(T,t);</span><br><span class="line"></span><br><span class="line">&#x2F;* 三种遍历方式 *&#x2F;</span><br><span class="line">preOrder(T);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">InOrder(T);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">PostOrder(T);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;* 返回二叉树的深度 *&#x2F;</span><br><span class="line">    printf(&quot;depth is %d\r\n &quot;,bit_tree_depth(T));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>还有一些高级的二叉树，如二叉平衡树，红黑树等，如果需要掌握这些高级的数据结构，还是要下一定的功夫的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-栈</title>
    <link href="/2019/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <url>/2019/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p><strong>栈与队列恰好相反，栈是一种后进先出的结构（Last In First Out）LIFO,你可以想像成一个容器，最先倒进去的最后倒出来</strong>   </p><p>本文介绍的是链式栈结构，在数据结构中几乎用的都是这种存储形式，这里要把数据结构的栈和内存的栈空间区别开，这里的栈是一种数据结构，内存的栈是指内存的存取方式类似于栈这种形式，因此取名栈空间。</p><ul><li>栈的结构,这里也是封装了一个链表，在此基础上加了一个栈顶指针，和栈内的数据个数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct StackNode</span><br><span class="line">&#123;</span><br><span class="line">int data;</span><br><span class="line">struct StackNode *next;</span><br><span class="line">&#125;StackNode, *LinkStackPtr;</span><br><span class="line"></span><br><span class="line">typedef struct LinkStack</span><br><span class="line">&#123;</span><br><span class="line">LinkStackPtr top;</span><br><span class="line">int count;</span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure><ul><li>初始化一个栈,此时栈内部的链表没有任何节点，也就是栈内没有任何数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void init_stack(LinkStack *S)</span><br><span class="line">&#123;</span><br><span class="line">S-&gt;top &#x3D; NULL;</span><br><span class="line">S-&gt;count &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>push操作，入栈操作<br>这里需要注意的是，这里不是按照单链表的方式连接到上一个节点的尾部，这里相当于单链表反向操作，即是把新加入的节点的next指向链表表头的位置（栈顶节点top），并且把top更新为新插入的节点<br>为什么这么做？原因在于删除的节点为链表最新加入的节点，这样便于删除这个节点，而不用遍历整个链表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int push(LinkStack *S,int data)</span><br><span class="line">&#123;</span><br><span class="line">LinkStackPtr s &#x3D; (LinkStackPtr)malloc(sizeof(struct StackNode));</span><br><span class="line">s-&gt;data &#x3D; data;</span><br><span class="line">s-&gt;next &#x3D; S-&gt;top;</span><br><span class="line">&#x2F;* 逆向的链表 *&#x2F;</span><br><span class="line">S-&gt;top &#x3D; s;</span><br><span class="line">S-&gt;count ++;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pop操作，出栈操作，就是把栈顶指针top更新为top-&gt;next,并把top节点free掉</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int pop(LinkStack *S, int *p_dat)</span><br><span class="line">&#123;</span><br><span class="line">LinkStackPtr p;</span><br><span class="line">if(S &#x3D;&#x3D; NULL || S-&gt;top &#x3D;&#x3D; NULL)</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">if(p_dat !&#x3D; NULL)</span><br><span class="line">*p_dat &#x3D; S-&gt;top-&gt;data;</span><br><span class="line"></span><br><span class="line">p &#x3D; S-&gt;top-&gt;next;</span><br><span class="line">free(S-&gt;top);</span><br><span class="line">S-&gt;top &#x3D; p;</span><br><span class="line">S-&gt;count--;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历整个栈,从栈顶一直遍历到栈底</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int print_all(LinkStack *S)</span><br><span class="line">&#123;</span><br><span class="line">if(S &#x3D;&#x3D; NULL || S-&gt;top &#x3D;&#x3D; NULL)</span><br><span class="line">return 0;</span><br><span class="line">    do&#123;</span><br><span class="line">printf(&quot;data is %d \n&quot;,S-&gt;top-&gt;data);</span><br><span class="line">S-&gt;top &#x3D; S-&gt;top-&gt;next;</span><br><span class="line">   &#125;while(S-&gt;top !&#x3D; NULL);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意栈结构中的链表操作有所不同</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++脑图</title>
    <link href="/2019/06/01/C++%E8%84%91%E5%9B%BE/"/>
    <url>/2019/06/01/C++%E8%84%91%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/C++%E8%84%91%E5%9B%BE/c++.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件操作</title>
    <link href="/2019/05/18/Linux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2019/05/18/Linux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p><strong>目录结构</strong>  </p><blockquote><p>1  底层系统调用<br>2  标准IO库<br>3  格式化输入输出<br>4  带缓冲的IO和不带缓冲的IO<br>5  目录操作<br>6  文件和目录的维护<br>7  proc文件系统<br>8  锁文件<br>9  文件锁  </p></blockquote><p>想必在此之前，你已经听说过这么一句话，<strong>在linux中，一切（几乎一切）都是文件</strong>，设置硬件设备也被映射为文件，Linux中比较重要的设备文件有3个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dev&#x2F;console：系统控制台</span><br><span class="line">&#x2F;dev&#x2F;tty：终端控制，由系统自动运行的进程和脚本没有控制终端，所以它们不能打开&#x2F;dev&#x2F;tty</span><br><span class="line">&#x2F;dev&#x2F;null：空设备，在cp命令里把它用作复制空文件的源文件，例如：</span><br><span class="line">cp &#x2F;dev&#x2F;null empty_file</span><br></pre></td></tr></table></figure><h2 id="一-底层系统调用"><a href="#一-底层系统调用" class="headerlink" title="一 底层系统调用"></a>一 底层系统调用</h2><p><strong>文件操作的底层系统调用常用的有以下几个：</strong>    </p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>open</td><td>打开文件或设备</td></tr><tr><td>read</td><td>从打开的文件或者设备里面读数据</td></tr><tr><td>write</td><td>向文件或设备里写数据</td></tr><tr><td>close</td><td>关闭文件或设备</td></tr><tr><td>lseek</td><td>设置读写指针</td></tr><tr><td>fstat/stat/lstat</td><td>获取文件相关信息</td></tr><tr><td>mmap/msync</td><td>内存映射</td></tr></tbody></table><p>当一个进程（process）开始运行时，一般会有3个已经打开的文件描述符：    </p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>标准输入</td></tr><tr><td>1</td><td>标准输出</td></tr><tr><td>2</td><td>标准错误</td></tr></tbody></table><p><strong>open</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int open(const char *path,int oflags);</span><br><span class="line">int open(const char *path,int oflags,mode_t mode);</span><br></pre></td></tr></table></figure><p>— 参数解释 —</p><ul><li>path:文件路径和文件名</li><li>oflags:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">O_RDONLY:以只读方式打开</span><br><span class="line">O_WRONLY:以只写方式打开</span><br><span class="line">O_RDWR:以读写方式打开</span><br><span class="line">可选的组合模式:</span><br><span class="line">O_APPEND:把写入的数据追加在文件的末尾</span><br><span class="line">O_TRUNC:把文件的长度设置为0，丢弃已有的内容</span><br><span class="line">O_CREAT:如果需要，则创建文件，比较常用</span><br><span class="line">O_EXCL:与O_CREAT一起使用，使用这个模式可以方式两个进程同时创建出一个文件，如果文件已经存在，则创建失败。</span><br></pre></td></tr></table></figure><ul><li>mode:<br>如果你使用O_CREAT标志的open来创建文件时，你必须使用三个参数的open函数。<br>第三个参数是文件的读/写/执行权限，一般是以0开头的三个八进制数，每个八进制数都是由1/2/4中的一个或几个进行相加得到的。<br>这三个八进制中，第一个表述属主的权限，第二个表示组的权限，第三个表示其他用户的权限。</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>允许任何权限</td></tr><tr><td>1</td><td>禁止执行权限</td></tr><tr><td>2</td><td>禁止写权限</td></tr><tr><td>4</td><td>禁止执行权限</td></tr></tbody></table><ul><li>返回值：<br>open调用成功时会返回一个新的文件描述符（非负整数），在失败时返回-1。<br>值得注意的是，返回的新的文件描述符总是未使用描述符的最小值，这个特征非常有用，后面的文章会提到。</li></ul><p><strong>read</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t read(int fildes,void *buf,size_t nbytes);</span><br></pre></td></tr></table></figure><p>—参数解释—</p><ul><li>filedes: 文件描述符</li><li>buf: 存放数据的缓冲区</li><li>nbytes: 读取的字节数</li><li>返回值：返回实际读取的字节数，这可能会小于请求的字节数。如果返回的是0，表示已经到达文件尾，未读入任何数据，如果返回的是-1，表示read调用出现了错误。</li></ul><p><strong>write</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t write(int fildes,const void *buf,size_t nbytes);</span><br></pre></td></tr></table></figure><p>—参数解释—</p><ul><li>filedes: 文件描述符</li><li>buf: 要写入的缓冲区</li><li>nbytes: 准备写入的字节数，写入的是缓冲区的前nbytes个字节</li><li>返回值：返回实际写入的字节数，可能会小于nbytes，如果返回0，表示未写入任何数据，返回-1，表示发生错误。</li></ul><p><strong>close</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int close(int fildes);</span><br></pre></td></tr></table></figure><ul><li>终止文件描述符与其对应的文件之间的关系</li><li>释放文件描述符并使其能够重新使用</li><li>成功返回0，失败返回-1</li></ul><p><strong>lseek</strong></p><blockquote><p>lseek用于对文件描述符fildes的读写指针进行设置。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_t lseek(int fileds,off_t offset,int whence);</span><br></pre></td></tr></table></figure><p>—参数解释—</p><ul><li>off_t offset：off_t是一个整数类型，offset表示偏移值</li><li>whence   </li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>SEEK_SET</td><td>offset是一个绝对位置</td></tr><tr><td>SEEK_CUR</td><td>offset是一个相对于当前位置的相对位置</td></tr><tr><td>SEEK_END</td><td>offset是一个相对于文件尾的相对位置</td></tr></tbody></table><ul><li>返回值<br>返回从文件头到文件指针的字节偏移值，失败时返回-1.</li></ul><p><strong>fstat/stat/lstat</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fstat(int fildes,struct stat *buf);</span><br><span class="line">int stat(const char *path,struct stat *buf);</span><br><span class="line">int lstat(const char *path,struct stat *buf);</span><br></pre></td></tr></table></figure><ul><li>fstat 通过文件描述符返回相关的文件状态信息</li><li>stat/lstat 是通过文件名查到文件的状态信息</li><li>stat/lstat的区别：当查到的文件名是一个符号链接时，lstat返回的是该符号链接本身的信息，stat返回的是该链接指向的文件的信息。</li></ul><p><strong>mmap/msync</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);</span><br></pre></td></tr></table></figure><p>函数功能</p><ul><li>mmap函数创建一段指向内存区域的指针，该内存区域与可以通过一个文件描述符访问的文件的内容相关联。</li><li>简单的说，就是把二进制文件的内容放在内存里，读写文件就可以使用指针操作，方便对某个字节进行读写操作。</li></ul><p>函数参数</p><ul><li>addr ： 分配的内存地址，一般设置为NULL,即由系统进行分配</li><li>len ： 需要分配的长度</li><li>prot: 设置内存访问的权限，有PORT_READ读/PORT_WRITE写/PORE_EXEC执行，按位OR操作</li><li>fildes ： 已经打开的文件描述符</li><li>off：内存访问的文件中数据的起始偏移地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int msync(void *addr,size_t len,int flags);</span><br></pre></td></tr></table></figure><p>函数功能：把映射的内存段写回到被映射的文件中</p><ul><li>flasgs：执行修改的具体方式</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>MS_ASYNC</td><td>采用异步写方式</td></tr><tr><td>MS_SYNC</td><td>采用同步写方式</td></tr><tr><td>MS_INVALIDATE</td><td>从文件中读回数据</td></tr></tbody></table><h2 id="二-标准IO库"><a href="#二-标准IO库" class="headerlink" title="二 标准IO库"></a>二 标准IO库</h2><p><strong>IO标准库提供的读写函数主要有以下几个</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>fopen</td><td>打开文件</td></tr><tr><td>fread</td><td>读取文件数据</td></tr><tr><td>fwrite</td><td>向文件写数据</td></tr><tr><td>flose</td><td>关闭文件流</td></tr><tr><td>fflush</td><td>写出缓冲区中所有的数据</td></tr><tr><td>fseek</td><td>移动读写指针</td></tr><tr><td>fgetc/getc/getchar</td><td>从文件流中获取一个字节</td></tr><tr><td>fputc/putc/putchar</td><td>输出一个字节到文件流中</td></tr><tr><td>fgets/gets</td><td>从文件流中获取字符串</td></tr></tbody></table><p>标注IO库stdio为底层I/O系统调用提供了一个通用的接口，还提供了许多复杂的函数用于格式化输出和扫面输入，它还负责满足设备的缓冲需求。<br>在标准IO库中，与文件描述符对应的是流（stream）,它是指向结构<strong>FILE</strong>的指针。<br>同样，在启动程序时，由3个流时自动打开的，分别是   </p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>stdin</td><td>标准输入</td></tr><tr><td>stdout</td><td>标准输出</td></tr><tr><td>stderr</td><td>标准错误</td></tr></tbody></table><p><strong>fopen</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *fopen(const char *filename,const char *mode);</span><br></pre></td></tr></table></figure><p>— 参数解释 —</p><ul><li>filename:指定的文件</li><li>moed:指定的打开方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;r&quot; &#x2F; &quot;rb&quot; :只读</span><br><span class="line">&quot;w&quot; &#x2F; &quot;wb&quot; : 只写,把文件长度截短为零</span><br><span class="line">&quot;a&quot; &#x2F; &quot;ab&quot; : 只写，新内容追加在文件尾</span><br><span class="line">&quot;r+&quot;&#x2F;&quot;rb+&quot;&#x2F;&quot;r+b&quot; : 以更新方式打开，读&#x2F;写</span><br><span class="line">&quot;w+&quot;&#x2F;&quot;wb+&quot;&#x2F;&quot;w+b&quot; : 以更新方式打开,并把文件长度截短为0</span><br><span class="line">&quot;a+&quot;&#x2F;&quot;ab+&quot;&#x2F;&quot;a+b&quot; : 以更新方式打开,新内容追加在文件尾</span><br></pre></td></tr></table></figure><ul><li>返回值：<br>成功返回一个非空的FILE * 指针<br>失败返回NULL</li></ul><p><strong>fread</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t fread(void *ptr,size_t size,size_t nitems,FILE *stream);</span><br></pre></td></tr></table></figure><p>—参数解释—</p><ul><li>ptr : 数据存放的缓冲区</li><li>size: 每次读取的长度</li><li>nitems: 读取的次数</li><li>stream:文件流</li><li>返回值：放到缓冲区里面的数据块的个数，而不是字节数</li></ul><p><strong>fwrite</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t fwrite(const void *ptr,size_t size,size_t nitems,FILE *stream);</span><br></pre></td></tr></table></figure><p>—参数解释—</p><ul><li>ptr : 数据存放的缓冲区</li><li>size: 每次写入的长度</li><li>nitems: 写入的次数</li><li>stream:文件流</li><li>返回值：写入的个数</li></ul><p><strong>flose</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fclose(FILE *stream);</span><br></pre></td></tr></table></figure><ul><li>flose关闭文件流stream,使所有尚未写出的数据都写出，因为stdio会对数据进行缓冲，所以使用fclose是非常重要的。</li></ul><p><strong>fflush</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fflush(FILE *stream);</span><br></pre></td></tr></table></figure><ul><li>把文件流里面所有未写出的数据立刻写出，可以用这个函数来确保在试图读入一个用户响应之前，先向终端送出一个交互提示符。</li><li>flose()隐含执行了一次fflush函数</li></ul><p><strong>fseek</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fseek(FILE *stream,long int offset,int whence);</span><br></pre></td></tr></table></figure><p>offset和whence的含义与lseek一样，不一样的时fseek返回的是一个整数，0表示成功，-1表示失败。</p><p><strong>fgetc/getc/getchar</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fgetc(FILE stream);</span><br><span class="line">int getc(FILE *stream);</span><br><span class="line">int getchar();</span><br></pre></td></tr></table></figure><ul><li>fgetc从文件流里面取出下一个字节并把它作为字符返回，当到达文件尾部或者发生错误时返回<strong>EOF</strong>.</li><li>getc与fgetc的作用一样,但是它有可能被声明成一个宏（被ISO C声明为一个宏），所以它不可以作为函数指针，宏会需要更多的内存空间，但是有更高的执行效率。</li><li>getchar的作用相当于getc(stdin),从标准里读取下一个字符</li></ul><p><strong>fputc/putc/putchar</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fputc(int c,FILE *stream);</span><br><span class="line">int putc(int c,FILE *stream);</span><br><span class="line">int putchar(int c);</span><br></pre></td></tr></table></figure><p>类似于<code>fgetc/fget/getchar</code>之间的关系<br>注意，<strong>putchar和getchar都是把字符当作int类型而不是char类型来使用的，这就允许文件尾(EOF)标识取值-1</strong></p><p><strong>fgets/gets</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *fgets(char *s,int n,FILE *stream);</span><br><span class="line">char *gets(char *s);</span><br></pre></td></tr></table></figure><ul><li>fgets把读到的字符写到S所指向的字符串里，<strong>直到遇到换行符或者文件尾</strong>，也会把换行符接受到字符串里，<strong>并加上结尾字符\0</strong>，一次调用最多传输<strong>n-1</strong>个字符，因为最后一个字符必须是<strong>\0</strong><br>成功时，返回指向s的指针，失败时，返回一个空指针</li><li>gets类似于fgets，只不过它是从标准输入读取数据并<strong>丢弃换行符，并在结尾加上null字符</strong></li></ul><h2 id="三-格式化输入输出"><a href="#三-格式化输入输出" class="headerlink" title="三 格式化输入输出"></a>三 格式化输入输出</h2><h3 id="1-标准输出函数"><a href="#1-标准输出函数" class="headerlink" title="1 标准输出函数"></a>1 标准输出函数</h3><p><strong>printf/fprintf/sprintf</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int printf(const char *format,...);</span><br><span class="line">int sprintf(char *s,const char *format,...);</span><br><span class="line">int fprintf(FILE *stream,const char *format,...);</span><br></pre></td></tr></table></figure><ul><li>printf   把自己的输出送到标准输出</li><li>fprintf  把自己的输出送到一个指定的文件流##</li><li>sprintf  把自己的输出和一个结尾空字符写到字符串s里面</li></ul><p><strong>scanf/fscanf/sscanf</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int scanf(const char *format,...);</span><br><span class="line">int fscanf(FILE *stream,const char *format,..);</span><br><span class="line">int sscanf(const char *s,const char *format,...);</span><br></pre></td></tr></table></figure><ul><li>scanf 读入标准输入的值保存到对应的变量里去，这些变量的类型必须正确并且精确匹配格式字符串，斗则，内存数据会遭到破坏，使程序崩溃<br>使用%c控制符从输入中读取一个自读，它<strong>不会跳过起始的空白字符</strong><br>使用%s控制符来扫描字符串，它<strong>会跳过起始的空白字符</strong><br>返回值是成功读取的数据项个数<br>例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给定下面的输入行：</span><br><span class="line">hello, 1234, 5.678, X, string to the end of the line</span><br><span class="line">下面的scanf会正确读取4个数据项：</span><br><span class="line">char s[256];</span><br><span class="line">int n;</span><br><span class="line">float f;</span><br><span class="line">char c;</span><br><span class="line">scanf(&quot;Hello,%d,%g, %c, %[^\n]&quot;,&amp;n,&amp;f,&amp;c,s);</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 1 注意%c前面有空格，是为了匹配字符X之前的空格</span><br><span class="line"> * 2 %[^\n]: 表示遇到\n停止读取字符串</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><ul><li>fscanf  从文件流读取数据到对应项中</li><li>sscanf  从字符串读取数据到对应项中</li></ul><h2 id="四-带缓冲的IO与不带缓冲的IO"><a href="#四-带缓冲的IO与不带缓冲的IO" class="headerlink" title="四 带缓冲的IO与不带缓冲的IO"></a>四 带缓冲的IO与不带缓冲的IO</h2><p>底层系统调用提供的IO读写操作是不带缓存的IO<br>标准库stdio提供的IO读写操作是带缓存的IO</p><p>看下面两个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_t write(int fildes,const void *buf,size_t nbytes);</span><br><span class="line">size_t fwrite(const void *ptr,size_t size,size_t nitems,FILE *stream);</span><br></pre></td></tr></table></figure><p>在数据读入buff或者是ptr之前，都会先写到内核所设置的缓冲存储器中。<strong>如果存储器未满，则并不将其排入到输出队列，直到缓存写满或者内核需要重新使用此缓存时才将其排入输出队列，再进行实际的IO操作，这种技术叫延迟写</strong></p><p>标准IO在系统调用上多加了一个缓冲区，也因此引入了流的概念，FILE实际上包含了管理流所需要的所有信息：</p><ul><li>实际的IO文件描述符</li><li>指向流缓存的指针</li><li>缓存长度</li><li>当前在缓存中的字节数     </li></ul><p>标准IO提供三种缓存模式：</p><ul><li>全缓存，即填满IO缓存后才执行IO操作</li><li>行缓存，即输入输出遇到新行符或者缓存满时，才执行真正的IO操作，stdin,stdout通常是行缓存，当stdout被重定向到一个具体的文件时，那么它是全缓存的</li><li>无缓存，相当于read write，stderr时不带任何缓存的</li></ul><p>带缓存的IO虽然数据复制了两次，但是无需考虑缓存以及最佳IO长度的选择，因此它不比read/write慢多少</p><p>如何直观的看到标准IO库的缓存效果，看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char buff[1024];</span><br><span class="line">printf(&quot;This Line Should be Cached...&quot;);</span><br><span class="line">sleep(3);    &#x2F;&#x2F;这时候在终端上是看不到任何输出</span><br><span class="line">printf(&quot;\nThis Line Should be Cached Again&quot;);  &#x2F;&#x2F;这时候可以看到第一个printf的输出，因为被换行符刷新了</span><br><span class="line">sleep(3);  </span><br><span class="line">printf(&quot;This Line Should Not be Cached Again\n&quot;); &#x2F;&#x2F;这时候可以看到第二个和第三个printf的输出，因为被结尾的\n刷新</span><br><span class="line">&#x2F;&#x2F;fgets(buff,20,stdin);&#x2F;&#x2F; buff中带&#39;\n&#39;</span><br><span class="line">gets(buff);&#x2F;&#x2F; buff中不带&#39;\n&#39;</span><br><span class="line">printf(&quot;%s &quot;,buff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-目录操作"><a href="#五-目录操作" class="headerlink" title="五 目录操作"></a>五 目录操作</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>opendir</td><td>打开目录流</td></tr><tr><td>readdir</td><td>扫描目录</td></tr><tr><td>telldir</td><td>返回目录当前位置</td></tr><tr><td>seekdir</td><td>设置目录流指针</td></tr><tr><td>closedir</td><td>关闭一个目录流</td></tr></tbody></table><p>Linux中，与目录操作有关的头文件在diret.h中，它们使用一个名为DIR的结构体作为目录操作的基础，被称为<strong>目录流</strong>的指针指向这个结构体。</p><p><strong>opendir</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIR *opendir(const char *name);</span><br></pre></td></tr></table></figure><ul><li>打开并建立一个目录流，如果失败，则返回一个空指针</li></ul><p><strong>readdir</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct dirent *readdir(DIR *dirp);</span><br></pre></td></tr></table></figure><ul><li>readdir返回一个指针，指向目录流的下一个目录项的有关资料，如果发生错误或者到达目录为，则返回NULL</li><li>struct dirent 包含的内容：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ino_t d_ino: 文件的inode节点号</span><br><span class="line">char d_name[]: 文件的名字</span><br></pre></td></tr></table></figure><p><strong>telldir</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long int telldir(DIR *dirp);</span><br></pre></td></tr></table></figure><ul><li>返回值记录一个目录流的当前位置</li></ul><p><strong>seekdir</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void seekdir(DIR *dirp,long int loc);</span><br></pre></td></tr></table></figure><ul><li>设置目录流dirp的目录项指针，loc的值用来设置指针位置，它应该通过<strong>telldir</strong>来获得</li></ul><p><strong>closedir</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int closedir(DIR *dirp);</span><br></pre></td></tr></table></figure><ul><li>关闭一个目录流并释放与之关联的资源，执行成功返回0，错误返回-1</li></ul><h2 id="六-文件和目录的维护"><a href="#六-文件和目录的维护" class="headerlink" title="六 文件和目录的维护"></a>六 文件和目录的维护</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>chmod</td><td>改变文件的访问权限</td></tr><tr><td>unlink/link/symlink</td><td>删除/建立文件链接</td></tr><tr><td>mkdir/rmdir</td><td>建立/删除目录</td></tr><tr><td>chdir/getcwd</td><td>获取当前目录</td></tr></tbody></table><p><strong>chmod</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int chmod(const char *path,mode_t mode);</span><br></pre></td></tr></table></figure><ul><li>path参数指定的文件被修改为具有mode参数给出的权限，参数mode与open中的一样</li></ul><p><strong>unlink/link/symlink</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int unlink(const char *path);</span><br><span class="line">int link(const char *path1,const char *path2);</span><br><span class="line">int symlink(const char *path1,const char *path2);</span><br></pre></td></tr></table></figure><ul><li>unlink,用来删除一个文件的目录项并减少它的连接数，成功返回0，失败返回-1，如果一个文件的链接数减少到0并且没有进程打开它，这个文件就会被删除</li><li>link 将创建一个指向已有文件path1的新连接，新目录由path2给出</li><li>symlink 以类似的方式创建符号链接</li></ul><p><strong>mkdir/rmdir</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int mkdir(const char *path,mode_t mode);</span><br><span class="line">int rmdir(const char *path);</span><br></pre></td></tr></table></figure><ul><li>mkdir 用于创建目录，权限由mode参数给出</li><li>rmdir 用于删除目录，只有在目录为空时才行</li></ul><p><strong>chdir/getcwd</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int chdir(const char *path);</span><br><span class="line">char *getcwd(char *buf,size_t size);</span><br></pre></td></tr></table></figure><ul><li>chdir 用于切换目录</li><li>getcwd 用于获取当前目录，把当前目录的名字写到buff里面，size参数给出了buff的长度</li></ul><h2 id="七-proc文件系统"><a href="#七-proc文件系统" class="headerlink" title="七 /proc文件系统"></a>七 /proc文件系统</h2><p>Linux提供了一个特殊的文件系统procfs,它通常以/proc目录的形式呈现<br>  </p><p>该目录中包含了许多驱动程序和内核信息，只要应用程序具有正确的访问权限，它们就可以通过读写这些文件来获得信息或者设置参数<br></p><ul><li>这是我阿里云服务器的/proc目录列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1      143    23     430   54    6875  985          interrupts   modules        thread-self</span><br><span class="line">10     15     24     431   55    6893  acpi         iomem        mounts         timer_list</span><br><span class="line">11     16     274    446   56    6894  buddyinfo    ioports      mtrr           timer_stats</span><br><span class="line">11293  163    27448  47    57    6911  bus          irq          net            tty</span><br><span class="line">11296  165    27449  4700  573   7     cgroups      kallsyms     pagetypeinfo   uptime</span><br><span class="line">12     166    27456  474   58    7081  cmdline      kcore        partitions     version</span><br><span class="line">13     17     27457  479   59    786   consoles     keys         sched_debug    version_signature</span><br><span class="line">133    18     27458  48    599   8     cpuinfo      key-users    schedstat      vmallocinfo</span><br><span class="line">134    19     27507  49    60    81    crypto       kmsg         scsi           vmstat</span><br><span class="line">135    197    28     5     61    811   devices      kpagecgroup  self           zoneinfo</span><br><span class="line">137    2      29     50    62    82    diskstats    kpagecount   slabinfo</span><br><span class="line">138    20     3      504   6539  874   dma          kpageflags   softirqs</span><br><span class="line">139    20824  30     505   6559  882   driver       loadavg      stat</span><br><span class="line">14     21     31     51    6581  9     execdomains  locks        swaps</span><br><span class="line">140    218    394    52    6584  930   fb           mdstat       sys</span><br><span class="line">141    22     411    5220  68    952   filesystems  meminfo      sysrq-trigger</span><br><span class="line">142    22921  425    53    6857  953   fs           misc         sysvipc</span><br></pre></td></tr></table></figure><ul><li>常用的信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo    输出cpu信息</span><br><span class="line">cat &#x2F;proc&#x2F;meminfo    输出内存使用情况</span><br><span class="line">cat &#x2F;proc&#x2F;version    输出内核版本信息</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><h2 id="八-锁文件"><a href="#八-锁文件" class="headerlink" title="八 锁文件"></a>八 锁文件</h2><blockquote><p>Linux提供了很多种方法来实现文件锁定，其中最简单的方法就是以原子操作的方式创建锁文件，所谓“原子操作”就是在创建锁文件时，这个过程不允许被打断。<br></p></blockquote><p>这种方式却把它所创建的文件是唯一的，而且这个文件不可能被其他程序在同一时间创<br></p><ul><li><p>锁文件只是<strong>建议锁</strong>，而不是<strong>强制锁</strong></p><blockquote><p>建议锁：进程在对某一个文件进行操作时，没有检测是否加锁或者直接向文件写入数据，内核是不会加以阻止的<br>强制锁：OS内核的文件锁，应用程序对文件进行读写操作时，OS内核会检测文件是否加锁，如果加锁将导致操作失败</p></blockquote></li><li><p>锁文件的实现是通过open函数调用的<strong>O_EXCL</strong>标志来完成的   </p></li></ul><ul><li>示例代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *  文件锁</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        int file_desc;</span><br><span class="line">        int save_error;</span><br><span class="line"></span><br><span class="line">        file_desc &#x3D; open(&quot;.&#x2F;LCK.test&quot;,O_RDWR | O_CREAT | O_EXCL,0444);</span><br><span class="line">        if(file_desc &#x3D;&#x3D; -1)</span><br><span class="line">                &#123;</span><br><span class="line">                        save_error &#x3D; errno;</span><br><span class="line">                        printf(&quot;open failed with error %d \n&quot;,save_error);</span><br><span class="line">                &#125;</span><br><span class="line">        else</span><br><span class="line">                &#123;</span><br><span class="line">                        printf(&quot; open succeeded \n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">        exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过O_EXCL标志以原子操作的方式创建了一个锁文件，但是需要注意以下两点：</p><ul><li>1 如果需要保证这个文件的名字是唯一的，那么所有的进程在创建文件时都需要加上O_EXCL，如果这个文件已经存在，则open()调用会返回错误</li><li>2 如果其他进程不加O_EXCL标志，则可以直接读写这个文件，因为锁文件是<strong>建议锁而不是强制锁</strong></li></ul><h2 id="九-文件锁"><a href="#九-文件锁" class="headerlink" title="九 文件锁"></a>九 文件锁</h2><blockquote><p>Linux至少提供两种系统调用，分别是fcntl系统调用和lockf系统调用，这些系统调用的好处是可以实现文件的<strong>区域锁定</strong>和<strong>段锁定</strong><br>fcntl和lockf使用不同的底层实现，因此两者不能混合使用<br>fcntl和lockf<strong>都是建议锁，而不是强制锁</strong></p></blockquote><h3 id="fcntl系统调用"><a href="#fcntl系统调用" class="headerlink" title="fcntl系统调用"></a>fcntl系统调用</h3><ul><li>fcntl对一个打开的文件描述符进行操作，并能根据command参数完成不同的任务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fcntl(int fildes,int command,struct flock *flock_structure);</span><br></pre></td></tr></table></figure><ul><li>command选项如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 获取锁信息，信息存储在 struct flock 结构体中 *&#x2F;</span><br><span class="line">F_GETLK</span><br><span class="line"></span><br><span class="line">&#x2F;* 加锁或者解锁，加锁或者解锁的信息在 struct flock 结构体中  *&#x2F;</span><br><span class="line">F_SETLK</span><br><span class="line"></span><br><span class="line">&#x2F;* 与SETLK类似，但在无法获取锁时，这个调用将等待直到 1 获取锁 2 收到一个信号 才会返回 *&#x2F;</span><br><span class="line">F_SETLKW</span><br></pre></td></tr></table></figure><ul><li>struct flock的成员如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">short l_type</span><br><span class="line">short l_whence</span><br><span class="line">off_t l_start</span><br><span class="line">off_t l_len</span><br><span class="line">pid_t l_pid</span><br></pre></td></tr></table></figure><ul><li>l_type</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 共享锁&#x2F;读锁 </span><br><span class="line"> * 许多不同的进程可以拥有文件同一区域的共享锁</span><br><span class="line"> * 只要任一进程拥有共享锁，则没有进程可以获得该区域的独占锁</span><br><span class="line"> * 简单的说，这把锁的作用是使文件不让进程上锁</span><br><span class="line"> * 要想获取共享锁，文件必须以读或者读写的方式打开</span><br><span class="line"> * 一般读文件的进程设置共享锁</span><br><span class="line"> *&#x2F;</span><br><span class="line">F_RDLCK</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> *解锁，清除锁</span><br><span class="line"> *&#x2F;</span><br><span class="line">F_UNLCK</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 独占锁&#x2F;写锁 </span><br><span class="line"> * 有且只有一个进程可以在文件的特定区域拥有一把独占锁</span><br><span class="line"> * 只要有一个进程设置了独占锁，其他任何进程都不可以设置任何锁</span><br><span class="line"> * 获取独占锁的前提是，文件必须要以写或者读写的方式打开，（否则没有获取独占锁，因为不需要修改文件)</span><br><span class="line"> * 一般写文件的进程设置独占锁</span><br><span class="line"> *&#x2F;</span><br><span class="line">F_WRLCK</span><br></pre></td></tr></table></figure><ul><li>l_whence</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 文件头 *&#x2F;</span><br><span class="line">SEEK_SET</span><br><span class="line">&#x2F;* 当前位置 *&#x2F;</span><br><span class="line">SEEK_CUR</span><br><span class="line">&#x2F;* 文件尾 *&#x2F;</span><br><span class="line">SEEK_END</span><br></pre></td></tr></table></figure><ul><li><p>l_start / l_len<br>l_whence定义了l_start的相对偏移值，l_start定义了该区域的第一个字节，l_len定义了改区域的字节数</p></li><li><p>l_pid<br>l_pid记录 持有锁的进程</p></li></ul><p><strong>示例代码</strong></p><p>1 在文件上加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *文件锁 </span><br><span class="line"> *  use fcntl</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">const char *test_file &#x3D; &quot;.&#x2F;tmp&#x2F;test_lock.txt&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">The structure describing an advisory lock.  This is the type of the third </span><br><span class="line">argument to &#96;fcntl&#39; for the F_GETLK, F_SETLK, and F_SETLKW requests.  </span><br><span class="line"></span><br><span class="line">struct flock</span><br><span class="line">  &#123;</span><br><span class="line">    __off_t l_start; Offset where the lock begins.  </span><br><span class="line">    __off_t l_len;    Size of the locked area; zero means until EOF.  </span><br><span class="line">    __pid_t l_pid;Process holding the lock.  </span><br><span class="line">    short int l_type;Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  </span><br><span class="line">    short int l_whence;Where &#96;l_start&#39; is relative to (like &#96;lseek&#39;).  </span><br><span class="line">  &#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int file_desc;</span><br><span class="line">int byte_count;</span><br><span class="line">char * byte_to_write &#x3D; &#39;A&#39;;</span><br><span class="line">struct flock region_1;</span><br><span class="line">struct flock region_2;</span><br><span class="line">int res;</span><br><span class="line"></span><br><span class="line">file_desc &#x3D; open(test_file,O_RDWR | O_CREAT , 0666);</span><br><span class="line">if(!file_desc)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr,&quot;unable to open file \n&quot;);</span><br><span class="line">exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">for(byte_count &#x3D; 0;byte_count &lt; 100;byte_count ++)</span><br><span class="line">&#123;</span><br><span class="line">write(file_desc,byte_to_write,1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 10-30 字节设置为区域 1 ，设置共享锁 *&#x2F;</span><br><span class="line">region_1.l_type &#x3D; F_RDLCK;</span><br><span class="line">region_1.l_whence &#x3D; SEEK_SET;</span><br><span class="line">region_1.l_start &#x3D;  10;</span><br><span class="line">region_1.l_len &#x3D; 20;</span><br><span class="line"></span><br><span class="line">&#x2F;* 40-50 字节设置为区域 2 ，设置独占锁 *&#x2F;</span><br><span class="line">region_2.l_type &#x3D; F_WRLCK;</span><br><span class="line">region_2.l_whence &#x3D; SEEK_SET;</span><br><span class="line">region_2.l_start &#x3D;  40;</span><br><span class="line">region_2.l_len &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;* 锁定文件 *&#x2F;</span><br><span class="line">printf(&quot; process %d locking file \n &quot;,getpid());</span><br><span class="line">res &#x3D; fcntl(file_desc,F_SETLK,&amp;region_1); &#x2F;* F_SETLK : 区域加锁 *&#x2F;</span><br><span class="line">if(res &#x3D;&#x3D; -1) fprintf(stderr,&quot;failed to lock region 1\n&quot;);</span><br><span class="line">res &#x3D; fcntl(file_desc,F_SETLK,&amp;region_2); &#x2F;* F_SETLK : 区域加锁 *&#x2F;</span><br><span class="line">if(res &#x3D;&#x3D; -1) fprintf(stderr,&quot;failed to lock region 2\n&quot;);</span><br><span class="line"></span><br><span class="line">sleep(60);</span><br><span class="line"></span><br><span class="line">printf(&quot;process %d close file \n&quot;,getpid());</span><br><span class="line">close(file_desc);</span><br><span class="line">exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 在另一个进程中读出这些锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> *测试文件中不同部分的文件锁</span><br><span class="line"> *  use fcntl </span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">const char *test_file &#x3D; &quot;.&#x2F;tmp&#x2F;test_lock.txt&quot;;</span><br><span class="line">#define SIZE_TO_TRY 5</span><br><span class="line"></span><br><span class="line">void show_lock_info(struct flock * lck);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int file_desc;</span><br><span class="line">int res;</span><br><span class="line">struct flock region_to_test;</span><br><span class="line">int start_byte;</span><br><span class="line"></span><br><span class="line">file_desc &#x3D; open(test_file,O_RDWR | O_CREAT,0X666);</span><br><span class="line">if(!file_desc)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr,&quot;Unable to open file \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">for(start_byte &#x3D; 0;start_byte &lt; 99 ;start_byte +&#x3D; SIZE_TO_TRY)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 独占锁 *&#x2F;</span><br><span class="line">region_to_test.l_type &#x3D; F_WRLCK;</span><br><span class="line">region_to_test.l_whence &#x3D; SEEK_SET;</span><br><span class="line">region_to_test.l_start &#x3D; start_byte;</span><br><span class="line">region_to_test.l_len &#x3D; SIZE_TO_TRY;</span><br><span class="line">region_to_test.l_pid &#x3D; -1;</span><br><span class="line">printf(&quot;testing F_WRLCK on region from %d to %d \n&quot;,start_byte,start_byte+SIZE_TO_TRY);</span><br><span class="line"></span><br><span class="line">&#x2F;*  F_GETLK   : 获取锁信息 *&#x2F;</span><br><span class="line">res &#x3D; fcntl(file_desc,F_GETLK,&amp;region_to_test);</span><br><span class="line">if(res &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr,&quot;lock fail,F_WRLCK retutn \n&quot;);</span><br><span class="line">exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">if(region_to_test.l_pid !&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;lock fail,F_WRLCK retutn \n&quot;);</span><br><span class="line">show_lock_info(&amp;region_to_test);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot; F_WRLCK - Lock would succeed \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 共享锁 *&#x2F;</span><br><span class="line">region_to_test.l_type &#x3D; F_RDLCK;</span><br><span class="line">region_to_test.l_whence &#x3D; SEEK_SET;</span><br><span class="line">region_to_test.l_start &#x3D; start_byte;</span><br><span class="line">region_to_test.l_len &#x3D; SIZE_TO_TRY;</span><br><span class="line">region_to_test.l_pid &#x3D; -1;</span><br><span class="line">printf(&quot;testing F_RDLCK on region from %d to %d \n&quot;,start_byte,start_byte+SIZE_TO_TRY);</span><br><span class="line"></span><br><span class="line">&#x2F;*      F_GETLK : 获取锁信息 *&#x2F;</span><br><span class="line">res &#x3D; fcntl(file_desc,F_GETLK,&amp;region_to_test);</span><br><span class="line">if(res &#x3D;&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr,&quot;lock fail,F_RDLCK retutn \n&quot;);</span><br><span class="line">exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">if(region_to_test.l_pid !&#x3D; -1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;lock fail,F_RDLCK retutn \n&quot;);</span><br><span class="line">show_lock_info(&amp;region_to_test);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot; F_RDLCK - Lock would succeed \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">close(file_desc);</span><br><span class="line">exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show_lock_info(struct flock * lck)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot; \t1_type %d &quot;, lck-&gt;l_type);</span><br><span class="line">printf(&quot; \t1_whence %d &quot;,  lck-&gt;l_whence);</span><br><span class="line">printf(&quot; \t1_start %d &quot;,   lck-&gt;l_start);</span><br><span class="line">printf(&quot; \t1_len %d &quot;,      lck-&gt;l_len);</span><br><span class="line">printf(&quot; \t1_pid %d \n&quot;,      lck-&gt;l_pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lockf系统调用"><a href="#lockf系统调用" class="headerlink" title="lockf系统调用"></a>lockf系统调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int lockf(int fildes,int function,off_t size_to_lock);</span><br></pre></td></tr></table></figure><ul><li>function定义如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F_ULOCK:解锁</span><br><span class="line">F_LOCK : 设置独占锁</span><br><span class="line">F_TLOCK : 测试并设置独占锁</span><br><span class="line">F_TEST : 测试其他进程设置的锁</span><br></pre></td></tr></table></figure><ul><li>size_to_lock</li></ul><p>操作的字节数，从文件的当前偏移值开始计算</p><blockquote><p>lockf的接口更加简单，但是功能和灵活性比fcntl差一些</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unix环境编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix环境编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux应用程序调试方法</title>
    <link href="/2019/05/18/Linux%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    <url>/2019/05/18/Linux%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一-使用strace命令跟踪系统调用"><a href="#一-使用strace命令跟踪系统调用" class="headerlink" title="一 使用strace命令跟踪系统调用"></a>一 使用strace命令跟踪系统调用</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>打补丁<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt; ..&#x2F;xxx.patch</span><br></pre></td></tr></table></figure></li><li>配置strace &amp;&amp; 编译<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --host&#x3D;arm-linux CC&#x3D;arm-linux-gcc</span><br><span class="line">make</span><br></pre></td></tr></table></figure>编译完成之后得到一个strace应用程序，拷贝到开发板上就可以使用了<br>使用方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;strace -o log.txt .&#x2F;firstdrvtext on</span><br></pre></td></tr></table></figure><code>log.txt</code>是调试信息输出的文件，<code>./firstdrvtext on</code>是应用程序使用方法</li></ul><h3 id="简单介绍strace的原理"><a href="#简单介绍strace的原理" class="headerlink" title="简单介绍strace的原理"></a>简单介绍strace的原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;strace(父进程) -o log.txt .&#x2F;firstdrvtext on(子进程)</span><br></pre></td></tr></table></figure><p><strong>父进程启动一个子进程，子进程先判断是否被跟踪，如果是，则会发送给父进程一些信号，然后进入休眠，父进程根据信号值决定记录哪些数据，父进程处理完之后（如记录），子进程继续运行。</strong></p><blockquote><p>子进程里面的open,read,write(c库)函数会调用一条swi指令 swi val<br>open   —-  swi  #val1<br>read    —- swi  #val2<br>write   —- swi  #val3<br>这条指令会导致系统swi异常，进入内核态，调用sys_open,sys_read …   </p></blockquote><ul><li>打开内核文件<code>arch/arm/kernel/entry-common.s</code>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">tstip, #_TIF_SYSCALL_TRACE@ are we tracing syscalls?</span><br><span class="line">bne__sys_trace</span><br><span class="line">&#x2F;&#x2F; 测试标记为，看是否被跟踪，如果被跟踪，则调用__sys_trace</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li>__sys_trace：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * This is the really slow path.  We&#39;re going to be doing</span><br><span class="line"> * context switches, and waiting for our parent to respond.</span><br><span class="line"> *&#x2F;</span><br><span class="line">__sys_trace:</span><br><span class="line">movr2, scno</span><br><span class="line">addr1, sp, #S_OFF</span><br><span class="line">movr0, #0@ trace entry [IP &#x3D; 0]</span><br><span class="line">blsyscall_trace</span><br><span class="line"></span><br><span class="line">adrlr, __sys_trace_return@ return address</span><br><span class="line">movscno, r0@ syscall number (possibly new)</span><br><span class="line">addr1, sp, #S_R0 + S_OFF@ pointer to regs</span><br><span class="line">cmpscno, #NR_syscalls@ check upper syscall limit</span><br><span class="line">ldmcciar1, &#123;r0 - r3&#125;@ have to reload r0 - r3</span><br><span class="line">ldrccpc, [tbl, scno, lsl #2]@ call sys_* routine</span><br><span class="line">b2b</span><br></pre></td></tr></table></figure><h3 id="strace的其他用法"><a href="#strace的其他用法" class="headerlink" title="strace的其他用法"></a>strace的其他用法</h3></li></ul><h2 id="二-使用GDB调试应用程序"><a href="#二-使用GDB调试应用程序" class="headerlink" title="二 使用GDB调试应用程序"></a>二 使用GDB调试应用程序</h2><h3 id="编译与安装"><a href="#编译与安装" class="headerlink" title="编译与安装"></a>编译与安装</h3><ul><li>配置 &amp;&amp; 编译 &amp;&amp; 安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --target&#x3D;arm-linux --disable-werror</span><br></pre></td></tr></table></figure></li><li>查看安装目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi makefile</span><br><span class="line">prefix &#x3D; &#x2F;usr&#x2F;local</span><br></pre></td></tr></table></figure></li><li>安装目录修改当前目录下的tmp<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir tmp</span><br><span class="line">make install prefix&#x3D;$PWD&#x2F;tmp</span><br></pre></td></tr></table></figure></li><li>配置 &amp;&amp; 编译gdbserver，并复制到网络文件系统<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd gdb&#x2F;gdbserver</span><br><span class="line">.&#x2F;configure --host&#x3D;arm-linux</span><br><span class="line">make</span><br><span class="line">cp gdbserver &#x2F;work&#x2F;fs.. &#x2F;bin&#x2F;gdbserver</span><br></pre></td></tr></table></figure><h3 id="GDB远程调试步骤"><a href="#GDB远程调试步骤" class="headerlink" title="GDB远程调试步骤"></a>GDB远程调试步骤</h3><blockquote><p>编译要调试的应用程序，编译时要加上-g选项</p></blockquote></li><li>在ARM板上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdbserver 192.168.1.17:2345 .&#x2F;test_debug</span><br><span class="line">&#x2F;&#x2F;  ip是arm板的ip，端口随便写</span><br></pre></td></tr></table></figure></li><li>在pc机上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin&#x2F;arm-linux-gdb  .&#x2F;test_debug</span><br><span class="line">target remote 192.168.1.17:2345</span><br></pre></td></tr></table></figure></li><li>常用的命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l： 查看源码</span><br><span class="line">break main  &#x2F;  break test_debug:31： 打断点 &#x2F;&#x2F;main函数打断点 &#x2F;  31行打断点</span><br><span class="line">c：继续执行</span><br><span class="line">step ：单步调试</span><br><span class="line">print *p：输出</span><br><span class="line">quit：退出</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h3 id="GDB的另一种使用方法"><a href="#GDB的另一种使用方法" class="headerlink" title="GDB的另一种使用方法"></a>GDB的另一种使用方法</h3><blockquote><p>让程序在开发板上直接运行，当它发送错误时，令它产生<strong>core dump</strong>文件<br>然后使用gdb根据core dump文件找到发生错误的地方。</p></blockquote><ul><li><p>在开发板上输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure></li><li><p>执行应用程序 <code>./test_debug</code> 程序出错会在当前目录下生成名为<code>core</code>的文件</p></li><li><p>拷贝core文件到pc上，pc机上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp core &#x2F;work&#x2F;xxx&#x2F;core</span><br><span class="line">&#x2F;bin&#x2F;arm-linux-gdb  .&#x2F;test_debug  .&#x2F;core</span><br></pre></td></tr></table></figure><p>若程序出错，就可以看到很多调试信息。</p></li></ul><h2 id="三-配置内核，输出应用程序的段错误信息"><a href="#三-配置内核，输出应用程序的段错误信息" class="headerlink" title="三 配置内核，输出应用程序的段错误信息"></a>三 配置内核，输出应用程序的段错误信息</h2><h3 id="配置内核，输出错误信息"><a href="#配置内核，输出错误信息" class="headerlink" title="配置内核，输出错误信息"></a>配置内核，输出错误信息</h3><ul><li>根据应用程序报错的信息在内核源码中搜索：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;Unable to handle kernel&quot; * -nR</span><br></pre></td></tr></table></figure></li><li>找到并打开<code>arch/arm/mm/fault.c</code>,看到下面的函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 处理应用程序错误函数 *&#x2F;</span><br><span class="line">static void</span><br><span class="line">__do_user_fault(struct task_struct *tsk, unsigned long addr,</span><br><span class="line">unsigned int fsr, unsigned int sig, int code,</span><br><span class="line">struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">struct siginfo si;</span><br><span class="line">unsigned long ret;</span><br><span class="line">unsigned long val;</span><br><span class="line">int i &#x3D;0;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEBUG_USER&#x2F;&#x2F; 1  配置内核</span><br><span class="line">if (user_debug &amp; UDBG_SEGV) &#123;   &#x2F;&#x2F; 2 设置启动参数</span><br><span class="line">printk(KERN_DEBUG &quot;%s: unhandled page fault (%d) at 0x%08lx, code 0x%03x\n&quot;,</span><br><span class="line">       tsk-&gt;comm, sig, addr, fsr);</span><br><span class="line">show_pte(tsk-&gt;mm, addr);</span><br><span class="line">show_regs(regs);</span><br><span class="line">&#x2F;*  开始打印栈信息   *&#x2F;</span><br><span class="line">printk(&quot;Stack: \n&quot;);</span><br><span class="line">while(i&lt;1024)</span><br><span class="line">&#123;</span><br><span class="line">if(copy_from_user(&amp;val,(const void __user *)(regs-&gt;ARM_sp+i*4),4)</span><br><span class="line">break;</span><br><span class="line">printk(&quot;%08x &quot;,val);</span><br><span class="line">i++;</span><br><span class="line">if(i % 8 &#x3D;&#x3D; 0)</span><br><span class="line">printk(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">printk(&quot;\nEnd of stack \n&quot;);</span><br><span class="line">&#x2F;*  打印栈信息结束   *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">tsk-&gt;thread.address &#x3D; addr;</span><br><span class="line">tsk-&gt;thread.error_code &#x3D; fsr;</span><br><span class="line">tsk-&gt;thread.trap_no &#x3D; 14;</span><br><span class="line">si.si_signo &#x3D; sig;</span><br><span class="line">si.si_errno &#x3D; 0;</span><br><span class="line">si.si_code &#x3D; code;</span><br><span class="line">si.si_addr &#x3D; (void __user *)addr;</span><br><span class="line">force_sig_info(sig, &amp;si, tsk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>配置内核 CONFIG_DEBUG_USER<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig </span><br><span class="line">&#x2F;DEBUG_USER  &#x2F;&#x2F;  搜索，配置成y</span><br><span class="line">make uImage</span><br></pre></td></tr></table></figure></li><li>uboot设置启动参数 user_debug<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set bootargs user_debug&#x3D;0xff ... ...</span><br></pre></td></tr></table></figure></li><li>执行./test_debug，可以看到调试信息和寄存器的值</li><li>反汇编app<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-objdump -D test_debug &gt; test_debug.dis</span><br></pre></td></tr></table></figure>在反汇编中找到pc值处的代码，根据寄存器的值找到程序出错的原因</li></ul><h3 id="修改内核，打印栈信息"><a href="#修改内核，打印栈信息" class="headerlink" title="修改内核，打印栈信息"></a>修改内核，打印栈信息</h3><p><code>struct pt_regs</code> 包含发生错误的瞬间所有寄存器的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct pt_regs &#123;</span><br><span class="line">long uregs[18];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define ARM_cpsruregs[16]</span><br><span class="line">#define ARM_pcuregs[15]</span><br><span class="line">#define ARM_lruregs[14]</span><br><span class="line">#define ARM_spuregs[13]</span><br><span class="line">#define ARM_ipuregs[12]</span><br><span class="line">#define ARM_fpuregs[11]</span><br><span class="line">#define ARM_r10uregs[10]</span><br><span class="line">#define ARM_r9uregs[9]</span><br><span class="line">#define ARM_r8uregs[8]</span><br><span class="line">#define ARM_r7uregs[7]</span><br><span class="line">#define ARM_r6uregs[6]</span><br><span class="line">#define ARM_r5uregs[5]</span><br><span class="line">#define ARM_r4uregs[4]</span><br><span class="line">#define ARM_r3uregs[3]</span><br><span class="line">#define ARM_r2uregs[2]</span><br><span class="line">#define ARM_r1uregs[1]</span><br><span class="line">#define ARM_r0uregs[0]</span><br><span class="line">#define ARM_ORIG_r0uregs[17]</span><br></pre></td></tr></table></figure><p>在<code>arch/arm/mm/__do_user_fault</code>中加入下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unsigned long ret;</span><br><span class="line">unsigned long val;</span><br><span class="line">int i &#x3D;0;</span><br><span class="line">printk(&quot;Stack: \n&quot;);</span><br><span class="line">while(i&lt;1024)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* 从堆栈指针sp处开始打印栈信息 *&#x2F;</span><br><span class="line">if(copy_from_user(&amp;val,(const void __user *)(regs-&gt;ARM_sp+i*4),4)  </span><br><span class="line">break; </span><br><span class="line">printk(&quot;%08x &quot;,val);</span><br><span class="line">i++;</span><br><span class="line">if(i % 8 &#x3D;&#x3D; 0)</span><br><span class="line">printk(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">printk(&quot;\nEnd of stack \n&quot;);</span><br></pre></td></tr></table></figure><ul><li>重新编译内核,复制到网络文件系统，并用新内核启动<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make uImage </span><br><span class="line">cp arch&#x2F;arm&#x2F;uImage  &#x2F;work&#x2F;nfs_root&#x2F;fs_mini_mdev&#x2F;uImage</span><br><span class="line">reboot</span><br><span class="line">nfs 32000000 192.168.1.123:&#x2F;work&#x2F;...&#x2F;uImage_new</span><br></pre></td></tr></table></figure></li></ul><p><strong>main函数被动态库调用，怎么知道动态库的地址？</strong></p><ul><li>方法1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps &#x2F;&#x2F;查看进程ID</span><br><span class="line">cat &#x2F;proc&#x2F;xxx(进程ID)</span><br><span class="line">cat maps      &#x2F;&#x2F;    查看应用程序里面各段地址</span><br></pre></td></tr></table></figure><ul><li>方法2，使用gdb调试,先启动gdb,使用命令<code>info file</code>查看程序里面的各个段</li></ul><blockquote><p>动态链接不容易看程序调用信息，把应用程序编译成静态链接的方式：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gcc -o test test.c -static</span><br></pre></td></tr></table></figure><h2 id="四-自制系统调用"><a href="#四-自制系统调用" class="headerlink" title="四 自制系统调用"></a>四 自制系统调用</h2><blockquote><p>ps:这种方法很少用，也比较繁琐，适合长时间打印调试信息</p></blockquote><h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><p>app 调用<code>open read write</code>函数，导致：swi #val<br>程序跳转到<code>vector_swi</code>处去执行，得到“导致异常的指令”，取出里面的val,根据这个val调用对应的处理函数，如<code>sys_open,sys_write，sys_read...</code><br>这些函数在一个数组里，通过查找数组调用对应的函数。   </p><ul><li>仿照这种形式写一个自己的系统调用</li></ul><h3 id="自制系统调用"><a href="#自制系统调用" class="headerlink" title="自制系统调用"></a>自制系统调用</h3><ul><li><strong>写一个应用函数，仿glibc，用来触发系统调用</strong>   <blockquote><p>仿照glibc里面的brk.c里面的_brk函数（c嵌入汇编的形式）</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#define __NR_OABI_SYSCALL_BASE0x900000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;#if defined(__thumb__) || defined(__ARM_EABI__)</span><br><span class="line">&#x2F;&#x2F;#define __NR_SYSCALL_BASE0</span><br><span class="line">&#x2F;&#x2F;#else</span><br><span class="line">#define __NR_SYSCALL_BASE__NR_OABI_SYSCALL_BASE</span><br><span class="line">&#x2F;&#x2F;#endif</span><br><span class="line"></span><br><span class="line">void hello(char *buf ,int count )</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;* swi *&#x2F;</span><br><span class="line"> asm (&quot;mov r0, %0\n&quot;&#x2F;* save the argment in r0 *&#x2F;</span><br><span class="line">          &quot;mov r1, %1\n&quot;&#x2F;* save the argment in r0 *&#x2F;</span><br><span class="line">          &quot;swi %2\n&quot;&#x2F;* do the system call *&#x2F;</span><br><span class="line">          : </span><br><span class="line">          : &quot;r&quot;(buf),&quot;r&quot;(count), &quot;i&quot; (__NR_SYSCALL_BASE + 352)</span><br><span class="line">          : &quot;r0&quot;,&quot;r1&quot;);&#x2F;* 过程中会改变的寄存器 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(int argc , char ** argv)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot; in app, call hello  \n&quot;);</span><br><span class="line">&#x2F;* 执行hello函数触发一个swi指令异常 *&#x2F;</span><br><span class="line">hello(&quot;tjpuzh.top&quot;,10);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>修改内核，添加系统调用函数的声明和实现</strong> </li><li>声明： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include\linux\syscalls.h中加入</span><br><span class="line">asmlinkage ssize_t sys_hello(const char __user *buf,int count);</span><br></pre></td></tr></table></figure><ul><li><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在\fs\read_write.c中实现sys_hello</span><br><span class="line">asmlinkage ssize_t sys_hello(const char __user * buf,int count)</span><br><span class="line">&#123;</span><br><span class="line">... ... </span><br><span class="line">&#x2F;&#x2F; 此处实现想要实现的功能，如open,read,write...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 arch\arm\kernel\calls.S中，最后加入一项CALL(sys_hello)</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make uImage</span><br><span class="line">cp arch&#x2F;arm&#x2F;uImage &#x2F;work&#x2F;nfs_root&#x2F;fs_mini_mdev&#x2F;uImage</span><br><span class="line">reboot</span><br><span class="line">nfs 32000000 192.168.3.123:&#x2F;work&#x2F;nfs_root&#x2F;fs_mini_mdev&#x2F;uImage_hello</span><br><span class="line">bootm 32000000</span><br></pre></td></tr></table></figure><h3 id="使用自制系统调用来打输出调试信息"><a href="#使用自制系统调用来打输出调试信息" class="headerlink" title="使用自制系统调用来打输出调试信息"></a>使用自制系统调用来打输出调试信息</h3><p> <strong>整体流程</strong></p><ul><li>修改应用程序的可执行文件，替换“某个位置”的代码为swi val   </li><li>执行程序   </li><li>执行到断点处，进入sys_hello    </li><li>在sys_hello,打印调试信息，执行原来的指令，返回</li></ul><p><strong>测试步骤</strong></p><ul><li>写一个简单的应用程序 : <code>debug_with_system_call.c</code></li><li>替换            </li></ul><ol><li><p>输出反汇编文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-objdump -D debug_with_system_call &gt; debug_with_system_call.dis</span><br></pre></td></tr></table></figure></li><li><p>根据适合打断点的指令，找到合适机器码    </p></li><li><p>反汇编自制系统调用的测试程序，可以看到swi指令的机器码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-objdump -D test_system_call &gt; test_system_call.dis</span><br></pre></td></tr></table></figure>    </li><li><p>修改应用程序的机器码为swi指令的机器码    </p>    </li></ol><p>保存为  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug_with_system_call_swi</span><br></pre></td></tr></table></figure><p>加上执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x debug_with_system_call_swi</span><br></pre></td></tr></table></figure><ul><li>修改自制的sys_hello函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;asm&#x2F;processor.h&gt;</span><br><span class="line">asmlinkage ssize_t sys_hello(const char __user * buf,int count)</span><br><span class="line">&#123;</span><br><span class="line">int val;</span><br><span class="line">struct pt_regs *regs;</span><br><span class="line">&#x2F;* 1 输出一些打印调试信息 *&#x2F;</span><br><span class="line">&#x2F;* 应用程序的反汇编里：00010788 &lt;cnt&gt; *&#x2F;</span><br><span class="line">copy_from_user(&amp;val,(const void __user *)0x00010788,4);</span><br><span class="line">printk(&quot;sys_hello:val &#x3D; %d\n&quot;,val);</span><br><span class="line">&#x2F;* 2 执行被替换的指令: add r3, r3, #2; 0x2 *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 搜索pt_regs，在它的结果里再搜索current</span><br><span class="line">regs &#x3D; task_pt_regs(current);</span><br><span class="line">regs-&gt;ARM_r3 +&#x3D; 2;</span><br><span class="line">&#x2F;* 3 反回 *&#x2F;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;debug_with_system_call_swi</span><br></pre></td></tr></table></figure><h2 id="五-编写输入模拟器"><a href="#五-编写输入模拟器" class="headerlink" title="五 编写输入模拟器"></a>五 编写输入模拟器</h2></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux调试方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux调试方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>call back机制</title>
    <link href="/2019/04/21/callback%E6%9C%BA%E5%88%B6/"/>
    <url>/2019/04/21/callback%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>ps:最近在做ffmpeg+rtmp的视频直播，这算是里面用到的一个小技术点。实际上这个技术<strong>很常用很常用</strong>，重要的事情多说一遍。</p></blockquote><h2 id="什么是call-back？"><a href="#什么是call-back？" class="headerlink" title="什么是call back？"></a>什么是call back？</h2><ul><li><strong>call back的定义</strong><blockquote><p>callback,又叫回调函数，是指用函数指针的形式将函数作为另一个函数的参数，当这个指针所指向的函数被调用时，这个函数就叫回调函数。</p></blockquote></li></ul><p>听起来是不是挺简单的，但是本文介绍的重点不在于如何定义一个函数指针，也不在于如何通过函数指针调用一个函数，而是介绍回调函数机制，重点在机制的分析，也就是通过回调函数的技术实现某些特定的功能。</p><hr><p>emmmm, 好吧，还是先介绍一下如何定义一个函数指针：</p><pre><code class="hljs c"><span class="hljs-keyword">void</span> (*function_callback)(AVFrame *pframe);</code></pre><p>这种定义方法当然没错，但是将这么长的一个式子放进另一个函数中作为参数，代码就有点不好看</p><ul><li>我们可以这么做：</li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*function_callback)</span><span class="hljs-params">(AVFrame *pframe)</span></span>;function_callback updatecallback；</code></pre><p>注意，下面这两行代码里面的<code>function_callback</code>就<strong>不是一个具体的函数指针</strong>了，这是通过typedef定义的一个<strong>函数指针类型</strong>，通过这个函数指针类型定义了一个函数指针<code>updatecallback</code>。<br>也许你会问，typedef的形式不是应该像下面这样吗？</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span>* pchar;</code></pre><p>原因是，在定义函数声明时，会将函数指针放到前面，使其看起来像一个完整的函数形式，如果把函数指针拿到后面，不就和这种形式一样了麽？</p><p>对于回调函数，还有一种说法:</p><blockquote><p>用户调用windows api叫做call, 就是调用，<br>windows api调用用户的函数叫call back</p></blockquote><p>有这种说法的存在是因为windows的内核中确实存在大量的回调函数需要用户去实现，但实际上这是回调函数的一种应用场景，call back还有其他的很多应用场景，在下面介绍。</p><h2 id="callback的应用场景"><a href="#callback的应用场景" class="headerlink" title="callback的应用场景"></a>callback的应用场景</h2><p><strong>线程同步，底层代码与GUI交互，一个接口多个实现等</strong></p><p>线程同步有很多种方式，其中    qt中有信号与槽的方式，在线程A中发送信号，线程B接受到信号执行槽函数，在linux中有信号量等，，，</p><ul><li><p><strong>使用callback的实现方法如下：</strong></p></li><li><p>模块A在完成某一操作后需要调用模块B的操作</p><blockquote><p>  如ffmpeg在视频解码完毕之后需要调用GUI层的函数来渲染图像，但是不同的平台的GUI又一样或者说GUI与ffmpeg不在一个线程中，在写ffmpeg的时候不知道调用哪个，此时，就可以用回调函数。<br> 不管这个是什么函数，先用函数指针的形式定义出来，再把它放在应该放的位置调用，最后提供一个设置callback的接口setcallback。<br> 别的模块按照这个函数指针的格式实现一个具体的函数，再调用setcallback的接口设置这个callback</p></blockquote></li><li><p><strong>一个接口多个实现</strong><br>看例子：</p></li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintMsg1</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"This is the message 1!\n"</span>);&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintMsg2</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"This is the message 2!\n"</span>);&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintMsg3</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"This is the message 3!\n"</span>);&#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowMessage</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (* p)())</span></span>&#123;p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;   ShowMessage(PrintMsg1);   ShowMessage(PrintMsg2);   ShowMessage(PrintMsg3);&#125;</code></pre><p><strong>callback的优点：灵活，跨平台</strong></p><p><img src="/img/callback%E6%9C%BA%E5%88%B6/callback.png" srcset="/img/loading.gif" alt=""></p><h2 id="实现线程同步的代码示例"><a href="#实现线程同步的代码示例" class="headerlink" title="实现线程同步的代码示例"></a>实现线程同步的代码示例</h2><ul><li><strong>ffmpeg解码线程：</strong></li><li>声明：</li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*function_callback)</span><span class="hljs-params">(AVFrame *pframe)</span></span>;function_callback updatecallback;</code></pre><ul><li>定义setupcallback：</li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setupcallback</span><span class="hljs-params">(function_callback callback)</span></span><span class="hljs-function"></span>&#123;updatecallback = callback;&#125;</code></pre><ul><li>callback使用：</li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start_decode</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;...<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;...avcodec_decode_video2(pOutCodecCtx,&amp;pframe,&amp;dec_got_frame,&amp;pkt);<span class="hljs-comment">// 解码</span>updatecallback(&amp;pframe);<span class="hljs-comment">// 刷新GUI</span>...&#125;...&#125;</code></pre><ul><li><p><strong>qt gui线程</strong></p></li><li><p>实现callback:</p></li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUpdateDecodedVideoData</span><span class="hljs-params">(AVFrame *pframe)</span></span><span class="hljs-function"></span>&#123;...&#125;</code></pre><ul><li>调用setupcallback把上面的函数替换掉ffmpeg线程里的函数</li></ul><pre><code class="hljs c">setupcallback(onUpdateDecodedVideoData);</code></pre><p><strong>这里需要注意以下几点：</strong><br>C++类成员函数的callback函数一般是静态的，原因在于C++的普通成员函数的参数会有一个默认的this，会导致callback函数的参数不匹配，编译器报错。<br>静态的成员函数无法调用非静态的成员变量，解决这个问题有个简单的方法就是在类内部定义一个静态的对象指针，把this指针赋值给这个静态的对象指针，在静态成员函数中使用这个静态对象代替this调用类内部的成员变量。</p><hr><p><font color=gray size=1>技术是在不断的讨论中进步的，如所述有不妥之处，希望能联系 <a href="mailto:devtty@qq.com">devtty@qq.com</a> 进行指正，万分感谢！ </font></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>热拔插驱动</title>
    <link href="/2019/04/16/%E7%83%AD%E6%8B%94%E6%8F%92%E9%A9%B1%E5%8A%A8/"/>
    <url>/2019/04/16/%E7%83%AD%E6%8B%94%E6%8F%92%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="热拔插驱动"><a href="#热拔插驱动" class="headerlink" title="热拔插驱动"></a>热拔插驱动</h2><ul><li>hotplug/uevent机制</li></ul><h3 id="hotplug内核框架"><a href="#hotplug内核框架" class="headerlink" title="hotplug内核框架"></a>hotplug内核框架</h3><pre><code class="hljs arduino">class_device_createclass_device_registerclass_device_addkobject_ueventkobject_uevent_env(kobj, action, <span class="hljs-literal">NULL</span>)   <span class="hljs-comment">// action_string  = “add”</span>action_string = action_to_string(action)<span class="hljs-comment">/* 分配保存环境变量的内存 */</span><span class="hljs-comment">/* environment values */</span><span class="hljs-built_in">buffer</span> = kmalloc(BUFFER_SIZE, GFP_KERNEL)<span class="hljs-comment">/* 设置环境变量 */</span>scratch = <span class="hljs-built_in">buffer</span>;envp [i++] = scratch;scratch += <span class="hljs-built_in">sprintf</span>(scratch, <span class="hljs-string">"ACTION=%s"</span>, action_string) + <span class="hljs-number">1</span>;envp [i++] = scratch;scratch += <span class="hljs-built_in">sprintf</span> (scratch, <span class="hljs-string">"DEVPATH=%s"</span>, devpath) + <span class="hljs-number">1</span>;envp [i++] = scratch;scratch += <span class="hljs-built_in">sprintf</span>(scratch, <span class="hljs-string">"SUBSYSTEM=%s"</span>, subsystem) + <span class="hljs-number">1</span>;<span class="hljs-comment">/* 调用应用程序：比如mdev */</span>argv [<span class="hljs-number">0</span>] = uevent_helper; = “mdev”argv [<span class="hljs-number">1</span>] = (<span class="hljs-keyword">char</span> *)subsystem;argv [<span class="hljs-number">2</span>] = <span class="hljs-literal">NULL</span>;call_usermodehelper (argv[<span class="hljs-number">0</span>], argv, envp, <span class="hljs-number">0</span>);</code></pre><ul><li>过程总结：</li></ul><blockquote><p>上述的代码从<code>class_device_class</code>开始,创建一个设备节点，然后层层深入每个函数调用的关键函数，最终找到<code>kobject_uevent</code>函数，根据传入的action，如<code>add</code>命令,则分配环境变量所需要的内存，再设置环境变量，设置完毕之后，调用<code>call_usermodehelper</code>,调用一个应用程序，这个应该程序会根据环境变量创建设备节点，这个外部函数一般设置为<code>/sbin/mdev</code></p></blockquote><ul><li><p>mdev介绍</p><blockquote><p>mdev是busybox中的一个udev管理程序的精简版本，它也可以自己创建设备节点和设备的自动挂载，只是mdev是被hotplug直接调用<br>mdev扫描/sys/class和/sys/block中所有的类设备目录，如果在目录中含有名为”dev”的文件，且文件中包含的是设备号，则mdev就利用这些信息为这个设备在/dev下创建设备节点</p></blockquote></li><li><p>为什么是/sbin/mdev？</p><blockquote><p>启动脚本<code>cat /etc/init.d/rcS</code>:<br> <code>echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</code>设置了uevent_helper 为“/sbin/mdev”.</p></blockquote></li></ul><h3 id="如何实现自动挂载"><a href="#如何实现自动挂载" class="headerlink" title="如何实现自动挂载"></a>如何实现自动挂载</h3><ul><li><p>如果想实现U盘的自动挂载<br>1 内核支持hotplug<br>2 需要编辑配置文件<code>/etc/mdev.conf</code>,该文件的作用是在找到匹配设备时自动执行自定义命令</p><p><strong>mdev.conf的格式</strong> </p></li></ul><pre><code class="hljs fsharp">&lt;device regex&gt; &lt;uid&gt;:&lt;gid&gt; &lt;octal permissions&gt; <span class="hljs-meta">[&lt;@|$|*&gt; &lt;command&gt;]</span></code></pre><blockquote><p><code>device regex</code> 正则表达式，表示哪一个设备<br><code>uid</code> owner<br><code>gid</code> 组ID<br><code>octal permissions</code>  以八进制表示的属性，默认660<br><code>@</code>  创建设备节点之后执行命令<br><code>$</code> 删除设备节点之前执行命令<br><code>*</code> 创建设备节点之后执行，删除设备节点之前执行命令<br><code>command</code> 要执行的命令</p></blockquote><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ul><li>什么是正则表达式：            <blockquote><p>1 在电脑上查文件，<em>.c :  *是通配符，表示任意字符<br>2 更精确的查找，使用正则表达式<br>  <code>.</code>表示任意字符（换行符除外）<br>  `</em> <code>表示重复0次或者更多次</code>+<code>表示重复1次或者更多次</code>？<code>表示重复0次或者1次</code>[  xxx  ] <code>表示这些字符里面的某一个，如</code>[abc]<code>、</code>[1~9]`</p></blockquote></li></ul><h4 id="写mdev-conf-参考-busybox-的-mdev-txt"><a href="#写mdev-conf-参考-busybox-的-mdev-txt" class="headerlink" title="写mdev.conf:(参考 busybox 的 mdev.txt )"></a>写mdev.conf:(参考 busybox 的 mdev.txt )</h4><p>1 <strong>实现led驱动在挂载时输出相关信息</strong>   </p><p>1.1 原始的做法</p><pre><code class="hljs angelscript">vi /etc/mdev.confleds <span class="hljs-number">0</span>:<span class="hljs-number">0</span> <span class="hljs-number">777</span>led1 <span class="hljs-number">0</span>:<span class="hljs-number">0</span> <span class="hljs-number">777</span>led2 <span class="hljs-number">0</span>:<span class="hljs-number">0</span> <span class="hljs-number">777</span>led3 <span class="hljs-number">0</span>:<span class="hljs-number">0</span> <span class="hljs-number">777</span></code></pre><p>1.2 修改为    </p><pre><code class="hljs angelscript">leds? [<span class="hljs-number">123</span>]? <span class="hljs-number">0</span>:<span class="hljs-number">0</span> <span class="hljs-number">777</span></code></pre><p>1.3 添加打印命令   </p><pre><code class="hljs angelscript">leds? [<span class="hljs-number">123</span>]? <span class="hljs-number">0</span>:<span class="hljs-number">0</span> <span class="hljs-number">777</span> * echo create /dev/$MDEV &gt; /dev/console</code></pre><p>1.4 改成输入输出打印不同的命令</p><pre><code class="hljs routeros">leds? [123]? 0:0 777 * <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$ACTION</span> = “add”]; then echo create /dev/<span class="hljs-variable">$MDEV</span> &gt; /dev<span class="hljs-built_in">/console; </span><span class="hljs-keyword">else</span> echo <span class="hljs-builtin-name">remove</span> /dev/<span class="hljs-variable">$MDEV</span> &gt; /dev/console;</code></pre><p>1.5 把上面的命令写入一个脚本 add_remove_led.sh</p><pre><code class="hljs routeros"><span class="hljs-comment">#!/bin/sh</span><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$ACTION</span> = “add”]thenecho create /dev/<span class="hljs-variable">$MDEV</span> &gt; /dev/console;<span class="hljs-keyword">else</span>echo <span class="hljs-builtin-name">remove</span> /dev/<span class="hljs-variable">$MDEV</span> &gt; /dev/console;fi</code></pre><p>1.6 再修改/etc/mdev.conf文件</p><pre><code class="hljs angelscript">leds?[<span class="hljs-number">123</span>]? <span class="hljs-number">0</span>:<span class="hljs-number">0</span> <span class="hljs-number">777</span> * /bin/add_remove_led.sh</code></pre><p>2 <strong>设置U盘自动挂载</strong></p><pre><code class="hljs angelscript">sda[<span class="hljs-number">1</span><span class="hljs-number">-9</span>]+ <span class="hljs-number">0</span>:<span class="hljs-number">0</span> <span class="hljs-number">777</span> * <span class="hljs-keyword">if</span> [$ACTION = “add”];then mount /dev/$MDEV /mnt; <span class="hljs-keyword">else</span> umount /mnt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux驱动</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux驱动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DMA驱动</title>
    <link href="/2019/04/11/DMA%E9%A9%B1%E5%8A%A8/"/>
    <url>/2019/04/11/DMA%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="DMA驱动"><a href="#DMA驱动" class="headerlink" title="DMA驱动"></a>DMA驱动</h1><h2 id="DMA驱动-1"><a href="#DMA驱动-1" class="headerlink" title=" DMA驱动 "></a><font color=gray size=1> DMA驱动 </font></h2><h2 id="一-DMA简介"><a href="#一-DMA简介" class="headerlink" title="一 DMA简介"></a>一 DMA简介</h2><p>DMA：Direct Memory Access 直接内存存取     </p><p>根据2440的芯片手册，DMA分为四种工作模式：</p><blockquote><ul><li>数据传输源地址在系统总线，数据传输目的地址在外部总线</li><li>数据传输源地址在系统总线，数据传输目的地址在系统总线</li><li>数据传输源地址在外部总线，数据传输目的地址在外部总线</li><li>数据传输源地址在外部总线，数据传输目的地址在系统总线</li></ul></blockquote><p>简而言之，DMA的作用就是用来进行数据的传输，而传输的过程不需要CPU的参与，可以为<br>系统减负。</p><p>对DMA的设置分为以下几个步骤：</p><ol><li>把源告诉DMA</li><li>把目的告诉DMA</li><li>把size告诉DMA</li><li>设置DMA的参数</li><li>启动DMA</li></ol><h2 id="二-DMA驱动代码分析"><a href="#二-DMA驱动代码分析" class="headerlink" title="二 DMA驱动代码分析"></a>二 DMA驱动代码分析</h2><h3 id="驱动入口函数"><a href="#驱动入口函数" class="headerlink" title="驱动入口函数"></a>驱动入口函数</h3><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dma_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(request_irq(IRQ_DMA3,s3c_dma_irq,<span class="hljs-number">0</span>,<span class="hljs-string">"s3c_dma"</span>,<span class="hljs-number">1</span>))&#123;printk(<span class="hljs-string">"can not request irq for dma \n"</span>);<span class="hljs-keyword">return</span> -EBUSY;&#125;src = dma_alloc_writecombine(<span class="hljs-literal">NULL</span>, BUFF_SIZE, &amp;src_phy, GFP_KERNEL);<span class="hljs-keyword">if</span>(src == <span class="hljs-literal">NULL</span>)&#123;free_irq(IRQ_DMA3,<span class="hljs-number">1</span>);printk(<span class="hljs-string">" can not alloc buffer for src \n"</span>);<span class="hljs-keyword">return</span> -ENOMEM;&#125;des = dma_alloc_writecombine(<span class="hljs-literal">NULL</span>, BUFF_SIZE, &amp;des_phy, GFP_KERNEL);<span class="hljs-keyword">if</span>(des == <span class="hljs-literal">NULL</span>)&#123;free_irq(IRQ_DMA3,<span class="hljs-number">1</span>);printk(<span class="hljs-string">" can not alloc buffer for des \n"</span>);dma_free_writecombine(<span class="hljs-literal">NULL</span>, BUFF_SIZE, &amp;src_phy, GFP_KERNEL);<span class="hljs-keyword">return</span> -ENOMEM;&#125;major = register_chrdev(<span class="hljs-number">0</span>, <span class="hljs-string">"s3c_dma"</span>, &amp;dma_fops);cls = class_create(THIS_MODULE,<span class="hljs-string">"s3c_dma"</span>);class_device_create(cls, <span class="hljs-literal">NULL</span>, MKDEV(major,<span class="hljs-number">0</span>),<span class="hljs-literal">NULL</span>,<span class="hljs-string">"dma"</span>); <span class="hljs-comment">/* /dev/dma */</span>p_s3c_regs = ioremap(S3C_DMA3_BASE, <span class="hljs-keyword">sizeof</span>(struct s3c_dma_regs));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>驱动入口函数分析：        </p><ol><li>注册DMA中断函数，在ioctl函数中，启动DMA之后进入休眠，此中断函数是用于在DMA<br>传输完成之后唤醒ioctl.</li><li>dma_alloc_writecombine ： 用来分配源和目的的buffer,此处不能用kmalloc，原因在于kmalloc分配到的内存地址不一定连续，而DMA传输需要<strong>源和目的的地址都是连续的</strong></li><li>register_chrdev：注册一个字符设备驱动，把dma_fops注册进内核，<strong>dma的操作一般使用的是ioctl，而不是rend/write</strong></li><li>class_create：创建一个类</li><li>class_device_create：在这个类下面创建一个字符设备节点</li><li>ioremap：分配DMA寄存器的虚拟地址</li></ol><h3 id="ioctl函数"><a href="#ioctl函数" class="headerlink" title="ioctl函数"></a>ioctl函数</h3><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">s3c_dma_ioctl</span> <span class="hljs-params">(struct inode * node, struct file *file, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i;<span class="hljs-built_in">memset</span>(src,<span class="hljs-number">0X55</span>,BUFF_SIZE);<span class="hljs-built_in">memset</span>(des,<span class="hljs-number">0XAA</span>,BUFF_SIZE);<span class="hljs-keyword">switch</span>(cmd)&#123;<span class="hljs-keyword">case</span> NO_USE_DMA :&#123;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;BUFF_SIZE;i++)&#123;des[i] = src[i];&#125;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(des,src,BUFF_SIZE) == <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">"NO_USE_DMA OK \n"</span>);&#125;<span class="hljs-keyword">else</span>&#123;printk(<span class="hljs-string">"NO_USE_DMA ERROR \n"</span>);&#125;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> USE_DMA:&#123;ev_dma = <span class="hljs-number">0</span>;p_s3c_regs-&gt;disrc = src_phy;<span class="hljs-comment">/* 把源,目的,长度告诉DMA */</span>p_s3c_regs-&gt;disrc      = src_phy;        <span class="hljs-comment">/* 源的物理地址 */</span>p_s3c_regs-&gt;disrcc     = (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">1</span>) | (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">0</span>); <span class="hljs-comment">/* 源位于AHB总线, 源地址递增 */</span>p_s3c_regs-&gt;didst      = des_phy;        <span class="hljs-comment">/* 目的的物理地址 */</span>p_s3c_regs-&gt;didstc     = (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">2</span>) | (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">1</span>) | (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">0</span>); <span class="hljs-comment">/* 目的位于AHB总线, 目的地址递增 */</span>p_s3c_regs-&gt;dcon       = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>)|(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">29</span>)|(<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">28</span>)|(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">27</span>)|(<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">23</span>)|(<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">20</span>)|(BUFF_SIZE&lt;&lt;<span class="hljs-number">0</span>);  <span class="hljs-comment">/* 使能中断,单个传输,软件触发, */</span><span class="hljs-comment">/* 启动DMA */</span>p_s3c_regs-&gt;dmasktrig  = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<span class="hljs-comment">/* 如何知道DMA转换完成？ */</span><span class="hljs-comment">/* 休眠 */</span>wait_event_interruptible(dma_waittq, ev_dma);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(des,src,BUFF_SIZE) == <span class="hljs-number">0</span>)&#123;printk(<span class="hljs-string">"USE_DMA OK \n"</span>);&#125;<span class="hljs-keyword">else</span>&#123;printk(<span class="hljs-string">"USE_DMA ERROR \n"</span>);&#125;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>ioctl函数分析：</p><ol><li>函数中通过用户传入的数选择使用DMA还是不使用DMA</li><li>wait_event_interruptible(dma_waittq, ev_dma)：函数进入休眠,参数定义如下：</li></ol><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">DECLARE_WAIT_QUEUE_HEAD</span><span class="hljs-params">(dma_waittq)</span></span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> ev_dma = <span class="hljs-number">0</span>;</code></pre><p>进入iotcl函数时，把ev_dma设置为0，休眠ioctl<br>DMA传输完成时，把ev_dma设置为1，唤醒ioctl,唤醒的中断函数如下：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">irqreturn_t</span> <span class="hljs-title">s3c_dma_irq</span><span class="hljs-params">(<span class="hljs-keyword">int</span> irq, <span class="hljs-keyword">void</span> *devid)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">/* 唤醒 */</span>ev_dma = <span class="hljs-number">1</span>;wake_up_interruptible(&amp;dma_waittq);<span class="hljs-comment">/* 唤醒休眠的进程 */</span><span class="hljs-keyword">return</span> IRQ_HANDLED;&#125;</code></pre><p>以上就是DMA的一个简单的试验，在虚拟机上将DMA测试文件放在后台运行，再输入ls等指令，使用DMA和不使用DMA，CPU对指令的反应速度有很大的差距。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>原先做电池管理时，在STM32上做ADC采集数据，一次需要16路ADC的数据，所以将ADC配置成了DMA模式，减轻CPU工作量的效果还是很明显的。其实，还有别的外设也是可以配置成DMA模式的。</p><h2 id="DMA驱动-2"><a href="#DMA驱动-2" class="headerlink" title=" DMA驱动 "></a><font color=gray size=1> DMA驱动 </font></h2>]]></content>
    
    
    <categories>
      
      <category>Linux驱动</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux驱动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符设备驱动</title>
    <link href="/2019/04/03/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    <url>/2019/04/03/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h1><h2 id="之前的框架"><a href="#之前的框架" class="headerlink" title="之前的框架"></a>之前的框架</h2><pre><code class="hljs markdown"><span class="hljs-bullet">- </span>确定主设备号<span class="hljs-bullet">- </span>file_operation结构体<span class="hljs-bullet">- </span>register_chrdecv<span class="hljs-bullet">- </span>入口<span class="hljs-bullet">- </span>出口</code></pre><p><strong>缺点：只有255个字符设备驱动</strong></p><blockquote><p><strong>之前：以主设备号为下标，在chardev里面找到之前注册的file_operations</strong><br><strong>现在：以主设备号和次设备号来找到file_operation结构体</strong></p></blockquote><h2 id="现在的框架"><a href="#现在的框架" class="headerlink" title="现在的框架"></a>现在的框架</h2><p>register_chardev拆分为以下几个部分：</p><pre><code class="hljs">__register_chrdev_regioncdev_alloccdev_initcdev_add</code></pre><h4 id="具体框架分析"><a href="#具体框架分析" class="headerlink" title="具体框架分析"></a>具体框架分析</h4><hr><ul><li>构造file_operation结构体</li></ul><pre><code class="hljs ini"><span class="hljs-attr">.owner</span> = THIS_MODULE<span class="hljs-attr">.open</span>  = hello</code></pre><ul><li>注册字符设备驱动</li></ul><pre><code class="hljs objectivec"><span class="hljs-keyword">if</span> major<span class="hljs-built_in">MKDEV</span>register_chrdev_region<span class="hljs-keyword">else</span> alloc_chrdev_region  <span class="hljs-comment">//自动分配主设备号</span></code></pre><ul><li>定义一个cdev结构体，并初始化</li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">cdev_init</span><span class="hljs-attribute">cdev_add</span></code></pre><ul><li>创建类，自动创建设备节点</li></ul><pre><code class="hljs ceylon">struct <span class="hljs-keyword">class</span> cls;cls = <span class="hljs-keyword">class</span><span class="hljs-number">_</span>create<span class="hljs-keyword">class</span><span class="hljs-number">_</span>device<span class="hljs-number">_</span>create</code></pre><ul><li>出口函数</li></ul><pre><code class="hljs ceylon"><span class="hljs-keyword">class</span><span class="hljs-number">_</span>device<span class="hljs-number">_</span>destroy<span class="hljs-keyword">class</span><span class="hljs-number">_</span>destroycdev<span class="hljs-number">_</span>delunregister<span class="hljs-number">_</span>chrdev<span class="hljs-number">_</span>region</code></pre><ul><li>测试程序</li></ul><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><span class="hljs-comment">/*</span><span class="hljs-comment"> * hello_test /dev/hello</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_usage</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *file)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s &lt;dev&gt; \n"</span>,file);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> fd;<span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)&#123;print_usage(argv[<span class="hljs-number">0</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;fd = <span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>],O_RDWR);<span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"can not open %s \n"</span>,argv[<span class="hljs-number">1</span>]);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"can open %s \n"</span>,argv[<span class="hljs-number">1</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="驱动部分代码"><a href="#驱动部分代码" class="headerlink" title="驱动部分代码"></a>驱动部分代码</h4><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;linux/<span class="hljs-keyword">module</span>.h&gt;#<span class="hljs-keyword">include</span> &lt;linux/kernel.h&gt;#<span class="hljs-keyword">include</span> &lt;linux/fs.h&gt;#<span class="hljs-keyword">include</span> &lt;linux/init.h&gt;#<span class="hljs-keyword">include</span> &lt;linux/delay.h&gt;#<span class="hljs-keyword">include</span> &lt;linux/irq.h&gt;#<span class="hljs-keyword">include</span> &lt;asm/uaccess.h&gt;#<span class="hljs-keyword">include</span> &lt;asm/irq.h&gt;#<span class="hljs-keyword">include</span> &lt;asm/io.h&gt;#<span class="hljs-keyword">include</span> &lt;asm/arch/regs-gpio.h&gt;#<span class="hljs-keyword">include</span> &lt;asm/hardware.h&gt;#<span class="hljs-keyword">include</span> &lt;linux/poll.h&gt;#<span class="hljs-keyword">include</span> &lt;linux/cdev.h&gt;<span class="hljs-comment">/* 1  确定主设备号 */</span>static <span class="hljs-built_in">int</span> major = <span class="hljs-number">0</span>;static <span class="hljs-keyword">struct</span> cdev cdev_hello; static <span class="hljs-keyword">struct</span> cdev cdev2_hello;#define MAX_HELLO <span class="hljs-number">2</span>static dev_t devid;static <span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *cls;<span class="hljs-built_in">int</span>  hello<span class="hljs-constructor">_open(<span class="hljs-params">struct</span> <span class="hljs-params">inode</span> <span class="hljs-operator">*</span><span class="hljs-params">node</span>,<span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">file</span>)</span>&#123;static count = <span class="hljs-number">0</span>;printk(<span class="hljs-string">"hello1 is open %d \n"</span>,++count);return <span class="hljs-number">0</span>;&#125;<span class="hljs-built_in">int</span>  hello2<span class="hljs-constructor">_open(<span class="hljs-params">struct</span> <span class="hljs-params">inode</span> <span class="hljs-operator">*</span><span class="hljs-params">node</span>,<span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">file</span>)</span>&#123;static count = <span class="hljs-number">0</span>;  printk(<span class="hljs-string">"hello2 is open %d \n"</span>,++count);return <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 2  构造file_operation结构体*/</span>static <span class="hljs-keyword">struct</span> file_operations file_ops=&#123;.owner = THIS_MODULE,.<span class="hljs-keyword">open</span>  = hello_open,&#125;; static <span class="hljs-keyword">struct</span> file_operations file_ops2=&#123;.owner = THIS_MODULE,.<span class="hljs-keyword">open</span>  = hello2_open,&#125;;static <span class="hljs-built_in">int</span> hello<span class="hljs-constructor">_init(<span class="hljs-params">void</span>)</span>&#123;<span class="hljs-comment">/*3 代替register_chrdev的方式 */</span><span class="hljs-comment">/* 创建次设备号为0 1的节点 */</span><span class="hljs-keyword">if</span> (major) &#123; devid = <span class="hljs-constructor">MKDEV(<span class="hljs-params">major</span>, 0)</span>;register<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">devid</span>, MAX_HELLO, <span class="hljs-string">"hello"</span>)</span>;<span class="hljs-comment">/* major(0~1)对应file_ops，其他的都不对应file_ops */</span>&#125; <span class="hljs-keyword">else</span> &#123;alloc<span class="hljs-constructor">_chrdev_region(&amp;<span class="hljs-params">devid</span>, 0, MAX_HELLO, <span class="hljs-string">"hello"</span>)</span>;<span class="hljs-comment">/* major(0~1)对应file_ops，其他的都不对应file_ops */</span>major = <span class="hljs-constructor">MAJOR(<span class="hljs-params">devid</span>)</span>;&#125;cdev<span class="hljs-constructor">_init(&amp;<span class="hljs-params">cdev_hello</span>,&amp;<span class="hljs-params">file_ops</span>)</span>;cdev<span class="hljs-constructor">_add(&amp;<span class="hljs-params">cdev_hello</span>,<span class="hljs-params">devid</span>,MAX_HELLO)</span>;<span class="hljs-comment">/* 创建次设备号为2的节点 */</span>devid = <span class="hljs-constructor">MKDEV(<span class="hljs-params">major</span>, 2)</span>; <span class="hljs-comment">// 从2开始</span>register<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">devid</span>, 1, <span class="hljs-string">"hello"</span>)</span>; <span class="hljs-comment">// 需要1个节点</span>cdev<span class="hljs-constructor">_init(&amp;<span class="hljs-params">cdev2_hello</span>,&amp;<span class="hljs-params">file_ops2</span>)</span>;cdev<span class="hljs-constructor">_add(&amp;<span class="hljs-params">cdev2_hello</span>,<span class="hljs-params">devid</span>,1)</span>; <span class="hljs-comment">/*4 自动创建设备节点 */</span>cls = <span class="hljs-keyword">class</span><span class="hljs-constructor">_create(THIS_MODULE,<span class="hljs-string">"hello"</span>)</span>;<span class="hljs-keyword">class</span><span class="hljs-constructor">_device_create(<span class="hljs-params">cls</span>,NULL,MKDEV(<span class="hljs-params">major</span>,0)</span>,NULL,<span class="hljs-string">"hello0"</span>);<span class="hljs-comment">/*dev/hello0*/</span><span class="hljs-keyword">class</span><span class="hljs-constructor">_device_create(<span class="hljs-params">cls</span>,NULL,MKDEV(<span class="hljs-params">major</span>,1)</span>,NULL,<span class="hljs-string">"hello1"</span>);<span class="hljs-comment">/*dev/hello1*/</span><span class="hljs-keyword">class</span><span class="hljs-constructor">_device_create(<span class="hljs-params">cls</span>,NULL,MKDEV(<span class="hljs-params">major</span>,2)</span>,NULL,<span class="hljs-string">"hello2"</span>);<span class="hljs-comment">/*dev/hello2*/</span><span class="hljs-keyword">class</span><span class="hljs-constructor">_device_create(<span class="hljs-params">cls</span>,NULL,MKDEV(<span class="hljs-params">major</span>,3)</span>,NULL,<span class="hljs-string">"hello3"</span>);<span class="hljs-comment">/*dev/hello2*/</span>return <span class="hljs-number">0</span>;&#125;static void hello<span class="hljs-constructor">_exit(<span class="hljs-params">void</span>)</span>&#123;<span class="hljs-keyword">class</span><span class="hljs-constructor">_device_destroy(<span class="hljs-params">cls</span>,MKDEV(<span class="hljs-params">major</span>,0)</span>);<span class="hljs-keyword">class</span><span class="hljs-constructor">_device_destroy(<span class="hljs-params">cls</span>,MKDEV(<span class="hljs-params">major</span>,1)</span>);<span class="hljs-keyword">class</span><span class="hljs-constructor">_device_destroy(<span class="hljs-params">cls</span>,MKDEV(<span class="hljs-params">major</span>,2)</span>);<span class="hljs-keyword">class</span><span class="hljs-constructor">_device_destroy(<span class="hljs-params">cls</span>,MKDEV(<span class="hljs-params">major</span>,3)</span>);<span class="hljs-keyword">class</span><span class="hljs-constructor">_destroy(<span class="hljs-params">cls</span>)</span>;cdev<span class="hljs-constructor">_del(&amp;<span class="hljs-params">cdev_hello</span>)</span>;unregister<span class="hljs-constructor">_chrdev_region(MKDEV(<span class="hljs-params">major</span>,0)</span>,MAX_HELLO);cdev<span class="hljs-constructor">_del(&amp;<span class="hljs-params">cdev2_hello</span>)</span>;unregister<span class="hljs-constructor">_chrdev_region(MKDEV(<span class="hljs-params">major</span>,2)</span>,<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">module</span><span class="hljs-constructor">_init(<span class="hljs-params">hello_init</span>)</span>;<span class="hljs-keyword">module</span><span class="hljs-constructor">_exit(<span class="hljs-params">hello_exit</span>)</span>;<span class="hljs-constructor">MODULE_LICENSE(<span class="hljs-string">"GPL"</span>)</span>;</code></pre><blockquote><p>以上是字符设备驱动的框架以及测试代码，仅仅是说明了字符设备驱动的一种新的注册方式，距离一个真正的字符设备驱动还有一定的距离<del>~</del></p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>Linux驱动</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux驱动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组与指针的关系</title>
    <link href="/2019/04/03/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/"/>
    <url>/2019/04/03/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="数组与指针的关系"><a href="#数组与指针的关系" class="headerlink" title="数组与指针的关系"></a>数组与指针的关系</h1><h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><blockquote><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4></blockquote><ul><li>一维数组 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int array</span><br></pre></td></tr></table></figure><ul><li>二维数组 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int array_2 [][10]</span><br><span class="line">注：低维度的数据元素个数必须显式定义，高维度可以省略</span><br></pre></td></tr></table></figure><ul><li>指针数组（数组元素为指针的数组） </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *p[]</span><br></pre></td></tr></table></figure><blockquote><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4></blockquote><ul><li>一级指针：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*p</span><br></pre></td></tr></table></figure><ul><li>二级指针：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**p</span><br></pre></td></tr></table></figure><ul><li>数组指针（指向数组的指针）：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int (*p)[10] </span><br><span class="line">这里是指向二维数组的指针形式，10 必须显式说明</span><br></pre></td></tr></table></figure><h2 id="常见的问题与解答"><a href="#常见的问题与解答" class="headerlink" title="常见的问题与解答"></a>常见的问题与解答</h2><blockquote><p>问题1 ：数组名和指针的区别？</p></blockquote><p>答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组名是数组的首地址，是一个常量，而不是变量</span><br><span class="line">指针是一种变量类型</span><br><span class="line">变量可以赋值给常量，常量不可以赋值给变量</span><br><span class="line">《c和指针》的说法为，表达式的左值必须是可修改的，也就是说数组名不可以是表达式的左值</span><br></pre></td></tr></table></figure><blockquote><p>问题2：如何把指针指向二维数组呢？</p></blockquote><p>答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有两种形式：</span><br><span class="line">    1 使用数组指针，C语言中指向二维数组的指针的形式为：</span><br><span class="line">      int (*p)[10]（为什么这么写？解释在下面）</span><br><span class="line">    2 由于二维数组的元素在内存中是按照先行后列的顺序顺序存储的，因此：</span><br><span class="line">      可以把数组的首地址“显式”的赋值给一个一级指针，形式如下：</span><br><span class="line">      int *p &#x3D; &amp;array[0][0]</span><br><span class="line">      但是注意：int *p &#x3D; array，这种形式在编译器中会报错</span><br></pre></td></tr></table></figure><blockquote><p>问题3：二级指针可以指向二维数组吗？</p></blockquote><p>答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是不可以的!编译器同样会报错。</span><br><span class="line">从这里可以看出，二维数组寻找数组的元素也许并不是对一位数组的首地址进行解引用</span><br><span class="line">操作，很可能是简单的进行行列的计算得出数据的位置（数据是顺序存储的），也就是</span><br><span class="line">为什么二维数组的列数必须是固定的。</span><br></pre></td></tr></table></figure><blockquote><p>问题4：什么类型的指针可以指向指针数组？</p></blockquote><p>答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">顾名思义，指针数组里面的元素都是指针，也就是说对数组地址进行解引用操作之后并不能</span><br><span class="line">得到数据，而是一个指针，必须对这个指针再进行一次解引用操作，才能得到一个具体的数</span><br><span class="line">据。</span><br><span class="line">上面的定义是不是和二级指针的定义很类似呢?</span><br><span class="line">是的，C语言中可以用二级指针指向指针数组。</span><br></pre></td></tr></table></figure><blockquote><p>问题5：对指针数组和数组指针形式的解释？</p></blockquote><p>答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">指针数组：char *p[] :</span><br><span class="line">[]的优先级大于*,因此p先和[]结合，解释为一个数组，char * 表面了数组里面元素的类型，</span><br><span class="line">为指向char型的指针</span><br><span class="line"></span><br><span class="line">数组指针：常见的是指向二维数组或者更高维数组的指针</span><br><span class="line">指向二维数组的指针：char (*p)[10]:</span><br><span class="line">()的优先级大于[],因此* 和p先结合，解释为一个指针，char修饰的是数组，包含了若干个</span><br><span class="line">元素的数组。</span><br><span class="line">也可以按照常规的数据定义方式：char(*)[10] p，char(*)[10]是数据类型，p是变量名，</span><br><span class="line">只是为了好看把P前移了而已。</span><br><span class="line">（注：实测后面这种形式在VS2017上编译并没有通过 --email:1059859967@qq.com）</span><br></pre></td></tr></table></figure><blockquote><p>问题6: <code>char **argv</code> 与<code>char *argv[]</code>的区别</p></blockquote><p>答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相信你看完之后已经完全不用搜索帖子或者百度来解答这个问题了~~~</span><br></pre></td></tr></table></figure><hr><blockquote><p><font color=gray size=1>技术是在不断的讨论中进步的，如所述有不妥之处，希望能联系 <a href="mailto:1059859967@qq.com">1059859967@qq.com</a> 进行指正，万分感谢！ </font></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
