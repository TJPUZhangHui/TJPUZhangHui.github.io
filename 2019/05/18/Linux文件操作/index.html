<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/avatar.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="ZhangHui">
  <meta name="keywords" content="">
  <title>Linux文件操作 - 章辉的博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>ZH</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2019-05-18 22:04">
                    2019年5月18日 晚上
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    5.8k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    73
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p><strong>目录结构</strong>  </p>
<blockquote>
<p>1  底层系统调用<br>2  标准IO库<br>3  格式化输入输出<br>4  带缓冲的IO和不带缓冲的IO<br>5  目录操作<br>6  文件和目录的维护<br>7  proc文件系统<br>8  锁文件<br>9  文件锁  </p>
</blockquote>
<p>想必在此之前，你已经听说过这么一句话，<strong>在linux中，一切（几乎一切）都是文件</strong>，设置硬件设备也被映射为文件，Linux中比较重要的设备文件有3个：</p>
<pre><code class="hljs css">/dev/console：系统控制台
/dev/tty：终端控制，由系统自动运行的进程和脚本没有控制终端，所以它们不能打开/dev/tty
/dev/null：空设备，在cp命令里把它用作复制空文件的源文件，例如：
cp /dev/null empty_file</code></pre>

<h2 id="一-底层系统调用"><a href="#一-底层系统调用" class="headerlink" title="一 底层系统调用"></a>一 底层系统调用</h2><p><strong>文件操作的底层系统调用常用的有以下几个：</strong>    </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>open</td>
<td>打开文件或设备</td>
</tr>
<tr>
<td>read</td>
<td>从打开的文件或者设备里面读数据</td>
</tr>
<tr>
<td>write</td>
<td>向文件或设备里写数据</td>
</tr>
<tr>
<td>close</td>
<td>关闭文件或设备</td>
</tr>
<tr>
<td>lseek</td>
<td>设置读写指针</td>
</tr>
<tr>
<td>fstat/stat/lstat</td>
<td>获取文件相关信息</td>
</tr>
<tr>
<td>mmap/msync</td>
<td>内存映射</td>
</tr>
</tbody></table>
<p>当一个进程（process）开始运行时，一般会有3个已经打开的文件描述符：    </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>标准输入</td>
</tr>
<tr>
<td>1</td>
<td>标准输出</td>
</tr>
<tr>
<td>2</td>
<td>标准错误</td>
</tr>
</tbody></table>
<p><strong>open</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path,<span class="hljs-keyword">int</span> oflags)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path,<span class="hljs-keyword">int</span> oflags,<span class="hljs-keyword">mode_t</span> mode)</span></span>;</code></pre>
<p>— 参数解释 —</p>
<ul>
<li>path:文件路径和文件名</li>
<li>oflags:</li>
</ul>
<pre><code class="hljs css"><span class="hljs-selector-tag">O_RDONLY</span>:以只读方式打开
<span class="hljs-selector-tag">O_WRONLY</span>:以只写方式打开
<span class="hljs-selector-tag">O_RDWR</span>:以读写方式打开
可选的组合模式:
<span class="hljs-selector-tag">O_APPEND</span>:把写入的数据追加在文件的末尾
<span class="hljs-selector-tag">O_TRUNC</span>:把文件的长度设置为0，丢弃已有的内容
<span class="hljs-selector-tag">O_CREAT</span>:如果需要，则创建文件，比较常用
<span class="hljs-selector-tag">O_EXCL</span>:与<span class="hljs-selector-tag">O_CREAT</span>一起使用，使用这个模式可以方式两个进程同时创建出一个文件，如果文件已经存在，则创建失败。</code></pre>

<ul>
<li>mode:<br>如果你使用O_CREAT标志的open来创建文件时，你必须使用三个参数的open函数。<br>第三个参数是文件的读/写/执行权限，一般是以0开头的三个八进制数，每个八进制数都是由1/2/4中的一个或几个进行相加得到的。<br>这三个八进制中，第一个表述属主的权限，第二个表示组的权限，第三个表示其他用户的权限。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>允许任何权限</td>
</tr>
<tr>
<td>1</td>
<td>禁止执行权限</td>
</tr>
<tr>
<td>2</td>
<td>禁止写权限</td>
</tr>
<tr>
<td>4</td>
<td>禁止执行权限</td>
</tr>
</tbody></table>
<ul>
<li>返回值：<br>open调用成功时会返回一个新的文件描述符（非负整数），在失败时返回-1。<br>值得注意的是，返回的新的文件描述符总是未使用描述符的最小值，这个特征非常有用，后面的文章会提到。</li>
</ul>
<p><strong>read</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fildes,<span class="hljs-keyword">void</span> *buf,<span class="hljs-keyword">size_t</span> nbytes)</span></span>;</code></pre>

<p>—参数解释—</p>
<ul>
<li>filedes: 文件描述符</li>
<li>buf: 存放数据的缓冲区</li>
<li>nbytes: 读取的字节数</li>
<li>返回值：返回实际读取的字节数，这可能会小于请求的字节数。如果返回的是0，表示已经到达文件尾，未读入任何数据，如果返回的是-1，表示read调用出现了错误。</li>
</ul>
<p><strong>write</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fildes,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf,<span class="hljs-keyword">size_t</span> nbytes)</span></span>;</code></pre>

<p>—参数解释—</p>
<ul>
<li>filedes: 文件描述符</li>
<li>buf: 要写入的缓冲区</li>
<li>nbytes: 准备写入的字节数，写入的是缓冲区的前nbytes个字节</li>
<li>返回值：返回实际写入的字节数，可能会小于nbytes，如果返回0，表示未写入任何数据，返回-1，表示发生错误。</li>
</ul>
<p><strong>close</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fildes)</span></span>;</code></pre>

<ul>
<li>终止文件描述符与其对应的文件之间的关系</li>
<li>释放文件描述符并使其能够重新使用</li>
<li>成功返回0，失败返回-1</li>
</ul>
<p><strong>lseek</strong></p>
<blockquote>
<p>lseek用于对文件描述符fildes的读写指针进行设置。</p>
</blockquote>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fileds,<span class="hljs-keyword">off_t</span> offset,<span class="hljs-keyword">int</span> whence)</span></span>;</code></pre>
<p>—参数解释—</p>
<ul>
<li>off_t offset：off_t是一个整数类型，offset表示偏移值</li>
<li>whence   </li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SEEK_SET</td>
<td>offset是一个绝对位置</td>
</tr>
<tr>
<td>SEEK_CUR</td>
<td>offset是一个相对于当前位置的相对位置</td>
</tr>
<tr>
<td>SEEK_END</td>
<td>offset是一个相对于文件尾的相对位置</td>
</tr>
</tbody></table>
<ul>
<li>返回值<br>返回从文件头到文件指针的字节偏移值，失败时返回-1.</li>
</ul>
<p><strong>fstat/stat/lstat</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fildes,struct stat *buf)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path,struct stat *buf)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path,struct stat *buf)</span></span>;</code></pre>

<ul>
<li>fstat 通过文件描述符返回相关的文件状态信息</li>
<li>stat/lstat 是通过文件名查到文件的状态信息</li>
<li>stat/lstat的区别：当查到的文件名是一个符号链接时，lstat返回的是该符号链接本身的信息，stat返回的是该链接指向的文件的信息。</li>
</ul>
<p><strong>mmap/msync</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> prot, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> fildes, <span class="hljs-keyword">off_t</span> off)</span></span>;</code></pre>

<p>函数功能</p>
<ul>
<li>mmap函数创建一段指向内存区域的指针，该内存区域与可以通过一个文件描述符访问的文件的内容相关联。</li>
<li>简单的说，就是把二进制文件的内容放在内存里，读写文件就可以使用指针操作，方便对某个字节进行读写操作。</li>
</ul>
<p>函数参数</p>
<ul>
<li>addr ： 分配的内存地址，一般设置为NULL,即由系统进行分配</li>
<li>len ： 需要分配的长度</li>
<li>prot: 设置内存访问的权限，有PORT_READ读/PORT_WRITE写/PORE_EXEC执行，按位OR操作</li>
<li>fildes ： 已经打开的文件描述符</li>
<li>off：内存访问的文件中数据的起始偏移地址</li>
</ul>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">msync</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> flags)</span></span>;</code></pre>

<p>函数功能：把映射的内存段写回到被映射的文件中</p>
<ul>
<li>flasgs：执行修改的具体方式</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>MS_ASYNC</td>
<td>采用异步写方式</td>
</tr>
<tr>
<td>MS_SYNC</td>
<td>采用同步写方式</td>
</tr>
<tr>
<td>MS_INVALIDATE</td>
<td>从文件中读回数据</td>
</tr>
</tbody></table>
<h2 id="二-标准IO库"><a href="#二-标准IO库" class="headerlink" title="二 标准IO库"></a>二 标准IO库</h2><p><strong>IO标准库提供的读写函数主要有以下几个</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>fopen</td>
<td>打开文件</td>
</tr>
<tr>
<td>fread</td>
<td>读取文件数据</td>
</tr>
<tr>
<td>fwrite</td>
<td>向文件写数据</td>
</tr>
<tr>
<td>flose</td>
<td>关闭文件流</td>
</tr>
<tr>
<td>fflush</td>
<td>写出缓冲区中所有的数据</td>
</tr>
<tr>
<td>fseek</td>
<td>移动读写指针</td>
</tr>
<tr>
<td>fgetc/getc/getchar</td>
<td>从文件流中获取一个字节</td>
</tr>
<tr>
<td>fputc/putc/putchar</td>
<td>输出一个字节到文件流中</td>
</tr>
<tr>
<td>fgets/gets</td>
<td>从文件流中获取字符串</td>
</tr>
</tbody></table>
<p>标注IO库stdio为底层I/O系统调用提供了一个通用的接口，还提供了许多复杂的函数用于格式化输出和扫面输入，它还负责满足设备的缓冲需求。<br>在标准IO库中，与文件描述符对应的是流（stream）,它是指向结构<strong>FILE</strong>的指针。<br>同样，在启动程序时，由3个流时自动打开的，分别是   </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>stdin</td>
<td>标准输入</td>
</tr>
<tr>
<td>stdout</td>
<td>标准输出</td>
</tr>
<tr>
<td>stderr</td>
<td>标准错误</td>
</tr>
</tbody></table>
<p><strong>fopen</strong></p>
<pre><code class="hljs c"><span class="hljs-function">FILE *<span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mode)</span></span>;</code></pre>
<p>— 参数解释 —</p>
<ul>
<li>filename:指定的文件</li>
<li>moed:指定的打开方式</li>
</ul>
<pre><code class="hljs css">"r" / "rb" :只读
"w" / "wb" : 只写,把文件长度截短为零
"a" / "ab" : 只写，新内容追加在文件尾
"r+"/"rb+"/"r+b" : 以更新方式打开，读/写
"w+"/"wb+"/"w+b" : 以更新方式打开,并把文件长度截短为0
"a+"/"ab+"/"a+b" : 以更新方式打开,新内容追加在文件尾</code></pre>

<ul>
<li>返回值：<br>成功返回一个非空的FILE * 指针<br>失败返回NULL</li>
</ul>
<p><strong>fread</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">fread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr,<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>,<span class="hljs-keyword">size_t</span> nitems,FILE *stream)</span></span>;</code></pre>

<p>—参数解释—</p>
<ul>
<li>ptr : 数据存放的缓冲区</li>
<li>size: 每次读取的长度</li>
<li>nitems: 读取的次数</li>
<li>stream:文件流</li>
<li>返回值：放到缓冲区里面的数据块的个数，而不是字节数</li>
</ul>
<p><strong>fwrite</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">fwrite</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *ptr,<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>,<span class="hljs-keyword">size_t</span> nitems,FILE *stream)</span></span>;</code></pre>

<p>—参数解释—</p>
<ul>
<li>ptr : 数据存放的缓冲区</li>
<li>size: 每次写入的长度</li>
<li>nitems: 写入的次数</li>
<li>stream:文件流</li>
<li>返回值：写入的个数</li>
</ul>
<p><strong>flose</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fclose</span><span class="hljs-params">(FILE *stream)</span></span>;</code></pre>
<ul>
<li>flose关闭文件流stream,使所有尚未写出的数据都写出，因为stdio会对数据进行缓冲，所以使用fclose是非常重要的。</li>
</ul>
<p><strong>fflush</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fflush</span><span class="hljs-params">(FILE *stream)</span></span>;</code></pre>
<ul>
<li>把文件流里面所有未写出的数据立刻写出，可以用这个函数来确保在试图读入一个用户响应之前，先向终端送出一个交互提示符。</li>
<li>flose()隐含执行了一次fflush函数</li>
</ul>
<p><strong>fseek</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fseek</span><span class="hljs-params">(FILE *stream,<span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> offset,<span class="hljs-keyword">int</span> whence)</span></span>;</code></pre>
<p>offset和whence的含义与lseek一样，不一样的时fseek返回的是一个整数，0表示成功，-1表示失败。</p>
<p><strong>fgetc/getc/getchar</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fgetc</span><span class="hljs-params">(FILE stream)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getc</span><span class="hljs-params">(FILE *stream)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getchar</span><span class="hljs-params">()</span></span>;</code></pre>

<ul>
<li>fgetc从文件流里面取出下一个字节并把它作为字符返回，当到达文件尾部或者发生错误时返回<strong>EOF</strong>.</li>
<li>getc与fgetc的作用一样,但是它有可能被声明成一个宏（被ISO C声明为一个宏），所以它不可以作为函数指针，宏会需要更多的内存空间，但是有更高的执行效率。</li>
<li>getchar的作用相当于getc(stdin),从标准里读取下一个字符</li>
</ul>
<p><strong>fputc/putc/putchar</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fputc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c,FILE *stream)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">putc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c,FILE *stream)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">putchar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;</code></pre>

<p>类似于<code>fgetc/fget/getchar</code>之间的关系<br>注意，<strong>putchar和getchar都是把字符当作int类型而不是char类型来使用的，这就允许文件尾(EOF)标识取值-1</strong></p>
<p><strong>fgets/gets</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">fgets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">int</span> n,FILE *stream)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span>;</code></pre>

<ul>
<li>fgets把读到的字符写到S所指向的字符串里，<strong>直到遇到换行符或者文件尾</strong>，也会把换行符接受到字符串里，<strong>并加上结尾字符\0</strong>，一次调用最多传输<strong>n-1</strong>个字符，因为最后一个字符必须是<strong>\0</strong><br>成功时，返回指向s的指针，失败时，返回一个空指针</li>
<li>gets类似于fgets，只不过它是从标准输入读取数据并<strong>丢弃换行符，并在结尾加上null字符</strong></li>
</ul>
<h2 id="三-格式化输入输出"><a href="#三-格式化输入输出" class="headerlink" title="三 格式化输入输出"></a>三 格式化输入输出</h2><h3 id="1-标准输出函数"><a href="#1-标准输出函数" class="headerlink" title="1 标准输出函数"></a>1 标准输出函数</h3><p><strong>printf/fprintf/sprintf</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format,...)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format,...)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fprintf</span><span class="hljs-params">(FILE *stream,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format,...)</span></span>;</code></pre>

<ul>
<li>printf   把自己的输出送到标准输出</li>
<li>fprintf  把自己的输出送到一个指定的文件流##</li>
<li>sprintf  把自己的输出和一个结尾空字符写到字符串s里面</li>
</ul>
<p><strong>scanf/fscanf/sscanf</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">scanf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format,...)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fscanf</span><span class="hljs-params">(FILE *stream,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format,..)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sscanf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format,...)</span></span>;</code></pre>

<ul>
<li>scanf 读入标准输入的值保存到对应的变量里去，这些变量的类型必须正确并且精确匹配格式字符串，斗则，内存数据会遭到破坏，使程序崩溃<br>使用%c控制符从输入中读取一个自读，它<strong>不会跳过起始的空白字符</strong><br>使用%s控制符来扫描字符串，它<strong>会跳过起始的空白字符</strong><br>返回值是成功读取的数据项个数<br>例：</li>
</ul>
<pre><code class="hljs c">给定下面的输入行：
hello, <span class="hljs-number">1234</span>, <span class="hljs-number">5.678</span>, X, <span class="hljs-built_in">string</span> to the <span class="hljs-built_in">end</span> of the <span class="hljs-built_in">line</span>
下面的<span class="hljs-built_in">scanf</span>会正确读取<span class="hljs-number">4</span>个数据项：
<span class="hljs-keyword">char</span> s[<span class="hljs-number">256</span>];
<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">float</span> f;
<span class="hljs-keyword">char</span> c;
<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"Hello,%d,%g, %c, %[^\n]"</span>,&amp;n,&amp;f,&amp;c,s);
<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * 1 注意%c前面有空格，是为了匹配字符X之前的空格</span>
<span class="hljs-comment"> * 2 %[^\n]: 表示遇到\n停止读取字符串</span>
<span class="hljs-comment"> */</span></code></pre>

<ul>
<li>fscanf  从文件流读取数据到对应项中</li>
<li>sscanf  从字符串读取数据到对应项中</li>
</ul>
<h2 id="四-带缓冲的IO与不带缓冲的IO"><a href="#四-带缓冲的IO与不带缓冲的IO" class="headerlink" title="四 带缓冲的IO与不带缓冲的IO"></a>四 带缓冲的IO与不带缓冲的IO</h2><p>底层系统调用提供的IO读写操作是不带缓存的IO<br>标准库stdio提供的IO读写操作是带缓存的IO</p>
<p>看下面两个函数</p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fildes,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf,<span class="hljs-keyword">size_t</span> nbytes)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">fwrite</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *ptr,<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>,<span class="hljs-keyword">size_t</span> nitems,FILE *stream)</span></span>;</code></pre>

<p>在数据读入buff或者是ptr之前，都会先写到内核所设置的缓冲存储器中。<strong>如果存储器未满，则并不将其排入到输出队列，直到缓存写满或者内核需要重新使用此缓存时才将其排入输出队列，再进行实际的IO操作，这种技术叫延迟写</strong></p>
<p>标准IO在系统调用上多加了一个缓冲区，也因此引入了流的概念，FILE实际上包含了管理流所需要的所有信息：</p>
<ul>
<li>实际的IO文件描述符</li>
<li>指向流缓存的指针</li>
<li>缓存长度</li>
<li>当前在缓存中的字节数     </li>
</ul>
<p>标准IO提供三种缓存模式：</p>
<ul>
<li>全缓存，即填满IO缓存后才执行IO操作</li>
<li>行缓存，即输入输出遇到新行符或者缓存满时，才执行真正的IO操作，stdin,stdout通常是行缓存，当stdout被重定向到一个具体的文件时，那么它是全缓存的</li>
<li>无缓存，相当于read write，stderr时不带任何缓存的</li>
</ul>
<p>带缓存的IO虽然数据复制了两次，但是无需考虑缓存以及最佳IO长度的选择，因此它不比read/write慢多少</p>
<p>如何直观的看到标准IO库的缓存效果，看下面的例子：</p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">char</span> buff[<span class="hljs-number">1024</span>];
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"This Line Should be Cached..."</span>);
	sleep(<span class="hljs-number">3</span>);    <span class="hljs-comment">//这时候在终端上是看不到任何输出</span>
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nThis Line Should be Cached Again"</span>);  <span class="hljs-comment">//这时候可以看到第一个printf的输出，因为被换行符刷新了</span>
	sleep(<span class="hljs-number">3</span>);  
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"This Line Should Not be Cached Again\n"</span>); <span class="hljs-comment">//这时候可以看到第二个和第三个printf的输出，因为被结尾的\n刷新</span>
	<span class="hljs-comment">//fgets(buff,20,stdin);		// buff中带'\n'</span>
	gets(buff);					<span class="hljs-comment">// buff中不带'\n'</span>
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s "</span>,buff);
&#125;</code></pre>


<h2 id="五-目录操作"><a href="#五-目录操作" class="headerlink" title="五 目录操作"></a>五 目录操作</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>opendir</td>
<td>打开目录流</td>
</tr>
<tr>
<td>readdir</td>
<td>扫描目录</td>
</tr>
<tr>
<td>telldir</td>
<td>返回目录当前位置</td>
</tr>
<tr>
<td>seekdir</td>
<td>设置目录流指针</td>
</tr>
<tr>
<td>closedir</td>
<td>关闭一个目录流</td>
</tr>
</tbody></table>
<p>Linux中，与目录操作有关的头文件在diret.h中，它们使用一个名为DIR的结构体作为目录操作的基础，被称为<strong>目录流</strong>的指针指向这个结构体。</p>
<p><strong>opendir</strong></p>
<pre><code class="hljs c"><span class="hljs-function">DIR *<span class="hljs-title">opendir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span>;</code></pre>

<ul>
<li>打开并建立一个目录流，如果失败，则返回一个空指针</li>
</ul>
<p><strong>readdir</strong></p>
<pre><code class="hljs c"><span class="hljs-function">struct dirent *<span class="hljs-title">readdir</span><span class="hljs-params">(DIR *dirp)</span></span>;</code></pre>

<ul>
<li>readdir返回一个指针，指向目录流的下一个目录项的有关资料，如果发生错误或者到达目录为，则返回NULL</li>
<li>struct dirent 包含的内容：</li>
</ul>
<pre><code class="hljs c"><span class="hljs-keyword">ino_t</span> d_ino: 文件的inode节点号
<span class="hljs-keyword">char</span> d_name[]: 文件的名字</code></pre>

<p><strong>telldir</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">telldir</span><span class="hljs-params">(DIR *dirp)</span></span>;</code></pre>

<ul>
<li>返回值记录一个目录流的当前位置</li>
</ul>
<p><strong>seekdir</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">seekdir</span><span class="hljs-params">(DIR *dirp,<span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> loc)</span></span>;</code></pre>

<ul>
<li>设置目录流dirp的目录项指针，loc的值用来设置指针位置，它应该通过<strong>telldir</strong>来获得</li>
</ul>
<p><strong>closedir</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">closedir</span><span class="hljs-params">(DIR *dirp)</span></span>;</code></pre>

<ul>
<li>关闭一个目录流并释放与之关联的资源，执行成功返回0，错误返回-1</li>
</ul>
<h2 id="六-文件和目录的维护"><a href="#六-文件和目录的维护" class="headerlink" title="六 文件和目录的维护"></a>六 文件和目录的维护</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>chmod</td>
<td>改变文件的访问权限</td>
</tr>
<tr>
<td>unlink/link/symlink</td>
<td>删除/建立文件链接</td>
</tr>
<tr>
<td>mkdir/rmdir</td>
<td>建立/删除目录</td>
</tr>
<tr>
<td>chdir/getcwd</td>
<td>获取当前目录</td>
</tr>
</tbody></table>
<p><strong>chmod</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chmod</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path,<span class="hljs-keyword">mode_t</span> mode)</span></span>;</code></pre>

<ul>
<li>path参数指定的文件被修改为具有mode参数给出的权限，参数mode与open中的一样</li>
</ul>
<p><strong>unlink/link/symlink</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path2)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">symlink</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path2)</span></span>;</code></pre>

<ul>
<li>unlink,用来删除一个文件的目录项并减少它的连接数，成功返回0，失败返回-1，如果一个文件的链接数减少到0并且没有进程打开它，这个文件就会被删除</li>
<li>link 将创建一个指向已有文件path1的新连接，新目录由path2给出</li>
<li>symlink 以类似的方式创建符号链接</li>
</ul>
<p><strong>mkdir/rmdir</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mkdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path,<span class="hljs-keyword">mode_t</span> mode)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rmdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;</code></pre>

<ul>
<li>mkdir 用于创建目录，权限由mode参数给出</li>
<li>rmdir 用于删除目录，只有在目录为空时才行</li>
</ul>
<p><strong>chdir/getcwd</strong></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buf,<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)</span></span>;</code></pre>

<ul>
<li>chdir 用于切换目录</li>
<li>getcwd 用于获取当前目录，把当前目录的名字写到buff里面，size参数给出了buff的长度</li>
</ul>
<h2 id="七-proc文件系统"><a href="#七-proc文件系统" class="headerlink" title="七 /proc文件系统"></a>七 /proc文件系统</h2><p>Linux提供了一个特殊的文件系统procfs,它通常以/proc目录的形式呈现<br>  </p>
<p>该目录中包含了许多驱动程序和内核信息，只要应用程序具有正确的访问权限，它们就可以通过读写这些文件来获得信息或者设置参数<br></p>
<ul>
<li>这是我阿里云服务器的/proc目录列表</li>
</ul>
<pre><code class="hljs c"><span class="hljs-number">1</span>      <span class="hljs-number">143</span>    <span class="hljs-number">23</span>     <span class="hljs-number">430</span>   <span class="hljs-number">54</span>    <span class="hljs-number">6875</span>  <span class="hljs-number">985</span>          <span class="hljs-built_in">interrupts</span>   modules        thread-self
<span class="hljs-number">10</span>     <span class="hljs-number">15</span>     <span class="hljs-number">24</span>     <span class="hljs-number">431</span>   <span class="hljs-number">55</span>    <span class="hljs-number">6893</span>  acpi         iomem        mounts         timer_list
<span class="hljs-number">11</span>     <span class="hljs-number">16</span>     <span class="hljs-number">274</span>    <span class="hljs-number">446</span>   <span class="hljs-number">56</span>    <span class="hljs-number">6894</span>  buddyinfo    ioports      mtrr           timer_stats
<span class="hljs-number">11293</span>  <span class="hljs-number">163</span>    <span class="hljs-number">27448</span>  <span class="hljs-number">47</span>    <span class="hljs-number">57</span>    <span class="hljs-number">6911</span>  bus          irq          net            tty
<span class="hljs-number">11296</span>  <span class="hljs-number">165</span>    <span class="hljs-number">27449</span>  <span class="hljs-number">4700</span>  <span class="hljs-number">573</span>   <span class="hljs-number">7</span>     cgroups      kallsyms     pagetypeinfo   uptime
<span class="hljs-number">12</span>     <span class="hljs-number">166</span>    <span class="hljs-number">27456</span>  <span class="hljs-number">474</span>   <span class="hljs-number">58</span>    <span class="hljs-number">7081</span>  cmdline      kcore        partitions     version
<span class="hljs-number">13</span>     <span class="hljs-number">17</span>     <span class="hljs-number">27457</span>  <span class="hljs-number">479</span>   <span class="hljs-number">59</span>    <span class="hljs-number">786</span>   consoles     keys         sched_debug    version_signature
<span class="hljs-number">133</span>    <span class="hljs-number">18</span>     <span class="hljs-number">27458</span>  <span class="hljs-number">48</span>    <span class="hljs-number">599</span>   <span class="hljs-number">8</span>     cpuinfo      key-users    schedstat      vmallocinfo
<span class="hljs-number">134</span>    <span class="hljs-number">19</span>     <span class="hljs-number">27507</span>  <span class="hljs-number">49</span>    <span class="hljs-number">60</span>    <span class="hljs-number">81</span>    crypto       kmsg         scsi           vmstat
<span class="hljs-number">135</span>    <span class="hljs-number">197</span>    <span class="hljs-number">28</span>     <span class="hljs-number">5</span>     <span class="hljs-number">61</span>    <span class="hljs-number">811</span>   devices      kpagecgroup  self           zoneinfo
<span class="hljs-number">137</span>    <span class="hljs-number">2</span>      <span class="hljs-number">29</span>     <span class="hljs-number">50</span>    <span class="hljs-number">62</span>    <span class="hljs-number">82</span>    diskstats    kpagecount   slabinfo
<span class="hljs-number">138</span>    <span class="hljs-number">20</span>     <span class="hljs-number">3</span>      <span class="hljs-number">504</span>   <span class="hljs-number">6539</span>  <span class="hljs-number">874</span>   dma          kpageflags   softirqs
<span class="hljs-number">139</span>    <span class="hljs-number">20824</span>  <span class="hljs-number">30</span>     <span class="hljs-number">505</span>   <span class="hljs-number">6559</span>  <span class="hljs-number">882</span>   driver       loadavg      stat
<span class="hljs-number">14</span>     <span class="hljs-number">21</span>     <span class="hljs-number">31</span>     <span class="hljs-number">51</span>    <span class="hljs-number">6581</span>  <span class="hljs-number">9</span>     execdomains  locks        swaps
<span class="hljs-number">140</span>    <span class="hljs-number">218</span>    <span class="hljs-number">394</span>    <span class="hljs-number">52</span>    <span class="hljs-number">6584</span>  <span class="hljs-number">930</span>   fb           mdstat       sys
<span class="hljs-number">141</span>    <span class="hljs-number">22</span>     <span class="hljs-number">411</span>    <span class="hljs-number">5220</span>  <span class="hljs-number">68</span>    <span class="hljs-number">952</span>   filesystems  meminfo      sysrq-trigger
<span class="hljs-number">142</span>    <span class="hljs-number">22921</span>  <span class="hljs-number">425</span>    <span class="hljs-number">53</span>    <span class="hljs-number">6857</span>  <span class="hljs-number">953</span>   fs           misc         sysvipc</code></pre>

<ul>
<li>常用的信息</li>
</ul>
<pre><code class="hljs css">cat /proc/cpuinfo    输出cpu信息
cat /proc/meminfo    输出内存使用情况
cat /proc/version    输出内核版本信息
... ...</code></pre>

<h2 id="八-锁文件"><a href="#八-锁文件" class="headerlink" title="八 锁文件"></a>八 锁文件</h2><blockquote>
<p>Linux提供了很多种方法来实现文件锁定，其中最简单的方法就是以原子操作的方式创建锁文件，所谓“原子操作”就是在创建锁文件时，这个过程不允许被打断。<br></p>
</blockquote>
<p>这种方式却把它所创建的文件是唯一的，而且这个文件不可能被其他程序在同一时间创<br></p>
<ul>
<li><p>锁文件只是<strong>建议锁</strong>，而不是<strong>强制锁</strong></p>
<blockquote>
<p>建议锁：进程在对某一个文件进行操作时，没有检测是否加锁或者直接向文件写入数据，内核是不会加以阻止的<br>强制锁：OS内核的文件锁，应用程序对文件进行读写操作时，OS内核会检测文件是否加锁，如果加锁将导致操作失败</p>
</blockquote>
</li>
<li><p>锁文件的实现是通过open函数调用的<strong>O_EXCL</strong>标志来完成的   </p>
</li>
</ul>
<ul>
<li>示例代码</li>
</ul>
<pre><code class="hljs c"><span class="hljs-comment">/*</span>
<span class="hljs-comment"> *  文件锁</span>
<span class="hljs-comment"> */</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
        <span class="hljs-keyword">int</span> file_desc;
        <span class="hljs-keyword">int</span> save_error;

        file_desc = <span class="hljs-built_in">open</span>(<span class="hljs-string">"./LCK.test"</span>,O_RDWR | O_CREAT | O_EXCL,<span class="hljs-number">0444</span>);
        <span class="hljs-keyword">if</span>(file_desc == <span class="hljs-number">-1</span>)
                &#123;
                        save_error = errno;
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"open failed with error %d \n"</span>,save_error);
                &#125;
        <span class="hljs-keyword">else</span>
                &#123;
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" open succeeded \n"</span>);
                &#125;
        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);
&#125;</code></pre>


<p>通过O_EXCL标志以原子操作的方式创建了一个锁文件，但是需要注意以下两点：</p>
<ul>
<li>1 如果需要保证这个文件的名字是唯一的，那么所有的进程在创建文件时都需要加上O_EXCL，如果这个文件已经存在，则open()调用会返回错误</li>
<li>2 如果其他进程不加O_EXCL标志，则可以直接读写这个文件，因为锁文件是<strong>建议锁而不是强制锁</strong></li>
</ul>
<h2 id="九-文件锁"><a href="#九-文件锁" class="headerlink" title="九 文件锁"></a>九 文件锁</h2><blockquote>
<p>Linux至少提供两种系统调用，分别是fcntl系统调用和lockf系统调用，这些系统调用的好处是可以实现文件的<strong>区域锁定</strong>和<strong>段锁定</strong><br>fcntl和lockf使用不同的底层实现，因此两者不能混合使用<br>fcntl和lockf<strong>都是建议锁，而不是强制锁</strong></p>
</blockquote>
<h3 id="fcntl系统调用"><a href="#fcntl系统调用" class="headerlink" title="fcntl系统调用"></a>fcntl系统调用</h3><ul>
<li>fcntl对一个打开的文件描述符进行操作，并能根据command参数完成不同的任务</li>
</ul>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fildes,<span class="hljs-keyword">int</span> command,struct flock *flock_structure)</span></span>;</code></pre>

<ul>
<li>command选项如下：</li>
</ul>
<pre><code class="hljs c"><span class="hljs-comment">/* 获取锁信息，信息存储在 struct flock 结构体中 */</span>
F_GETLK

<span class="hljs-comment">/* 加锁或者解锁，加锁或者解锁的信息在 struct flock 结构体中  */</span>
F_SETLK

<span class="hljs-comment">/* 与SETLK类似，但在无法获取锁时，这个调用将等待直到 1 获取锁 2 收到一个信号 才会返回 */</span>
F_SETLKW</code></pre>

<ul>
<li>struct flock的成员如下：</li>
</ul>
<pre><code class="hljs c">short l_type
short l_whence
<span class="hljs-keyword">off_t</span> l_start
<span class="hljs-keyword">off_t</span> l_len
<span class="hljs-keyword">pid_t</span> l_pid</code></pre>

<ul>
<li>l_type</li>
</ul>
<pre><code class="hljs c"><span class="hljs-comment">/*</span>
<span class="hljs-comment"> * 共享锁/读锁 </span>
<span class="hljs-comment"> * 许多不同的进程可以拥有文件同一区域的共享锁</span>
<span class="hljs-comment"> * 只要任一进程拥有共享锁，则没有进程可以获得该区域的独占锁</span>
<span class="hljs-comment"> * 简单的说，这把锁的作用是使文件不让进程上锁</span>
<span class="hljs-comment"> * 要想获取共享锁，文件必须以读或者读写的方式打开</span>
<span class="hljs-comment"> * 一般读文件的进程设置共享锁</span>
<span class="hljs-comment"> */</span>
F_RDLCK

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> *解锁，清除锁</span>
<span class="hljs-comment"> */</span>
F_UNLCK

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * 独占锁/写锁 </span>
<span class="hljs-comment"> * 有且只有一个进程可以在文件的特定区域拥有一把独占锁</span>
<span class="hljs-comment"> * 只要有一个进程设置了独占锁，其他任何进程都不可以设置任何锁</span>
<span class="hljs-comment"> * 获取独占锁的前提是，文件必须要以写或者读写的方式打开，（否则没有获取独占锁，因为不需要修改文件)</span>
<span class="hljs-comment"> * 一般写文件的进程设置独占锁</span>
<span class="hljs-comment"> */</span>
F_WRLCK</code></pre>

<ul>
<li>l_whence</li>
</ul>
<pre><code class="hljs c"><span class="hljs-comment">/* 文件头 */</span>
SEEK_SET
<span class="hljs-comment">/* 当前位置 */</span>
SEEK_CUR
<span class="hljs-comment">/* 文件尾 */</span>
SEEK_END</code></pre>

<ul>
<li><p>l_start / l_len<br>l_whence定义了l_start的相对偏移值，l_start定义了该区域的第一个字节，l_len定义了改区域的字节数</p>
</li>
<li><p>l_pid<br>l_pid记录 持有锁的进程</p>
</li>
</ul>
<p><strong>示例代码</strong></p>
<p>1 在文件上加锁</p>
<pre><code class="hljs c"><span class="hljs-comment">/*</span>
<span class="hljs-comment"> *	文件锁 </span>
<span class="hljs-comment"> *  use fcntl</span>
<span class="hljs-comment"> */</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span>

<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *test_file = <span class="hljs-string">"./tmp/test_lock.txt"</span>;

<span class="hljs-comment">/*</span>
<span class="hljs-comment">The structure describing an advisory lock.  This is the type of the third </span>
<span class="hljs-comment">argument to `fcntl' for the F_GETLK, F_SETLK, and F_SETLKW requests.  </span>
<span class="hljs-comment"></span>
<span class="hljs-comment">struct flock</span>
<span class="hljs-comment">  &#123;</span>
<span class="hljs-comment">    __off_t l_start;	 	Offset where the lock begins.  </span>
<span class="hljs-comment">    __off_t l_len;		    Size of the locked area; zero means until EOF.  </span>
<span class="hljs-comment">    __pid_t l_pid;			Process holding the lock.  </span>
<span class="hljs-comment">    short int l_type;		Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  </span>
<span class="hljs-comment">    short int l_whence;		Where `l_start' is relative to (like `lseek').  </span>
<span class="hljs-comment">  &#125;;</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">int</span> file_desc;
	<span class="hljs-keyword">int</span> byte_count;
	<span class="hljs-keyword">char</span> * byte_to_write = <span class="hljs-string">'A'</span>;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">flock</span> <span class="hljs-title">region_1</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">flock</span> <span class="hljs-title">region_2</span>;</span>
	<span class="hljs-keyword">int</span> res;

	file_desc = <span class="hljs-built_in">open</span>(test_file,O_RDWR | O_CREAT , <span class="hljs-number">0666</span>);
	<span class="hljs-keyword">if</span>(!file_desc)
		&#123;
			<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"unable to open file \n"</span>);
			<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
		&#125;
	<span class="hljs-keyword">for</span>(byte_count = <span class="hljs-number">0</span>;byte_count &lt; <span class="hljs-number">100</span>;byte_count ++)
		&#123;
			<span class="hljs-built_in">write</span>(file_desc,byte_to_write,<span class="hljs-number">1</span>);
		&#125;
	<span class="hljs-comment">/* 10-30 字节设置为区域 1 ，设置共享锁 */</span>
	region_1.l_type = F_RDLCK;
	region_1.l_whence = SEEK_SET;
	region_1.l_start =  <span class="hljs-number">10</span>;
	region_1.l_len = <span class="hljs-number">20</span>;

	<span class="hljs-comment">/* 40-50 字节设置为区域 2 ，设置独占锁 */</span>
	region_2.l_type = F_WRLCK;
	region_2.l_whence = SEEK_SET;
	region_2.l_start =  <span class="hljs-number">40</span>;
	region_2.l_len = <span class="hljs-number">10</span>;

	<span class="hljs-comment">/* 锁定文件 */</span>
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">" process %d locking file \n "</span>,getpid());
	res = fcntl(file_desc,F_SETLK,&amp;region_1); <span class="hljs-comment">/* F_SETLK : 区域加锁 */</span>
	<span class="hljs-keyword">if</span>(res == <span class="hljs-number">-1</span>) <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"failed to lock region 1\n"</span>);
	res = fcntl(file_desc,F_SETLK,&amp;region_2); <span class="hljs-comment">/* F_SETLK : 区域加锁 */</span>
	<span class="hljs-keyword">if</span>(res == <span class="hljs-number">-1</span>) <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"failed to lock region 2\n"</span>);

	sleep(<span class="hljs-number">60</span>);

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"process %d close file \n"</span>,getpid());
	<span class="hljs-built_in">close</span>(file_desc);
	<span class="hljs-built_in">exit</span>(EXIT_SUCCESS);
&#125;</code></pre>

<p>2 在另一个进程中读出这些锁</p>
<pre><code class="hljs c">
<span class="hljs-comment">/*</span>
<span class="hljs-comment"> *	测试文件中不同部分的文件锁</span>
<span class="hljs-comment"> *  use fcntl </span>
<span class="hljs-comment"> */</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span>

<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *test_file = <span class="hljs-string">"./tmp/test_lock.txt"</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE_TO_TRY 5</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_lock_info</span><span class="hljs-params">(struct flock * lck)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">int</span> file_desc;
	<span class="hljs-keyword">int</span> res;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">flock</span> <span class="hljs-title">region_to_test</span>;</span>
	<span class="hljs-keyword">int</span> start_byte;

	file_desc = <span class="hljs-built_in">open</span>(test_file,O_RDWR | O_CREAT,<span class="hljs-number">0X666</span>);
	<span class="hljs-keyword">if</span>(!file_desc)
		&#123;	
			<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"Unable to open file \n"</span>);
		&#125;
	<span class="hljs-keyword">for</span>(start_byte = <span class="hljs-number">0</span>;start_byte &lt; <span class="hljs-number">99</span> ;start_byte += SIZE_TO_TRY)
		&#123;
			<span class="hljs-comment">/* 独占锁 */</span>
			region_to_test.l_type = F_WRLCK;
			region_to_test.l_whence = SEEK_SET;	
			region_to_test.l_start = start_byte;
			region_to_test.l_len = SIZE_TO_TRY;
			region_to_test.l_pid = <span class="hljs-number">-1</span>;
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"testing F_WRLCK on region from %d to %d \n"</span>,start_byte,start_byte+SIZE_TO_TRY);

			<span class="hljs-comment">/*  		F_GETLK   : 获取锁信息 */</span>
			res = fcntl(file_desc,F_GETLK,&amp;region_to_test);
			<span class="hljs-keyword">if</span>(res == <span class="hljs-number">-1</span>)
				&#123;
					<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"lock fail,F_WRLCK retutn \n"</span>);
					<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
				&#125;
			<span class="hljs-keyword">if</span>(region_to_test.l_pid != <span class="hljs-number">-1</span>)
				&#123;
					<span class="hljs-built_in">printf</span>(<span class="hljs-string">"lock fail,F_WRLCK retutn \n"</span>);
					show_lock_info(&amp;region_to_test);						
				&#125;
			<span class="hljs-keyword">else</span>
				&#123;
					<span class="hljs-built_in">printf</span>(<span class="hljs-string">" F_WRLCK - Lock would succeed \n"</span>);
				&#125;
			

			<span class="hljs-comment">/* 共享锁 */</span>
			region_to_test.l_type = F_RDLCK;
			region_to_test.l_whence = SEEK_SET;
			region_to_test.l_start = start_byte;
			region_to_test.l_len = SIZE_TO_TRY;
			region_to_test.l_pid = <span class="hljs-number">-1</span>;
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"testing F_RDLCK on region from %d to %d \n"</span>,start_byte,start_byte+SIZE_TO_TRY);

			<span class="hljs-comment">/*      F_GETLK : 获取锁信息 */</span>
			res = fcntl(file_desc,F_GETLK,&amp;region_to_test);
			<span class="hljs-keyword">if</span>(res == <span class="hljs-number">-1</span>)
				&#123;
					<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"lock fail,F_RDLCK retutn \n"</span>);
					<span class="hljs-built_in">exit</span>(EXIT_FAILURE);
				&#125;
			<span class="hljs-keyword">if</span>(region_to_test.l_pid != <span class="hljs-number">-1</span>)
				&#123;
					<span class="hljs-built_in">printf</span>(<span class="hljs-string">"lock fail,F_RDLCK retutn \n"</span>);
					show_lock_info(&amp;region_to_test);						
				&#125;
			<span class="hljs-keyword">else</span>
				&#123;
					<span class="hljs-built_in">printf</span>(<span class="hljs-string">" F_RDLCK - Lock would succeed \n"</span>);
				&#125;

			
		&#125;
		<span class="hljs-built_in">close</span>(file_desc);
		<span class="hljs-built_in">exit</span>(EXIT_SUCCESS);
	
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_lock_info</span><span class="hljs-params">(struct flock * lck)</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">" \t1_type %d "</span>, 	lck-&gt;l_type);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">" \t1_whence %d "</span>,  lck-&gt;l_whence);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">" \t1_start %d "</span>,   lck-&gt;l_start);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">" \t1_len %d "</span>,      lck-&gt;l_len);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">" \t1_pid %d \n"</span>,      lck-&gt;l_pid);
&#125;</code></pre>

<h3 id="lockf系统调用"><a href="#lockf系统调用" class="headerlink" title="lockf系统调用"></a>lockf系统调用</h3><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lockf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fildes,<span class="hljs-keyword">int</span> function,<span class="hljs-keyword">off_t</span> size_to_lock)</span></span>;</code></pre>

<ul>
<li>function定义如下：</li>
</ul>
<pre><code class="hljs css"><span class="hljs-selector-tag">F_ULOCK</span>:解锁
<span class="hljs-selector-tag">F_LOCK</span> : 设置独占锁
<span class="hljs-selector-tag">F_TLOCK</span> : 测试并设置独占锁
<span class="hljs-selector-tag">F_TEST</span> : 测试其他进程设置的锁</code></pre>

<ul>
<li>size_to_lock</li>
</ul>
<p>操作的字节数，从文件的当前偏移值开始计算</p>
<blockquote>
<p>lockf的接口更加简单，但是功能和灵活性比fcntl差一些</p>
</blockquote>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Unix%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/">Unix环境编程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Unix%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/">Unix环境编程</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2019/06/01/C++%E8%84%91%E5%9B%BE/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++脑图</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2019/05/18/Linux%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/">
                        <span class="hidden-mobile">Linux应用程序调试方法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script defer src="https://cdn.staticfile.org/valine/1.4.14/Valine.min.js" ></script>

  <script type="text/javascript">
    var oldLoadVa = window.onload;
    window.onload = function () {
      oldLoadVa && oldLoadVa();

      new Valine({
        el: "#vcomments",
        app_id: "xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz",
        app_key: "erIpQac4azoCmgfBB7Dl9maa",
        placeholder: "说点什么吧",
        path: window.location.pathname,
        avatar: "retro",
        meta: ["nick","mail","link"],
        pageSize: "10",
        lang: "zh-CN",
        highlight: false,
        recordIP: false,
        serverURLs: "",
      });
    };
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  
    <!-- APlayer 音乐播放器 -->
    <div id="aplayer"></div>
    <script defer src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js" ></script>
<link  rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
<script type="text/javascript">
  var oldLoadAp = window.onload;
  window.onload = function () {
    oldLoadAp && oldLoadAp();

    new APlayer({
      container: document.getElementById('aplayer'),
      fixed: true,
      autoplay: 'false' === 'true',
      loop: 'all',
      order: 'random',
      theme: '#b7daff',
      preload: 'none',
      audio: [{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]
    });
  }
</script>

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    
  <!-- 备案信息 -->
  <div>
    <a href="http://beian.miit.gov.cn/" target="_blank" class="beian-icp"
       rel="nofollow noopener">京ICP证123456号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon" />
        
        <span>京公网安备12345678号</span>
      </a>
     
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 6,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Linux文件操作&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>
